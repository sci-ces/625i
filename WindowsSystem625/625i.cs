/*
 * 
 * 
 *  Note for using dev system
 *  (flow system not working May 2020)
 *  to run without flow, comment out error 111
 *  to ship make sure line is re-enabled 
 *  may set pre-compile setting to warn of this value not being re-enabled.
 *  
 *  Note version 1.2.0.54 and beyond have the following updates:
 *  precompile settings that allow control of:
 *  TURNON_NIHARDWARE      TURNON_LOWFLOW    TURNON_TUBESEASONING
 *  To perform debug, simply place a # before each of the TURNON_ items
 *  
 *  1.2.0.54 update 5 min mode tuning to 36 seconds
 *  add log of seconds to acquire to internal log file
 *  2 hour mode start time fix
 *  
 *  
 *   
 */





using MetroFramework;
using MetroFramework.Forms;
// for modbus 
using Modbus.Data;
using Modbus.Device;
using myxrsfp;
using NationalInstruments;
using NationalInstruments.DAQmx;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
// for SQLite
using System.Data.SQLite;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.IO.Compression;    //required for file zipping 
using System.IO.Ports;
using System.Linq;
//using System.Windows.Forms;   //needed for method invoker
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions; //for parsing ez4axis response strings
using System.Threading;
using System.Timers;
using System.Windows.Forms;
using System.Windows.Input;


namespace WindowsSystem625
{

    public partial class Form1 : MetroForm
    {


        static string StatusDisplayErrorMessage = string.Empty;
        static string StatusDisplayWarningMessage = string.Empty;

        const int FAIL_NOZZLE = 2;

        //static 60sec counter value for flow average checking each minute
        static int FlowAvgCounter = 0;

        //static values from init flow calibration
        static double init_TnistCA;
        static double init_PnistCA;
        static double init_PSnistCA;
        static double init_yint;
        static double init_slope;
        static double init_NormalFlow;
        static int flowCalCompleted = 0;
        static int flowCalStarted = 0;

        //counters to check for proper state machine function:
        public static int readTimerLockedCounter = 0;
        public static int InterlockTimerCounter = 0;
        public static int ManualAcqLockCounter = 0;
        public static int LeakCheckLockCounter = 0;
        public static int AcquisitionLockCounter = 0;
        public static int EcalLockCounter = 0;
        public static int FiveMinuteLockCounter = 0;
        public static int TubeSeasoningLockCounter = 0;
        public static int UpscaleLockCounter = 0;


        //
        public static int troubleshooting = 0;
        public static int TubeSeasoningTime = 0;
        //public static int TubeSeasoningDone = 0;  //controls start of ecal after tube seasoning in "warm up" Set at end of Tube Seasoning; polled for set and then cleared by Warm Up start-of-Ecal logic
        public static int WarmUpActive = 0;
        public static int returnManualFWHome = FAIL;
        public static int rampActive = 0;  //set by caller to rampxrays, cleared by rampxrays complete
        public static int RampXraysToZeroActive = 0;

        public static int rampErrorIHigh = 0;
        public static int rampErrorILow = 0;
        public static int rampErrorVHigh = 0;
        public static int rampErrorVLow = 0;
        public static int checkLastValueCounter = 0;

        static public int filterWheelReturnValue = 0;
        static public int fwRetry = 0;
        static public int fwECstart = 0;
        static public int fwECend = 0;
        //static public int HaltEnabled = 1;  //Enable Halt function.  Once called it will disable Halt.  Re-enable halt via Run. 

        const string csvPathName = "C:/Process_Data_CSV/";
        const string csvPathNameArchive = "c:/Process_Data_CSV_Archive/";

        static double ManualWarmUpTime = 15.0; //minutes

        static public double waitTime;
        static public int manualTubeSeasoning;
        static public int manualWarmUp;

        //real time values
        static public int PumpIntention = 0;  //addition to prevent out-of-sequence threads from turning the pump on -- if the intention is to turn it off


        double AT = ambientTempStatic;//Convert.ToDouble(tbMetroAmbientTempCal.Text);
        double BP = ambientPressureStatic;// Convert.ToDouble(tbMetroAtmPressureCal.Text);


        static public double ambientTempStatic;
        static public double sampleTempStatic;
        static public double ambientPressureStatic;
        static public double samplePressureStatic;
        static public double relativeHumidityStatic;
        static public double flow25Static;
        static public double flowActualStatic;
        static public double flowStandardStatic;
        static public double volumeStatic;
        static public double tubeTempStatic;
        static public double enclosureTempStatic;
        static public double filamentMonitorStatic;
        static public double sDDTempStatic;
        static public double dPPTempStatic;
        static public double sampleTimeStatic;
        static public double windSpeedStatic;
        static public double windDirStatic;



        static int leakCheckActive = 0;
        static int fiveMinuteCounter = 0;
        static double samplePressureAtStart = 0.0;
        static double samplePressureAtEnd = 0.0;
        //static int alarmCode;
        static int PumpLeakCheckTimer = 0;

        DateTime RunPressed;
        bool enterDataButtonClicked = false;

        const int PASS = 1;
        const int FAIL = 0;
        const int PRESET_END_ADJUST = 5;
        const int PRESET_END_ADJUST_ECAL = 5;
        const int PRESET_END_ADJUST_UPSCALE = 10;

        static List<string> filesToParse = new List<string>();
        static int filesToParseIndex = 0;

        static string saveGainOffset;

        static int delayTime = 0;

        int returnVal11;

        //each error and string are paired together
        static List<int> systemError;   //if error occurs set here for logging and display and action
        static List<string> errorString;  //list of errors, times, ect.

        static Queue<string> displayActionQueue = new Queue<string>();

        //pump related
        public static int pumpStartCounter = 0;

        public static MetroForm Form2_Display;



        //static private double TUBETEMP = 45;
        static private double TIMER_VALUE = 1.0; //in seconds
        static private int SAMPLES = 7500;            //7500, 10000, and 15000 the more samples/sec the better
        static private int PRESSURE_SAMPLES = 20;

        static public int samplesPerChannel = SAMPLES;
        static public int 
            pressureSamplesPerChannel = PRESSURE_SAMPLES;

        //static public double ambientTempStatic;
        //static public double ambientPressureStatic;

        static public AnalogWaveform<double>[] data;

        //private static string receivedValue;

        static public int CancelRamp = 0;

        static public int acqTimerCounter = 0;
        static public int acqReturnValue = 1;

        static public int FunctionCalled = 0;
        static public int successCount = 0;

        
        static public bool EC1maset = false;  //used by manual Acq
        static public bool EC2maset = false;
        static public bool EC3maset = false;
        static public bool EC4maset = false;
        static public int SaveButton = 0;


        static public int readInputTimerCounter = 0;
        static public int TTCounter = 0;
        static public int toggleInterlockTimerCounter = 0;
        static int TubeSeasoningIndex=0;

        static int[] TubeSeasoningkVArray = { 13, 18, 23, 28, 33, 38, 43, 48 };
        static int[] TubeSeasoninguAArray =  { 300, 400, 500, 600, 700, 800, 900, 1000 };
        static DateTime tubeSeasoningStartTime;
        static DateTime tubeSeasoningEndTime;


        private delegate void processValueDelegate(string value);

        BackgroundWorker m_oWorkerRamp;             //ramp voltage and current

        BackgroundWorker m_oWorkerPump;             //run the pump 


        static public double processValue;

        static private NationalInstruments.DAQmx.Task FlowSensorInput;
        static private NationalInstruments.DAQmx.Task AmbientPressureSensorInput;

        static private NationalInstruments.DAQmx.Task OutputCurrent;   //output to NI 
        static private NationalInstruments.DAQmx.Task OutputVoltage;   //output to NI

        static private NationalInstruments.DAQmx.Task InputVoltage;    //input from NI
        static private NationalInstruments.DAQmx.Task InputCurrent;    //input from NI

        static private NationalInstruments.DAQmx.Task InputReadValue;  //read input values from NI   (tube temp)
        static private NationalInstruments.DAQmx.Task InputReadEnclosureTemp;  //read enclosure temp from NI
        static private NationalInstruments.DAQmx.Task InputReadSampleTemp;  //read sample temp from NI
        static private NationalInstruments.DAQmx.Task InputReadAtmPressure;
        static private NationalInstruments.DAQmx.Task InputReadFilamentMonitor;

        static private NationalInstruments.DAQmx.Task InputReadSamplePressure;

        static private NationalInstruments.DAQmx.Task InputReadRelativeHumidity;

        static private NationalInstruments.DAQmx.Task InputReadAmbientTemp;

        //        static private NationalInstruments.DAQmx.Task FlowSensorPower; //temp for flow sensor
        static private NationalInstruments.DAQmx.Task PumpOutput;      //
        static private NationalInstruments.DAQmx.Task PumpOutputOff;

        static private NationalInstruments.DAQmx.Task InterlockOutput; // digital output for interlock ssr

        static private NationalInstruments.DAQmx.Task InletHeaterOutput; //digital output for the inlet heater.

        static private NationalInstruments.DAQmx.Task InterlockControlWatchdogOutput; //ICWO will toggle every read IO interrupt--if the toggle is not seen by hardware for 30 seconds the Xray interlock will open


        static public AnalogWaveform<double>[] InputVoltageData;

        static public AnalogWaveform<double>[] InputCurrentData;

        static public AnalogWaveform<double>[] InputTubeTempData;

        static public AnalogWaveform<double>[] InputEnclosureTempData;

        static public AnalogWaveform<double>[] InputAmbientTempData;

        static public AnalogWaveform<double>[] InputSampleTempData;

        static public AnalogWaveform<double>[] InputAtmPressData;

        static public AnalogWaveform<double>[] InputFilamentMonitorData;

        static public AnalogWaveform<double>[] InputRelativeHumidityData;

        //static public AnalogWaveform<double>[] InputAmbientTemperatureData;

        static public AnalogWaveform<double>[] InputSamplePressureData;



        List<double> rawUPaOut_EC1 = new List<double>();
        List<double> rawUPvOut_EC1 = new List<double>();

        List<double> rawUPaOut_EC2 = new List<double>();
        List<double> rawUPvOut_EC2 = new List<double>();

        List<double> rawUPaOut_EC3 = new List<double>();
        List<double> rawUPvOut_EC3 = new List<double>();

        List<double> rawDNaOut_EC1 = new List<double>();
        List<double> rawDNvOut_EC1 = new List<double>();

        List<double> rawDNaOut_EC2 = new List<double>();
        List<double> rawDNvOut_EC2 = new List<double>();

        List<double> rawDNaOut_EC3 = new List<double>();
        List<double> rawDNvOut_EC3 = new List<double>();

        //static public req
        static public List<double> LinearRampValuesVoltage = new List<double>();
        static public List<double> LinearRampValuesCurrent = new List<double>();
        static public int rampIndex = 0;

        //pump feedback filter logic
        static public double PumpOutputNew;
        static public double PumpOutputOld;
        static public int inputIndex = 0;


        static private AnalogMultiChannelReader reader;
        static private AnalogMultiChannelReader readerAtmPressure;
        static private AnalogMultiChannelReader readerSamplePressure;

        static private AnalogMultiChannelReader readerFlowSensor;

        //pump logic:

        static public string sProportionalGain;
        static public string sIntegralGain;
        static public string sDerivativeGain;


        static public double OutputVoltage_1 = 0;  //previous output -- for limiting maximum output changes to prevent thrashing the pump
        static public double integral = 0.00;
        static public double Error_1 = 0;
        static public double Error_2 = 0;
        static public double Error_3 = 0;
        static public double derivative = 0.00;
        static public double deltaTime = TIMER_VALUE;  //set in seconds 
        static public double Error;
        static public double setPointValueOld;
        static public double setPointValueNew;

        static public double PumpOutputVoltage = 0.0;
        static public double PumpOutputVoltage_1 = 0.0;
        static public double PumpOutputVoltagePID = 0.0;

        static public double flowSensorVoltage = 0.0;
        static public double readInputCurrent = 0.0;
        static public double readInputVoltage = 0.0;
        static public double readOnlySamplePressureValue = 0.0;

        static public int pumpOnOff = 0;
        public delegate void SetFieldDelegate(int field, int value);

        public static long startTime;
        public static Stopwatch stopwatch;

        public object AcquisitionManager;
        public object XrsfpManager;

        // This delegate enables asynchronous calls for setting
        // the text property on a TextBox control.
        delegate void SetTextCallback(string text);
        public static string retVal;

        //acqusition logic state variables

        public static double sampleTime = 60;
        public static DateTime DateTimeFromStartButton;
        public static DateTime DateTimeFromStartButtonInternalLog;
        public static DateTime DateTimeFromStartButtonErrorLog;

        public static DateTime DateTimeFromStartButtonWarningLog;


        public static int fileNoForInternalLog;
        public static int fileNoForErrorLog;
        public static int fileNoForWarningLog;
        public static int fileNoForLogFile;



        //acquisition variables:
        public static DateTime AcquireStarted;
        public static DateTime AcquireStart;
        public static DateTime AcquireRequestStarted;

        public static DateTime calculateStartAcq; //start now if less than 15min

        public static DateTime EC1start;
        public static DateTime EC1stop;
        public static DateTime EC2start;
        public static DateTime EC2stop;
        public static DateTime EC3start;
        public static DateTime EC3stop;

        public static DateTime UpscaleStart;

        public static double EC1Voltage = 25;
        public static double EC1Current = 1500;
        public static double EC1time = sampleTime * 0.20;
        public static double EC2time = sampleTime * 0.40;
        public static double EC3time = sampleTime * 0.40;



        public static double EC2Voltage = 46;
        public static double EC2Current = 800;

        public static double EC3Voltage = 46;
        public static double EC3Current = 800;

        //multithreaded file write....
        private static ReaderWriterLockSlim _readWriteLock = new ReaderWriterLockSlim();

        //myxrsfp holds the interface to xrsfp to be called when needed
        static _cMTFFPX myxrsfp;

        



        private ErrorClass ErrorManager;
        private SerialIO SerialManager;
        public static SerialControlLinesIO SerialIOControlLinesManager;

        private SerialWindSpeedandDirIO SerialWindSpeedandDirManager;



        public System.Windows.Forms.Timer ToggleInterlockTimer; 

        public System.Windows.Forms.Timer IOReadAndDisplayGUITimer;

        public System.Windows.Forms.Timer IOReadWindSpeedAndDisplayGUITimer;

        public System.Windows.Forms.Timer errorMonitorTimer;


        public object GUIFlashInputTimer { get; private set; }


        //digital filter:
        static public double flowInput0;
        static public double flowInput1;

        static public int flowInputIndex;

        static public double flowOutput0;
        static public double flowOutput1;
        static public int flowOutputIndex;

        static public double alpha = 0.15;   //0.6 low pass less than .25

        static public DateTime EndTime;

        private static object lockObj;

        private static object lockEcalObj;
        private static object lockUpscaleObj;
        private static object lockManualAcqObj;
        private static object lockLeakCheckObj;
        private static object lockTubeSeasoningObj;
        private static object lockFiveMinuteObj;

        private static object lockTimerObj;
        private static object lockToggleInterlockTimerObj;

        private static object lockWindSpeedTimerObj;

        private static object pumpLockObj;
        private static object rampLockObj;

        public Background BackgroundManager;


        //////////////////////////////////////////
        /// flow variables
        /// /////////////////////////////////////
        public string Tnistvalue;
        public string Pnistvalue;

        public double fNormalMeas;
        public string sfNormalMeas;
        //remove
        public string sflow25_167;
        public double flow25_167;

        public string sflow25_150;
        public double flow25_150;

        public string sflow25_184;
        public double flow25_184;
        //end remove

        public string suflowActAmb_167;
        public double uflowActAmb_167;

        public string suflowActAmb_150;
        public double uflowActAmb_150;

        public string suflowActAmb_184;
        public double uflowActAmb_184;


        public double fLowMeas;
        public string sfLowMeas;

        public double fHiMeas;
        public string sfHiMeas;


        public double PumpSetPoint = 4.21;
        public double flowPumpSetPoint = 17.0;

        public bool mrb150;
        public bool mrb167;
        public bool mrb184;

        public static bool rb15;
        public static bool rb30;
        public static bool rb60;


        public bool rbStandard;
        public bool rbActual;

        static double atmPressureOld = 760.0; //init value
        //
        static public string actualValueV;
        static public string actualValueI;

        static public double acqVolume;
        private DateTime ec1time;
        private DateTime ectime;


        static public int runState = 0;

        static public int interlockControlWatchdogToggle = 0;

        static public int windSpeedAndDirResponseCounter = 0;
        static public int allowWindSpeedAndDirResponseCounter = 0;

        static public int xrayOnCommand = 0;
        static public int xrayOnCommandCounter = 0;
        static public int xrayRampCommandActive = 0;
        static public int xrayCommandActive = 0;       //this flag follows the command voltage and current

        //static public int xrayRampVoltage = 0;
        static public int waiting = 0;
        static public int waitingCounter;

        static public int HaltEnabled = 1;  //Enable Halt function.  Once called it will disable Halt.  Re-enable halt via Run. 
                                            //static public int EnclosureTempCounter =0;

        static public FileVersionInfo myFileVersionInfo;

        static public int ErrorsAndWarningsFileNumber = 0;

        public Form1()
        {

            //goto DEBUGTAG11;

            //check for running instance 
            if (!EnsureSingleInstance())
            {
                Application.Exit();
                return;
            }

            if (Properties.Settings.Default.TapeMidMoveCheckEnable == 1)
            {
                Logger.WriteLogFile("init:  TapeMidMoveCheckEnable = 1");
            }
            else
            {
                Logger.WriteLogFile("init:  TapeMidMoveCheckEnable = 0");

            }


            /*
            static bool EnsureSingleInstance()
            {
                Process currentProcess = Process.GetCurrentProcess();

                var runningProcess = (from process in Process.GetProcesses()
                                      where
                                        process.Id != currentProcess.Id &&
                                        process.ProcessName.Equals(
                                          currentProcess.ProcessName,
                                          StringComparison.Ordinal)
                                      select process).FirstOrDefault();

                if (runningProcess != null)
                {
                    ShowWindow(runningProcess.MainWindowHandle, SW_SHOWMAXIMIZED);
                    SetForegroundWindow(runningProcess.MainWindowHandle);

                    return false;
                }

                return true;
            }

[DllImport("user32.dll", EntryPoint = "SetForegroundWindow")]
        private static extern bool SetForegroundWindow(IntPtr hWnd);

        [DllImport("user32.dll")]
        private static extern Boolean ShowWindow(IntPtr hWnd, Int32 nCmdShow);

        private const int SW_SHOWMAXIMIZED = 3;
        */

            System.IO.Directory.CreateDirectory("C:/CES/InternalLog");
            System.IO.Directory.CreateDirectory("C:/CES/UserSettings");
            System.IO.Directory.CreateDirectory("C:/CES/SettingsRecovery");

            System.IO.Directory.CreateDirectory("C:/Process_Data_CSV");
            System.IO.Directory.CreateDirectory("C:/Process_Data_CSV_Archive");




            _cMTFFPX myacq_xrsfp = new cMTFFPX();

            BackgroundManager = new Background();

            Logger.WriteInternalLogFile("Program initialization start.");
        

            Logger.WriteInternalLogFile("Initialize serial IO.");
            //make this a function callable on serial port setting changes

            //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            Logger.WriteInternalLogFile("After launch acquisition control.");
            try
            {
                Logger.WriteInternalLogFile("Initializing motor serial IO.");

                SerialManager = new SerialIO();  //handles ez4axis
                SerialManager.initSerialIO();
                Logger.WriteInternalLogFile("Done initializing motor serial IO.");

            }
            catch (Exception Ex)
            {
                //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                Logger.WriteInternalLogFile("Error Init motor comport."+Ex.ToString());
                Halt("Init Motor Comport Error");
                //AcquisitionControl.SetAlarmValue(110);
            }

            try
            {
                Logger.WriteInternalLogFile("Initializing wind speed and direction serial IO.");

                SerialWindSpeedandDirManager = new SerialWindSpeedandDirIO();
                SerialWindSpeedandDirManager.initSerialIO();
                Logger.WriteInternalLogFile("Done initializing wind speed and direction serial IO.");

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error Init wind comport." + Ex.ToString());
                Halt("Init Wind Comport Error");
                //AcquisitionControl.SetAlarmValue(110);
            }
            /*
            try
            {
                Logger.WriteInternalLogFile("Serial Control Lines... ");

                SerialControlLinesManager = new SerialControlLinesIO();

                if (Properties.Settings.Default.OutputPin7 == true)
                {
                    SerialControlLinesManager.initSerialIO();
                }
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error Init Pin 7 toggle" + Ex.ToString());
                Halt("Init Control Lines Error");
                AcquisitionControl.SetAlarmValue(110);
            }
            */

            Logger.WriteInternalLogFile("Initialize GUI.");

            InitializeComponent();
            Logger.WriteInternalLogFile("Initialize Controls.");


            //intialize tab page settings
            EnableDisableAllSettingsControls(false);
            EnableDisableAllFlowCalibrationControls(false);
            EnableDisableAllMaintenanceControls(false);

            Logger.WriteInternalLogFile("Initialize Closing Form.");

            /////////
            // tab pages initialization
            /////////
            //get the program closing function call
            this.FormClosing += Form1_FormClosing;

            Logger.WriteInternalLogFile("Initialize tabs.");

            //how to select init tab:
            MetroTabControlSettings.SelectTab("metroTabPage1");  //status
            // MetroTabControl2.SelectTab("metroTabPage8");  //sub menu selection

            //this reports what tab was clicked
            MetroTabControlSettings.Selected += new TabControlEventHandler(MetroTabControlSettings_Selected);


            //sub menu intial tab
            metroTabControl1.SelectTab("metroTabPage7");
            //sub menu clicked
            metroTabControl1.Selected += new TabControlEventHandler(metroTabControl1_Selected);

            //sub menu clicks  (was for conc data and adapt
            //MetroTabControl2.Selected += new TabControlEventHandler(MetroTabControl2_Selected);

            //systemError = new List<int>();   //if error occurs set here for logging and display and action

            errorString = new List<string>(); // static List<string> errorString;  //list of errors, times, ect.

            ErrorManager = new ErrorClass();

            Logger.WriteInternalLogFile("Initialize Timers.");
            IOReadAndDisplayGUITimer = new System.Windows.Forms.Timer();

            ToggleInterlockTimer = new System.Windows.Forms.Timer();


            IOReadWindSpeedAndDisplayGUITimer = new System.Windows.Forms.Timer();

            errorMonitorTimer = new System.Windows.Forms.Timer();

            //set up tasks for NI IO:


            try
            {
                Logger.WriteInternalLogFile("Init NI IO tasks.... ");

                PumpOutput = new NationalInstruments.DAQmx.Task();
                PumpOutputOff = new NationalInstruments.DAQmx.Task();

                FlowSensorInput = new NationalInstruments.DAQmx.Task();

                AmbientPressureSensorInput = new NationalInstruments.DAQmx.Task();

                InputVoltage = new NationalInstruments.DAQmx.Task();
                InputCurrent = new NationalInstruments.DAQmx.Task();

                InputReadValue = new NationalInstruments.DAQmx.Task();


                InputReadEnclosureTemp = new NationalInstruments.DAQmx.Task();
                InputReadSampleTemp = new NationalInstruments.DAQmx.Task();

                InputReadAtmPressure = new NationalInstruments.DAQmx.Task();

                InputReadFilamentMonitor = new NationalInstruments.DAQmx.Task();

                InputReadRelativeHumidity = new NationalInstruments.DAQmx.Task();

                InputReadSamplePressure = new NationalInstruments.DAQmx.Task();

                InputReadAmbientTemp = new NationalInstruments.DAQmx.Task();

                OutputVoltage = new NationalInstruments.DAQmx.Task();
                OutputCurrent = new NationalInstruments.DAQmx.Task();

                //replaced by circuit on IOBB:
                //FlowSensorPower = new NationalInstruments.DAQmx.Task();

                InterlockOutput = new NationalInstruments.DAQmx.Task();

                InletHeaterOutput = new NationalInstruments.DAQmx.Task();

                InterlockControlWatchdogOutput = new NationalInstruments.DAQmx.Task();


                AnalogSingleChannelReader setPointReaderVoltage = new AnalogSingleChannelReader(InputVoltage.Stream);
                AnalogSingleChannelReader setPointReaderCurrent = new AnalogSingleChannelReader(InputCurrent.Stream);
                AnalogSingleChannelReader setPointReaderTubeTemp = new AnalogSingleChannelReader(InputReadValue.Stream);

                AnalogSingleChannelReader setPointReaderEnclosureTemp = new AnalogSingleChannelReader(InputReadEnclosureTemp.Stream);
                AnalogSingleChannelReader setPointReaderAmbientTemp = new AnalogSingleChannelReader(InputReadAmbientTemp.Stream);
                AnalogSingleChannelReader setPointReaderSampleTemp = new AnalogSingleChannelReader(InputReadSampleTemp.Stream);
                AnalogSingleChannelReader setPointReaderAtmPress = new AnalogSingleChannelReader(InputReadAtmPressure.Stream);
                AnalogSingleChannelReader setPointReaderFilamentMonitor = new AnalogSingleChannelReader(InputReadFilamentMonitor.Stream);
                AnalogSingleChannelReader setPointReaderSamplePressure = new AnalogSingleChannelReader(InputReadSamplePressure.Stream);
                AnalogSingleChannelReader setPointReaderRelativeHumidity = new AnalogSingleChannelReader(InputReadRelativeHumidity.Stream);
                AnalogSingleChannelWriter setPointWriterVoltage = new AnalogSingleChannelWriter(OutputVoltage.Stream);
                AnalogSingleChannelWriter setPointWriterCurrent = new AnalogSingleChannelWriter(OutputCurrent.Stream);


                readerFlowSensor = new AnalogMultiChannelReader(FlowSensorInput.Stream);
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error Init NI hardware tasks" + Ex.ToString());
                Halt("Init NI hardware Error");
                //AcquisitionControl.SetAlarmValue(110);
            }


#if TURNON_NIHARDWARE //is defined

            try
            {
                // pre version 78, the aiterminalconfiguration was (AITerminalConfiguration)(-1)
                // 78 and beyond:  AITerminalConfiguration.Rse

                InputVoltage.AIChannels.CreateVoltageChannel("Dev1/ai0", "aiChannel", (AITerminalConfiguration)(-1), 0.000, 9.999, AIVoltageUnits.Volts);
                InputCurrent.AIChannels.CreateVoltageChannel("Dev1/ai1", "aiChannel", (AITerminalConfiguration)(-1), 0.000, 9.999, AIVoltageUnits.Volts);

                //tube temp:
                InputReadValue.AIChannels.CreateVoltageChannel("Dev1/ai3", "aiChannel", (AITerminalConfiguration)(-1), 0.000, 9.999, AIVoltageUnits.Volts);
                InputReadEnclosureTemp.AIChannels.CreateVoltageChannel("Dev1/ai4", "aiChannel", (AITerminalConfiguration)(-1), 0.000, 9.999, AIVoltageUnits.Volts);
                InputReadFilamentMonitor.AIChannels.CreateVoltageChannel("Dev1/ai2", "aiChannel", AITerminalConfiguration.Rse, 0.000, 9.999, AIVoltageUnits.Volts);

                //InputReadAmbientPressure.AIChannels.CreateVoltageChannel("Dev1/ai23", "aiChannel", (AITerminalConfiguration)(-1), 0.000, 9.999, AIVoltageUnits.Volts);
                InputReadAmbientTemp.AIChannels.CreateVoltageChannel("Dev1/ai6", "aiChannel", (AITerminalConfiguration)(-1), 0.000, 9.999, AIVoltageUnits.Volts);
                InputReadRelativeHumidity.AIChannels.CreateVoltageChannel("Dev1/ai19", "aiChannel", (AITerminalConfiguration)(-1), 0.000, 9.999, AIVoltageUnits.Volts);
                InputReadAtmPressure.AIChannels.CreateVoltageChannel("Dev1/ai23", "aiChannel", (AITerminalConfiguration)(-1), 0.000, 9.999, AIVoltageUnits.Volts);
                InputReadSamplePressure.AIChannels.CreateVoltageChannel("Dev1/ai22", "aiChannel", (AITerminalConfiguration)(-1), 0.000, 9.999, AIVoltageUnits.Volts);
                InputReadSampleTemp.AIChannels.CreateVoltageChannel("Dev1/ai20", "aiChannel", (AITerminalConfiguration)(-1), 0.000, 9.999, AIVoltageUnits.Volts);


                OutputVoltage.AOChannels.CreateVoltageChannel("Dev1/ao0", "aoChannel", 0.000, 10.000, AOVoltageUnits.Volts);  //five max for now
                OutputCurrent.AOChannels.CreateVoltageChannel("Dev1/ao1", "aoChannel", 0.000, 10.000, AOVoltageUnits.Volts);  //five max for now

                //OBSOLETE this is the sensor power output:
                //FlowSensorPower.AOChannels.CreateVoltageChannel("Dev1/ao2", "aoChannel", 0.000, 9.999, AOVoltageUnits.Volts);

                //define the pump output
                PumpOutput.AOChannels.CreateVoltageChannel("Dev1/ao3", "aoChannel", 0.000, 4.999, AOVoltageUnits.Volts);

                PumpOutputOff.AOChannels.CreateVoltageChannel("Dev1/ao3", "aoChannel", 0.000, 4.999, AOVoltageUnits.Volts);

                //define the interlock output
                InterlockOutput.DOChannels.CreateChannel("Dev1/port0/line0", "doChannel0", ChannelLineGrouping.OneChannelForEachLine);

                InletHeaterOutput.DOChannels.CreateChannel("Dev1/port0/line30", "doChannel30", ChannelLineGrouping.OneChannelForEachLine);

                //define the interlock watchdog output
                InterlockControlWatchdogOutput.DOChannels.CreateChannel("Dev1/port1/line0", "DoChannel0", ChannelLineGrouping.OneChannelForEachLine);


                DigitalSingleChannelWriter Port00writer = new DigitalSingleChannelWriter(InterlockOutput.Stream);

                DigitalSingleChannelWriter Port10writer = new DigitalSingleChannelWriter(InterlockControlWatchdogOutput.Stream);

                DigitalSingleChannelWriter Port30writer = new DigitalSingleChannelWriter(InletHeaterOutput.Stream);

                //do not turn off here in case the HVPS is ON.....

                //this defaults the pump to off
                AnalogSingleChannelWriter PumpOutputVoltage = new AnalogSingleChannelWriter(PumpOutput.Stream);
                PumpOutputVoltage.WriteSingleSample(true, 0.000);

                //  flow sensor input 
                FlowSensorInput.AIChannels.CreateVoltageChannel("Dev1/ai21", "aiChannel", (AITerminalConfiguration)(-1), 0.000, 10.000, AIVoltageUnits.Volts);


#else

            //TODO:
            //ADD THIS LABEL TO gui
            //    NIHARDWAREStatus.Text = "NI Hardware Disabled";
            //    NIHARDWAREStatus.BackColor = Color.Yellow;
#endif
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error define NI hardware IO." + Ex.ToString());
                Halt("Init define NI IO Error");
                //AcquisitionControl.SetAlarmValue(110);
            }


            try
            {

                Logger.WriteInternalLogFile("Init background threads...");

                //ramp:
                m_oWorkerRamp = new BackgroundWorker();
                m_oWorkerRamp.DoWork += new DoWorkEventHandler(m_oWorkerRamp_DoWork);
                m_oWorkerRamp.ProgressChanged += new ProgressChangedEventHandler(m_oWorkerRamp_ProgressChanged);
                m_oWorkerRamp.RunWorkerCompleted += new RunWorkerCompletedEventHandler(m_oWorkerRamp_RunWorkerCompleted);
                //allow cancellationa and progress updates to the GUI 
                m_oWorkerRamp.WorkerReportsProgress = true;
                m_oWorkerRamp.WorkerSupportsCancellation = true;


                //pump:
                m_oWorkerPump = new BackgroundWorker();
                m_oWorkerPump.DoWork += new DoWorkEventHandler(m_oWorkerPump_DoWork);  //sets up Onpumptimedevent
                m_oWorkerPump.ProgressChanged += new ProgressChangedEventHandler(m_oWorkerPump_ProgressChanged);
                m_oWorkerPump.RunWorkerCompleted += new RunWorkerCompletedEventHandler(m_oWorkerPump_RunWorkerCompleted);
                //allow cancellation and progress updates to the GUI
                m_oWorkerPump.WorkerReportsProgress = true;
                m_oWorkerPump.WorkerSupportsCancellation = true;

                //acquisition:
                BackgroundManager.m_oWorkerAcq = new BackgroundWorker();
                BackgroundManager.m_oWorkerAcq.DoWork += new DoWorkEventHandler(m_oWorkerAcq_DoWork);
                BackgroundManager.m_oWorkerAcq.ProgressChanged += new ProgressChangedEventHandler(m_oWorkerAcq_ProgressChanged);
                BackgroundManager.m_oWorkerAcq.RunWorkerCompleted += new RunWorkerCompletedEventHandler(m_oWorkerAcq_RunWorkerCompleted);
                //allow cancellationa and progress updates to the GUI 
                BackgroundManager.m_oWorkerAcq.WorkerReportsProgress = true;
                BackgroundManager.m_oWorkerAcq.WorkerSupportsCancellation = true;


                ////Manual Ecal:
                BackgroundManager.m_oWorkerEcal = new BackgroundWorker();
                BackgroundManager.m_oWorkerEcal.DoWork += new DoWorkEventHandler(m_oWorkerEcal_DoWork);
                BackgroundManager.m_oWorkerEcal.ProgressChanged += new ProgressChangedEventHandler(m_oWorkerEcal_ProgressChanged);
                BackgroundManager.m_oWorkerEcal.RunWorkerCompleted += new RunWorkerCompletedEventHandler(m_oWorkerEcal_RunWorkerCompleted);
                //allow cancellationa and progress updates to the GUI 
                BackgroundManager.m_oWorkerEcal.WorkerReportsProgress = true;
                BackgroundManager.m_oWorkerEcal.WorkerSupportsCancellation = true;

                ///Manual Upscale:
                ///
                BackgroundManager.m_oWorkerUpscale = new BackgroundWorker();
                BackgroundManager.m_oWorkerUpscale.DoWork += new DoWorkEventHandler(m_oWorkerUpscale_DoWork);
                BackgroundManager.m_oWorkerUpscale.ProgressChanged += new ProgressChangedEventHandler(m_oWorkerUpscale_ProgressChanged);
                BackgroundManager.m_oWorkerUpscale.RunWorkerCompleted += new RunWorkerCompletedEventHandler(m_oWorkerUpscale_RunWorkerCompleted);
                //allow cancellationa and progress updates to the GUI 
                BackgroundManager.m_oWorkerUpscale.WorkerReportsProgress = true;
                BackgroundManager.m_oWorkerUpscale.WorkerSupportsCancellation = true;

                ///Manual Acquisition
                ///
                //m_oWorkerManualAcquisition
                BackgroundManager.m_oWorkerManualAcq = new BackgroundWorker();
                BackgroundManager.m_oWorkerManualAcq.DoWork += new DoWorkEventHandler(m_oWorkerManualAcq_DoWork);
                BackgroundManager.m_oWorkerManualAcq.ProgressChanged += new ProgressChangedEventHandler(m_oWorkerManualAcq_ProgressChanged);
                //BackgroundManager.m_oWorkerManualAcquisition.RunWorkerCompleted += new RunWorkerCompletedEventHandler(m_oWorkerManualAcquisition_RunWorkerCompleted);
                //allow cancellationa and progress updates to the GUI 
                BackgroundManager.m_oWorkerManualAcq.WorkerReportsProgress = true;
                BackgroundManager.m_oWorkerManualAcq.WorkerSupportsCancellation = true;

                //leak check state machine 
                BackgroundManager.m_oLeakCheck = new BackgroundWorker();
                BackgroundManager.m_oLeakCheck.DoWork += new DoWorkEventHandler(m_oLeakCheck_DoWork);
                BackgroundManager.m_oLeakCheck.ProgressChanged += new ProgressChangedEventHandler(m_oLeakCheck_ProgressChanged);
                //BackgroundManager.m_oWorkerManualAcquisition.RunWorkerCompleted += new RunWorkerCompletedEventHandler(m_oWorkerManualAcquisition_RunWorkerCompleted);
                //allow cancellationa and progress updates to the GUI 
                BackgroundManager.m_oLeakCheck.WorkerReportsProgress = true;
                BackgroundManager.m_oLeakCheck.WorkerSupportsCancellation = true;


                //Tube seasoning
                //
                BackgroundManager.m_oWorkerTubeSeasoning = new BackgroundWorker();
                BackgroundManager.m_oWorkerTubeSeasoning.DoWork += new DoWorkEventHandler(m_oWorkerTubeSeasoning_DoWork);
                //BackgroundManager.m_oWorkerTubeSeasoning.ProgressChanged += new ProgressChangedEventHandler(m_oWorkerTubeSeasoning_ProgressChanged);
                BackgroundManager.m_oWorkerTubeSeasoning.RunWorkerCompleted += new RunWorkerCompletedEventHandler(m_oWorkerTubeSeasoning_RunWorkerCompleted);
                //allow cancellationa and progress updates to the GUI 
                BackgroundManager.m_oWorkerTubeSeasoning.WorkerReportsProgress = true;
                BackgroundManager.m_oWorkerTubeSeasoning.WorkerSupportsCancellation = true;

                //FiveMinute
                //
                BackgroundManager.m_oWorkerFiveMinute = new BackgroundWorker();
                BackgroundManager.m_oWorkerFiveMinute.DoWork += new DoWorkEventHandler(m_oWorkerFiveMinute_DoWork);
                //BackgroundManager.m_oWorkerTubeSeasoning.ProgressChanged += new ProgressChangedEventHandler(m_oWorkerTubeSeasoning_ProgressChanged);
                //BackgroundManager.m_oWorkerManualAcquisition.RunWorkerCompleted += new RunWorkerCompletedEventHandler(m_oWorkerManualAcquisition_RunWorkerCompleted);
                //allow cancellationa and progress updates to the GUI 
                BackgroundManager.m_oWorkerFiveMinute.WorkerReportsProgress = true;
                BackgroundManager.m_oWorkerFiveMinute.WorkerSupportsCancellation = true;



            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error Init background worker threads." + Ex.ToString());
                Halt("Init background threads Error");
                //AcquisitionControl.SetAlarmValue(110);
            }




            try
            {
                Logger.WriteInternalLogFile("Init timers... ");

                StartReadInputTimer();  

                StartReadWindSpeedInputTimer();  

                StartInterlockToggleTimer();  //check for command and toggle relay if no xray on command

            }

            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error init read input timers." + Ex.ToString());
                Halt("Init read input timers.");
                //AcquisitionControl.SetAlarmValue(110);
            }






            Logger.WriteInternalLogFile("Start Init Acquisition Control class");
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            Logger.WriteInternalLogFile("Done Init Acquisition Control class");

            Logger.WriteInternalLogFile("Init xact holding registers... ");

            DataStore xactHoldingRegisters = AcquisitionControl.getDataStore();

            string mbComport = "COM" + Properties.Settings.Default.ModbusComPort.ToString();



            try
            {
                //check outputpin7 setting (true or false)                  
                if (/*Properties.Settings.Default.OutputPin4==true ||*/ Properties.Settings.Default.OutputPin7 == true)
                {
                    Logger.WriteInternalLogFile("Init Serial IO lines comport... ");

                    //init control lines comport class on the Modbus comport
                    SerialIOControlLinesManager = new SerialControlLinesIO();
                    SerialIOControlLinesManager.initSerialIO();  //init sets up the comport and use the nmodbus comport number.
                    SerialIOControlLinesManager.ClrOutputPin4();
                    SerialIOControlLinesManager.ClrOutputPin7();


                }
                else
                {
                    Logger.WriteInternalLogFile("Init Modbus Comport... ");

                    // start NModbus init:
                    //SerialControlLinesIO SerialIOControlLinesManager = new SerialControlLinesIO();
                    //SerialIOControlLinesManager.initSerialIO();  //init sets up the comport and use the nmodbus comport number.

                    nModbusOperations.initialize(mbComport, 9600, out xactHoldingRegisters);
                    
                    AcquisitionControl.setDataStore(xactHoldingRegisters);
                    //end of NModbus init
                }

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error Init Modbus/control lines comport." + Ex.ToString());
                Halt("Init Modbus/control lines Comport Error");
                AcquisitionControl.SetAlarmValue(110);
            }




            try
            {
                const string userRoot = "HKEY_CURRENT_USER";
                const string subkey = "Software\\Microsoft\\Internet Explorer\\Main\\FeatureControl\\FEATURE_BROWSER_EMULATION";
                const string keyName = userRoot + "\\" + subkey;

                Microsoft.Win32.Registry.SetValue(keyName, "WindowsSystem625.exe", 11000, Microsoft.Win32.RegistryValueKind.DWord);
                Microsoft.Win32.Registry.SetValue(keyName, "WindowsSystem625.vshost.exe", 11000, Microsoft.Win32.RegistryValueKind.DWord);
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error Init adapt browser version." + Ex.ToString());
                Halt("Init adapt browser version Error");
                AcquisitionControl.SetAlarmValue(110);
            }



            ErrorsAndWarningsFileNumber = GetErrorsAndWarningsFileNumber();


            //perform connect at program start:
            //get connected if not connected.
            //wait for cross launch
            Thread.Sleep(3000);
            //poll for this?

            try
            {
                var startUpCheckHaspKey = myacq_xrsfp.GetHASPbits;


                if (startUpCheckHaspKey < 0)
                {
                    Logger.WriteInternalLogFile("At Init invalid analysis software hasp key...");
                    mlabelHasp.Text = "INVALID key";

                    mlabelHasp.BackColor = Color.DimGray;
                    mtbXrsStatus.Text = "Xrs-Fp init: Fail";
                    mtbXrsStatus.Refresh();
                    Halt("Invalid Hasp Key.");

                }
                else
                {
                    Logger.WriteInternalLogFile("At Init, valid analysis software hasp key...");
                    mlabelHasp.Text = "VALID key";
                    //lb_hasp.BackColor = Color.Cyan;
                    //mlabelHasp.BackColor = System.Drawing.Color.LimeGreen;   //no work metro
                    mlabelHasp.BackColor = Color.LimeGreen;
                    mlabelHasp.Refresh();
                    mtbXrsStatus.Text = "Xrs-Fp init: Pass";
                    mtbXrsStatus.Refresh();

                    //hasp key valid
                }
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error Init Xrs-FP hasp key." + Ex.ToString());
                Halt("Init Xrs-FP hasp key Error");
                AcquisitionControl.SetAlarmValue(110);
            }

            try
            {
                Logger.WriteInternalLogFile("At Init, check detector connection...");


                var startUpVal = AcquisitionControl.CheckDetectorConnection();
                if (startUpVal != PASS)
                {
                    Halt("Unable to Connect to detector.");
                    //SetAlarmValue(203);  only set if running
                    //WriteAlarmToModbus(203);  only set if runnning

                }
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error Init detector connection." + Ex.ToString());
                Halt("Init detector connection Error");
                AcquisitionControl.SetAlarmValue(110);
            }
            finally
            {
                Logger.WriteInternalLogFile("At Init, done checking detector connection.");

            }


            myacq_xrsfp.AutoForm_Show = false;
            myacq_xrsfp.SpectraX_Show = false;



            Logger.WriteInternalLogFile("Checking exe version info...");
            LogInstanceInfo();

            //these two lines require that the version be set at build time:
//            FileVersionInfo myFileVersionInfo = FileVersionInfo.GetVersionInfo("WindowsSystem625.exe");   //change this for 920 etc...  
//            mlVersionNumber.Text = myFileVersionInfo.FileVersion;



            EnableDisableAllSettingsControls(false);
            EnableDisableAllMaintenanceControls(false);
            EnableDisableAllFlowCalibrationControls(false);



            //recover saved settings at init time  --if file is present--
            if (System.IO.File.Exists("c:/CES/SettingsRecovery/settings.ini") == true)
            {
                try
                {
                    string[] lines = System.IO.File.ReadAllLines("c:/CES/SettingsRecovery/settings.ini");

                    Properties.Settings.Default.SampleTime = Convert.ToInt32(lines[0]);
                    Properties.Settings.Default.UpscaleRodPosition = Convert.ToInt32(lines[1]);
                    Properties.Settings.Default.EcalRodPosition = Convert.ToInt32(lines[2]);
                    Properties.Settings.Default.FWEC1 = Convert.ToInt32(lines[3]);
                    Properties.Settings.Default.FWEC2 = Convert.ToInt32(lines[4]);
                    Properties.Settings.Default.FWEC3 = Convert.ToInt32(lines[5]);
                    Properties.Settings.Default.EcalkV = Convert.ToInt32(lines[6]);
                    Properties.Settings.Default.EcaluA = Convert.ToInt32(lines[7]);
                    Properties.Settings.Default.EcalTime = Convert.ToInt32(lines[8]);
                    Properties.Settings.Default.EC1kV = Convert.ToInt32(lines[9]);
                    Properties.Settings.Default.EC1uA = Convert.ToInt32(lines[10]);
                    Properties.Settings.Default.EC1RTP = Convert.ToInt32(lines[11]);
                    Properties.Settings.Default.EC1RunTime = Convert.ToInt32(lines[12]);
                    Properties.Settings.Default.EC1Filter = lines[13];
                    Properties.Settings.Default.EC1AC = lines[14];
                    Properties.Settings.Default.EC2kV = Convert.ToInt32(lines[15]);
                    Properties.Settings.Default.EC2uA = Convert.ToInt32(lines[16]);
                    Properties.Settings.Default.EC2RTP = Convert.ToInt32(lines[17]);
                    Properties.Settings.Default.EC2RunTime = Convert.ToInt32(lines[18]);
                    Properties.Settings.Default.EC2Filter = lines[19];
                    Properties.Settings.Default.EC2AC = lines[20];
                    Properties.Settings.Default.EC3kV = Convert.ToInt32(lines[21]);
                    Properties.Settings.Default.EC3uA = Convert.ToInt32(lines[22]);
                    Properties.Settings.Default.EC3RTP = Convert.ToInt32(lines[23]);
                    Properties.Settings.Default.EC3RunTime = Convert.ToInt32(lines[24]);
                    Properties.Settings.Default.EC3Filter = lines[25];
                    Properties.Settings.Default.EC3AC = lines[26];
                    Properties.Settings.Default.FWMC = Convert.ToInt32(lines[27]);
                    Properties.Settings.Default.FWHC = Convert.ToInt32(lines[28]);
                    Properties.Settings.Default.DMC = Convert.ToInt32(lines[29]);
                    Properties.Settings.Default.DHC = Convert.ToInt32(lines[30]);
                    Properties.Settings.Default.NozzleMC = Convert.ToInt32(lines[31]);
                    Properties.Settings.Default.NozzleHC = Convert.ToInt32(lines[32]);
                    Properties.Settings.Default.TapeMC = Convert.ToInt32(lines[33]);
                    Properties.Settings.Default.TapeHC = Convert.ToInt32(lines[34]);
                    Properties.Settings.Default.MotorComPort = Convert.ToInt32(lines[35]);
                    Properties.Settings.Default.WindComPort = Convert.ToInt32(lines[36]);
                    Properties.Settings.Default.InletHeater = Convert.ToInt32(lines[37]);
                    Properties.Settings.Default.UpscaleCr = Convert.ToDouble(lines[38]);
                    Properties.Settings.Default.UpscalePb = Convert.ToDouble(lines[39]);
                    Properties.Settings.Default.UpscaleCd = Convert.ToDouble(lines[40]);
                    Properties.Settings.Default.Nb = Convert.ToDouble(lines[41]);
                    Properties.Settings.Default.UpscaleAlarmPercent = Convert.ToInt32(lines[42]);
                    Properties.Settings.Default.FlowControl = lines[43];
                    Properties.Settings.Default.FlowSum = lines[44];
                    Properties.Settings.Default.ModbusComPort = Convert.ToInt32(lines[45]);

                    Properties.Settings.Default.yint = Convert.ToDouble(lines[46]);
                    Properties.Settings.Default.slope = Convert.ToDouble(lines[47]);
                    Properties.Settings.Default.TnistCalAdj = Convert.ToDouble(lines[48]);
                    Properties.Settings.Default.PnistCalAdj = Convert.ToDouble(lines[49]);

                    Properties.Settings.Default.PSnistCalAdj = Convert.ToDouble(lines[50]);
                    Properties.Settings.Default.OutputPin7 = Convert.ToBoolean(lines[51]);
                    Properties.Settings.Default.OutputPin4 = Convert.ToBoolean(lines[52]);
                    Properties.Settings.Default.NbAlarmPercent = Convert.ToDouble(lines[53]);  //order matters here --file creation must put things in this order.
                    Properties.Settings.Default.TubeTempErrorTrigger = Convert.ToInt32(lines[54]);
                    Properties.Settings.Default.TubeTempWarningTrigger = Convert.ToInt32(lines[55]);
                    Properties.Settings.Default.FWHK = Convert.ToInt32(lines[56]);

                    Properties.Settings.Default.EC4kV = Convert.ToInt32(lines[57]);
                    Properties.Settings.Default.EC4uA = Convert.ToInt32(lines[58]);
                    Properties.Settings.Default.EC4RTP = Convert.ToInt32(lines[59]);
                    Properties.Settings.Default.EC4RunTime = Convert.ToInt32(lines[60]);
                    Properties.Settings.Default.EC4Filter = lines[61];
                    Properties.Settings.Default.EC4AC = lines[62];

                    Properties.Settings.Default.FWEC4 = Convert.ToInt32(lines[63]);
                    Properties.Settings.Default.UpscaleEC4 = Convert.ToDouble(lines[64]);

                    Properties.Settings.Default.EncoderWheelLL = Convert.ToInt32(lines[65]);
                    Properties.Settings.Default.EncoderWheelUL = Convert.ToInt32(lines[66]);
                    Properties.Settings.Default.TemperatureSensorType = lines[67];

                    Properties.Settings.Default.FlowError = Convert.ToDouble(lines[68]);
                    Properties.Settings.Default.FlowWarning = Convert.ToDouble(lines[69]);

                    if (lines[70].Contains("1"))
                    {
                        Properties.Settings.Default.TapeMidMoveCheckEnable = 1;
                    }
                    else if (lines[70].Contains("0"))
                    {
                        Properties.Settings.Default.TapeMidMoveCheckEnable = 0;

                    }
                    else
                    {
                        Properties.Settings.Default.TapeMidMoveCheckEnable = 0;
                    }


                    try
                    {
                        Properties.Settings.Default.RunModeFlow = Convert.ToDouble(lines[71]);
                        Logger.WriteInternalLogFile("Flow value in settings.ini = " + Properties.Settings.Default.RunModeFlow.ToString("F2"));
                    }
                    catch
                    {
                        Logger.WriteInternalLogFile("No value found in settings.ini for flow.  Setting flow to:  16.7");
                        Properties.Settings.Default.RunModeFlow = 16.7;
                    }

                    Properties.Settings.Default.Save();
                    

                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error reading settings.ini file.  Ex = "+Ex.ToString());
                }
                finally
                {
                    String NewFileName;
                    NewFileName = "C:/CES/SettingsRecovery/settings_" + DateTime.Now.ToString("MM_dd_yyyy__HH_mm_ss") + ".ini";
                    System.IO.File.Move("C:/CES/SettingsRecovery/settings.ini", NewFileName);
                    System.IO.File.Delete("C:/CES/SettingsRecovery/settings.ini");

                }

            }
            else
            {
                Logger.WriteInternalLogFile("No settings.ini file found, loading normal parameter values at program launch.");
            }

            try
            {
                //Get current SQL and Modbus library version (i.e. customer's library version)
                FileVersionInfo currentSQLver = FileVersionInfo.GetVersionInfo("C:/XactControl/System.Data.SQLite.dll");
                FileVersionInfo currentNmodbusver = FileVersionInfo.GetVersionInfo("C:/XactControl/NModbus4.dll");
                //Log current SQL, Modbus, and Runtime version
                Logger.WriteInternalLogFile("Current SQLite Version: " + currentSQLver.FileVersion);
                Logger.WriteInternalLogFile("Current NModbus Version: " + currentNmodbusver.FileVersion);
                Logger.WriteInternalLogFile("Current Runtime Version: " + Environment.Version.ToString());

                //Set Library version at built time (i.e. our library version)
                string buildSQLver = "1.0.104.0";
                string buildNmodbusver = "2.1.0.0";
                string SQLRuntimeVer = "4.0.30319";
                string nmodbusRuntimeVer = "4.0.30319";
                string runtimeVer = Environment.Version.ToString();
                //Conver runtime version string from "x.x.xxxxx.xxxxx" to "x.x.xxxxx"
                string[] elementItems = runtimeVer.Split('.');
                runtimeVer = elementItems[0] + "." + elementItems[1] + "." + elementItems[2];
                //Compare current library version and library version at built time
                if (currentSQLver.FileVersion != buildSQLver || currentNmodbusver.FileVersion != buildNmodbusver || SQLRuntimeVer != runtimeVer || nmodbusRuntimeVer != runtimeVer)
                {
                    Logger.WriteErrorFile("Library does not match.");
                    Logger.WriteInternalLogFile("Library does not match.");
                    Logger.WriteLogFile("Library does not match.");
                }
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error Checking Library Version.  Ex = " + Ex.ToString());
            }


            try
            {
                string productVersion;
                productVersion = GetProductVersion();
                Logger.WriteInternalLogFile("XactControl version = " + productVersion);
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Unable to log program version.  Ex = " + Ex.ToString());
            }




            //may want to add this check to init code

            // test logic here


            //bhc debug

            // 
            //1.  write date time to file
            //this file is checked for last known run

            //DateTime now = DateTime.Now;

            //must be odd hour:
            //try less than 30:  27 min and 37 min (works) 
            
            //DateTime dt = new DateTime(now.Year, now.Month, now.Day, 11, 27 ,52 );


            //AcquireRequestStarted = dt;

            //AcquireStart = AcquisitionControl.CalculateAcquireStartTime(AcquireRequestStarted);  //this is how long you wait to start

            //AcquisitionControl.SetAcquireStartTime(AcquireStart);


            //int x = 5;

            //bhc debug


            //DateTime dt = new DateTime(now.Year, now.Month, now.Day, 14, 52,10 );
            ////DateTime dt = new DateTime(now.Year, now.Month, now.Day, 7, 59, 58);

            //DateTime dt = new DateTime(now.Year, now.Month, now.Day, 8, 02, 25);
            //dt = new DateTime(now.Year, now.Month, now.Day, 9, 28, 25);

            //TimeCalc(1, dt ,5);
            //TimeCalc(1, dt, 30);
            //TimeCalc(1, dt, 60);
            //TimeCalc(1, dt, 120);
            //TimeCalc(1, dt, 240);
            //dt = new DateTime(now.Year, now.Month, now.Day, 7, 59, 59);
            //TimeCalc(1, dt, 15);
            //TimeCalc(1, dt, 30);
            //TimeCalc(1, dt, 60);
            //TimeCalc(1, dt, 120);
            //TimeCalc(1, dt, 240);
            //DateTime now = DateTime.Now;
            //DateTime dt;
            //DateTime dt = new DateTime(now.Year, now.Month, now.Day, 00, 30, 17);

            //TimeCalc21AfterUpscale(0,dt,60);

            //DateTime dt = new DateTime(now.Year, now.Month, now.Day, 00, 30, 30);
            //TimeCalc21AfterUpscale(21,dt, 240);

            //testing for 22


            //AcquisitionControl.SetCounter(0);
            //AcquisitionControl.SetSamplePeriod(Properties.Settings.Default.SampleTime);

            //AcquireRequestStarted = DateTime.Now;
            //AcquireStart = AcquisitionControl.CalculateAcquireStartTime(AcquireRequestStarted);  //this is how long you wait to start


            //AcquisitionControl.LoadMTFRFile(1);
            // AcquisitionControl.LoadMTFRFile(2);
            // AcquisitionControl.LoadMTFRFile(3);
            //AcquisitionControl.LoadMTFRFile(4);
            //  AcquisitionControl.LoadMTFRFile(0);


            // end test logic



            //test connection to adapt db: *******************************


            //update adapt database
            //AdaptDB db = new AdaptDB();

            //string db_path = "C:\\XactControl\\Adapt\\adapt.db";  //works!
            //string db_path = "‪C:/XactControl/Adapt/adapt.db";         //does NOT allow db connection to open
            //string db_path = @"‪C:\XactControl\Adapt\adapt.db";        //does NOT allow db connection to open

            //C:\XactControl\Adapt
            //SQLiteConnection dbConnection;
            //db.DBConnection(db_path, out dbConnection);

            //DateTime now = DateTime.Now;
            ////DateTime dt;
            //DateTime dt = new DateTime(now.Year, now.Month, now.Day, now.Hour,now.Minute,now.Second);


            //IniFile.WriteValue("C:/XactControl/XRD.ini", "Tube", "LastRun", dt.ToString());
            //string lastRunValue = IniFile.ReadValue("C:/XactControl/XRD.ini", "Tube", "LastRun");
            //DateTime dtLRV = DateTime.Parse(lastRunValue);

            //TimeSpan span = now.Subtract(dtLRV);
            //double days = span.TotalDays;



            //*************************************************** end test

            //GenerateCSVOutput(0);

            tbMetroTubeTemp.BackColor = Color.White; //set default -- this display tb allows red or yellow background based on temp input

            metroToggleFlowCal.CheckState = System.Windows.Forms.CheckState.Unchecked;
            metroToggleFlowCal.Refresh();


            Logger.WriteInternalLogFile("Program initialization complete.");








        }

        /// <summary>
        /// Get the product version string and log to the internal log file
        /// </summary>
        /// <returns></returns>
        public static string GetProductVersion()
        {

            System.Reflection.Assembly assembly = System.Reflection.Assembly.GetExecutingAssembly();
            FileVersionInfo fvi = FileVersionInfo.GetVersionInfo(assembly.Location);
            string version = fvi.FileVersion;
            return version;

        }

        public int GetErrorsAndWarningsFileNumber()
        {
            try
            {
                string[] files;

                files = Directory.GetFiles("C:/Temp/");
                int numberOfFiles = files.Count();

                List<string> filesFound = new List<string>();

                string item = string.Empty;
                for(int i =0;i<numberOfFiles;i++)
                {
                    item = files[i];
                    if(item.Contains("ErrorsAndWarnings"))
                    {
                        filesFound.Add(item);
                    }

                }


                if (filesFound.Count() == 0)
                {
                    return 0;
                }
                else
                {

                    List<int> intValues = new List<int>();
                    foreach (string fitem in filesFound)
                    {
                        int result = 0;
                        //return largest value found in filesFound

                        string local0 = fitem.Replace(".txt", "");
                        string local1 = local0.Replace("ErrorsAndWarnings_", "");
                        string local2 = local1.Replace("C:/Temp/", "");
                        //local 1 now holds the integer string value
                        bool success = Int32.TryParse(local2, out result);
                        if (success == true)
                        {
                            intValues.Add(result);
                        }

                    }
                    int num = intValues.Count();
                    return intValues[num-1];
                }
            }

            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error: in GetErrorsAndWarningFilenumber.  Ex = " + Ex.ToString());              return 0;
            }



        }






        /// <summary>
        /// capture the instant uc and system values for write to Modbus regs
        /// </summary>
        /// <param name="dataSetValue"></param>
        public List<double> CaptureInstantSystemValues()
        {

            List<double> outputData = new List<double>();
            outputData.Clear();
            try
            {
                outputData.Add(ambientTempStatic);
                outputData.Add(sampleTempStatic);
                outputData.Add(ambientPressureStatic);
                outputData.Add(samplePressureStatic);
                outputData.Add(relativeHumidityStatic);
                outputData.Add(flow25Static);
                outputData.Add(flowActualStatic);
                outputData.Add(flowStandardStatic);
                outputData.Add(volumeStatic);
                outputData.Add(tubeTempStatic);
                outputData.Add(enclosureTempStatic);
                outputData.Add(filamentMonitorStatic);
                outputData.Add(sDDTempStatic);
                outputData.Add(dPPTempStatic);
                outputData.Add(Convert.ToDouble(Properties.Settings.Default.SampleTime));
                outputData.Add(windSpeedStatic);
                outputData.Add(windDirStatic);

                /*
                //if (dataSetValue == 1)
                //{
                if (InvokeRequired)
                {
                    string value = "";
                    tbMetroDryingChamberRA.Invoke(new MethodInvoker(delegate { value = tbMetroDryingChamberRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    dryingChamberRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroDryingChamberRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    dryingChamberRA_1 = result;
                    outputData.Add(result);
                }

                if (InvokeRequired)
                {
                    string value = "";
                    tbMetroInletHeaterRA.Invoke(new MethodInvoker(delegate { value = tbMetroInletHeaterRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    inletHeaterRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroInletHeaterRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    outputData.Add(result);
                    inletHeaterRA_1 = result;
                }

                if (InvokeRequired)
                {
                    string value = "";
                    //tbMetroCarrier
                    tbMetroCarrierAir0RA.Invoke(new MethodInvoker(delegate { value = tbMetroCarrierAir0RA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierAir0RA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroCarrierAir0RA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierAir0RA_1 = result;
                    outputData.Add(result);
                }

                if (InvokeRequired)
                {
                    string value = "";
                    //tbMetroCarrier
                    tbMetroCarrierAir1RA.Invoke(new MethodInvoker(delegate { value = tbMetroCarrierAir1RA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierAir1RA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroCarrierAir1RA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierAir1RA_1 = result;
                    outputData.Add(result);
                }
                //carrierHeaterR_1
                if (InvokeRequired)
                {
                    string value = "";
                    //tbMetroCarrier
                    tbMetroCarrierHeaterRA.Invoke(new MethodInvoker(delegate { value = tbMetroCarrierHeaterRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierHeaterRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroCarrierHeaterRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierHeaterRA_1 = result;
                    outputData.Add(result);
                }
                //carrierAir2R_1
                if (InvokeRequired)
                {
                    string value = "";
                    //tbMetroCarrier
                    tbMetroCarrierAir2RA.Invoke(new MethodInvoker(delegate { value = tbMetroCarrierAir2RA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierAir2RA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroCarrierAir2RA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierAir2RA_1 = result;
                    outputData.Add(result);
                }
                //sampleAir1R_1
                if (InvokeRequired)
                {
                    string value = "";
                    //tbMetroCarrier
                    tbMetroSampleAir1RA.Invoke(new MethodInvoker(delegate { value = tbMetroSampleAir1RA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    sampleAir1RA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroSampleAir1RA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    sampleAir1RA_1 = result;
                    outputData.Add(result);
                }
                //sampleAir2R_1
                if (InvokeRequired)
                {
                    string value = "";
                    //tbMetroCarrier
                    tbMetroSampleAir2RA.Invoke(new MethodInvoker(delegate { value = tbMetroSampleAir2RA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    sampleAir2RA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroSampleAir2RA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    sampleAir2RA_1 = result;
                    outputData.Add(result);
                }
                //sampleHeaterR_1
                if (InvokeRequired)
                {
                    string value = "";
                    //tbMetroCarrier
                    tbMetroSampleAir2RA.Invoke(new MethodInvoker(delegate { value = tbMetroSampleHeaterRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    sampleHeaterRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroSampleAir2RA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    sampleHeaterRA_1 = result;
                    outputData.Add(result);
                }
                //spikeFlowR_1
                if (InvokeRequired)
                {
                    string value = "";
                    //tbMetroCarrier

                    tbMetroSpikeFlowRA.Invoke(new MethodInvoker(delegate { value = tbMetroSpikeFlowRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    spikeFlowRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroSpikeFlowRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    spikeFlowRA_1 = result;
                }
                //spikePumpR_1
                if (InvokeRequired)
                {
                    string value = "";
                    //tbMetroCarrier

                    tbMetroSpikePumpRA.Invoke(new MethodInvoker(delegate { value = tbMetroSpikePumpRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    spikePumpRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroSpikePumpRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    spikePumpRA_1 = result;
                    outputData.Add(result);
                }
                //sampleLiquidFlowR_1
                if (InvokeRequired)
                {
                    string value = "";
                    //tbMetroCarrier

                    tbMetroSampleLiquidFlowRA.Invoke(new MethodInvoker(delegate { value = tbMetroSampleLiquidFlowRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    sampleLiquidFlowRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroSampleLiquidFlowRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    sampleLiquidFlowRA_1 = result;
                    outputData.Add(result);
                }
                //sampleLiquidPumpR_1 = 0;
                if (InvokeRequired)
                {
                    string value = "";
                    //tbMetroCarrier

                    tbMetroSampleLiquidPumpRA.Invoke(new MethodInvoker(delegate { value = tbMetroSampleLiquidPumpRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    sampleLiquidPumpRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroSampleLiquidPumpRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    sampleLiquidPumpRA_1 = result;
                    outputData.Add(result);
                }
                //static public double totalFlowR_1 = 0;
                if (InvokeRequired)
                {
                    string value = "";
                    //tbMetroCarrier

                    tbMetroTotalFlowRA.Invoke(new MethodInvoker(delegate { value = tbMetroTotalFlowRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    totalFlowRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroTotalFlowRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    totalFlowRA_1 = result;
                    outputData.Add(result);
                }
                //static public double isolationValveR_1 = 0;
                if (InvokeRequired)
                {
                    string value = "";
                    //tbMetroCarrier

                    tbMetroIsolationValveRA.Invoke(new MethodInvoker(delegate { value = tbMetroIsolationValveRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    isolationValveRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroIsolationValveRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    isolationValveRA_1 = result;
                    outputData.Add(result);
                }
                //static public double fSLFlowR_1 = 0;
                if (InvokeRequired)
                {
                    string value = "";
                    //tbMetroCarrier

                    tbMetroFSLFlowRA.Invoke(new MethodInvoker(delegate { value = tbMetroFSLFlowRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    fSLFlowRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroFSLFlowRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    fSLFlowRA_1 = result;
                    outputData.Add(result);
                }
                //static public double tDSSensorR_1 = 0;
                if (InvokeRequired)
                {
                    string value = "";
                    //tbMetroCarrier

                    tbMetroTDSSensorRA.Invoke(new MethodInvoker(delegate { value = tbMetroTDSSensorRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    tDSSensorRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroTDSSensorRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    tDSSensorRA_1 = result;
                    outputData.Add(result);
                }
                //static public double intStdR_1 = 0;
                if (InvokeRequired)
                {
                    string value = "";
                    tbMetroIntStdRA.Invoke(new MethodInvoker(delegate { value = tbMetroIntStdRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    intStdRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroIntStdRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    intStdRA_1 = result;
                    outputData.Add(result);
                }
                //intConc_1
                //if (InvokeRequired)
                //{
                //    string value = "";
                //    //tbMetroCarrier

                //    tbMetroSolnConcR.Invoke(new MethodInvoker(delegate { value = tbMetroIntStdR.Text; }));
                //    bool b1 = Double.TryParse(value, out double result);
                //    //result = result / 1000;
                //    intStdR_1 = result;
                //}
                //else
                //{
                //    string value = "";
                //    value = tbMetroIntStdR.Text;
                //    bool b1 = Double.TryParse(value, out double result);
                //    //result = result / 1000;
                //    intStdR_1 = result;
                //}
                //static public double nebulizerFlowR_1 = 0;
                if (InvokeRequired)
                {
                    string value = "";
                    tbMetroNebulizerFlowRA.Invoke(new MethodInvoker(delegate { value = tbMetroNebulizerFlowRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    nebulizerFlowRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroNebulizerFlowRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    nebulizerFlowRA_1 = result;
                    outputData.Add(result);
                }
                //nebulizerPressureR
                if (InvokeRequired)
                {
                    string value = "";
                    tbMetroNebulizerPressureRA.Invoke(new MethodInvoker(delegate { value = tbMetroNebulizerPressureRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    nebulizerPressureRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroNebulizerPressureRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    nebulizerPressureRA_1 = result;
                    outputData.Add(result);
                }
                //static public double sampleAirFlowR_1 = 0;
                if (InvokeRequired)
                {
                    string value = "";
                    tbMetroSampleAirFlowRA.Invoke(new MethodInvoker(delegate { value = tbMetroSampleAirFlowRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    sampleAirFlowRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroSampleAirFlowRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    sampleAirFlowRA_1 = result;
                    outputData.Add(result);
                }
                //static public double sampleAirPumpR_1 = 0;
                if (InvokeRequired)
                {
                    string value = "";
                    tbMetroSampleAirPumpRA.Invoke(new MethodInvoker(delegate { value = tbMetroSampleAirPumpRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    sampleAirPumpRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroSampleAirPumpRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    sampleAirPumpRA_1 = result;
                    outputData.Add(result);
                }
                //static public double sampleANLiquidLevelR_1 = 0;
                if (InvokeRequired)
                {
                    string value = "";
                    tbMetroSampleANLiquidLevelRA.Invoke(new MethodInvoker(delegate { value = tbMetroSampleANLiquidLevelRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    sampleANLiquidLevelRA_1 = result;
                    outputData.Add(result);
                }
                else
                {
                    string value = "";
                    value = tbMetroSampleANLiquidLevelRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    sampleANLiquidLevelRA_1 = result;
                    outputData.Add(result);
                }
                //static public double carrierFlowR_1 = 0;
                if (InvokeRequired)
                {
                    string value = "";
                    tbMetroCarrierFlowRA.Invoke(new MethodInvoker(delegate { value = tbMetroCarrierFlowRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierFlowRA_1 = result;
                    outputData.Add(result);
                }
                else
                {

                    string value = "";
                    value = tbMetroCarrierFlowRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierFlowRA_1 = result;
                    outputData.Add(result);
                }
                //static public double carrierAirPumpR_1 = 0;
                if (InvokeRequired)
                {
                    string value = "";
                    tbMetroCarrierAirPumpRA.Invoke(new MethodInvoker(delegate { value = tbMetroCarrierAirPumpRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierAirPumpRA_1 = result;
                    outputData.Add(result);
                }
                else
                {

                    string value = "";
                    value = tbMetroCarrierAirPumpRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierAirPumpRA_1 = result;
                    outputData.Add(result);
                }
                //static public double carrierANdPR_1 = 0;
                if (InvokeRequired)
                {
                    string value = "";
                    tbMetroCarrierANdPRA.Invoke(new MethodInvoker(delegate { value = tbMetroCarrierANdPRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierANdPRA_1 = result;
                    outputData.Add(result);
                }
                else
                {

                    string value = "";
                    value = tbMetroCarrierANdPRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierANdPRA_1 = result;
                    outputData.Add(result);
                }
                //static public double carrierANLiquidLevelR_1 = 0;
                if (InvokeRequired)
                {
                    string value = "";
                    tbMetroCarrierANLiquidLevelRA.Invoke(new MethodInvoker(delegate { value = tbMetroCarrierANLiquidLevelRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierANLiquidLevelRA_1 = result;
                    outputData.Add(result);
                }
                else
                {

                    string value = "";
                    value = tbMetroCarrierANLiquidLevelRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierANLiquidLevelRA_1 = result;
                    outputData.Add(result);
                }
                //static public double carrierANdPSamplePressureR_1 = 0;
                if (InvokeRequired)
                {
                    string value = "";
                    tbMetroCarrierANdPSamplePressureRA.Invoke(new MethodInvoker(delegate { value = tbMetroCarrierANdPSamplePressureRA.Text; }));
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierANdPSamplePressureRA_1 = result;
                    outputData.Add(result);
                }
                else
                {

                    string value = "";
                    value = tbMetroCarrierANdPSamplePressureRA.Text;
                    bool b1 = Double.TryParse(value, out double result);
                    //result = result / 1000;
                    carrierANdPSamplePressureRA_1 = result;
                    outputData.Add(result);
                }




                

                //static public double dryingChamberR_1 = 0;
                //static public double inletHeater_1 = 0;
                //static public double carrierAir0R_1 = 0;
                //static public double carrierAir1R_1 = 0;
                //static public double carrierHeaterR_1 = 0;
                //static public double carrierAir2R_1 = 0;
                //static public double sampleAir1R_1 = 0;
                //static public double sampleHeaterR_1 = 0;
                //static public double sampleAir2R_1 = 0;


                //Fluid
                //static public double spikeFlowR_1 = 0;
                //static public double spikePumpR_1 = 0;
                //static public double sampleLiquidFlowR_1 = 0;
                //static public double sampleLiquidPumpR_1 = 0;
                //static public double totalFlowR_1 = 0;
                //static public double isolationValveR_1 = 0;
                //static public double fSLFlowR_1 = 0;
                //static public double tDSSensorR_1 = 0;
                //static public double intStdR_1 = 0;
                //static public double intConc_1 = 0;

                //AcidNeutralizer
                //static public double nebulizerFlowR_1 = 0;
                //static public double nebulizerPressureR_1 = 0;
                //static public double sampleAirFlowR_1 = 0;
                //static public double sampleAirPumpR_1 = 0;
                //static public double sampleANLiquidLevelR_1 = 0;
                //static public double carrierFlowR_1 = 0;
                //static public double carrierAirPumpR_1 = 0;
                //static public double carrierANdPR_1 = 0;
                //static public double carrierANLiquidLevelR_1 = 0;
                //static public double carrierANdPSamplePressureR_1 = 0;
                

                //}
                */
                return outputData;
            }
            catch (Exception Ex)
            {
                outputData.Add(0);
                Logger.WriteInternalLogFile("Error in CaptureDataSet.  Error = " + Ex.ToString());
                return outputData;
            }

        }








        ////
        ////Update GUI functions here:
        ////

        /// <summary>
        /// allow other classes and threads to update GUI -- 
        /// </summary>
        /// <param name="UscaleMessage"></param>
        public void UpdateUpscaleMessage(string inputDate, string Cr, string Cd, string Pb, string Nb, int index)
        {
            try
            {
                //input date format
                string date = 
                inputDate.Substring(0, 2) + "/" +
                inputDate.Substring(3, 2) + "/" +
                inputDate.Substring(8, 2) + " " +
                inputDate.Substring(11, 2) + ":" +
                inputDate.Substring(14, 2);

                if (index == 1)
                {
                    if (InvokeRequired)
                    {
                        mtbDT1.Invoke(new MethodInvoker(delegate { mtbDT1.Text = date; }));
                        mtbCR1.Invoke(new MethodInvoker(delegate { mtbCR1.Text = Cr; }));
                        mtbCD1.Invoke(new MethodInvoker(delegate { mtbCD1.Text = Cd; }));
                        mtbPB1.Invoke(new MethodInvoker(delegate { mtbPB1.Text = Pb; }));
                        mtbNB1.Invoke(new MethodInvoker(delegate { mtbNB1.Text = Nb; }));
                    }
                    else
                    {
                        mtbDT1.Text = date;
                        mtbCR1.Text = Cr;
                        mtbCD1.Text = Cd;
                        mtbPB1.Text = Pb;
                        mtbNB1.Text = Nb;

                    }
                }
                else if(index==2)
                {
                    if (InvokeRequired)
                    {
                        mtbDT2.Invoke(new MethodInvoker(delegate { mtbDT2.Text = date; }));
                        mtbCR2.Invoke(new MethodInvoker(delegate { mtbCR2.Text = Cr; }));
                        mtbCD2.Invoke(new MethodInvoker(delegate { mtbCD2.Text = Cd; }));
                        mtbPB2.Invoke(new MethodInvoker(delegate { mtbPB2.Text = Pb; }));
                        mtbNB2.Invoke(new MethodInvoker(delegate { mtbNB2.Text = Nb; }));
                    }
                    else
                    {
                        mtbDT2.Text = date;
                        mtbCR2.Text = Cr;
                        mtbCD2.Text = Cd;
                        mtbPB2.Text = Pb;
                        mtbNB2.Text = Nb;

                    }
                }
                else if (index == 3)
                {
                    if (InvokeRequired)
                    {
                        mtbDT3.Invoke(new MethodInvoker(delegate { mtbDT3.Text = date; }));
                        mtbCR3.Invoke(new MethodInvoker(delegate { mtbCR3.Text = Cr; }));
                        mtbCD3.Invoke(new MethodInvoker(delegate { mtbCD3.Text = Cd; }));
                        mtbPB3.Invoke(new MethodInvoker(delegate { mtbPB3.Text = Pb; }));
                        mtbNB3.Invoke(new MethodInvoker(delegate { mtbNB3.Text = Nb; }));
                    }
                    else
                    {
                        mtbDT3.Text = date;
                        mtbCR3.Text = Cr;
                        mtbCD3.Text = Cd;
                        mtbPB3.Text = Pb;
                        mtbNB3.Text = Nb;

                    }
                }
                else if (index == 4)
                {
                    if (InvokeRequired)
                    {
                        mtbDT4.Invoke(new MethodInvoker(delegate { mtbDT4.Text = date; }));
                        mtbCR4.Invoke(new MethodInvoker(delegate { mtbCR4.Text = Cr; }));
                        mtbCD4.Invoke(new MethodInvoker(delegate { mtbCD4.Text = Cd; }));
                        mtbPB4.Invoke(new MethodInvoker(delegate { mtbPB4.Text = Pb; }));
                        mtbNB4.Invoke(new MethodInvoker(delegate { mtbNB4.Text = Nb; }));
                    }
                    else
                    {
                        mtbDT4.Text = date;
                        mtbCR4.Text = Cr;
                        mtbCD4.Text = Cd;
                        mtbPB4.Text = Pb;
                        mtbNB4.Text = Nb;

                    }
                }
                /*else if (index == 5)
                {
                    if (InvokeRequired)
                    {
                        mtbDT5.Invoke(new MethodInvoker(delegate { mtbDT5.Text = date; }));
                        mtbCR5.Invoke(new MethodInvoker(delegate { mtbCR5.Text = Cr; }));
                        mtbCD5.Invoke(new MethodInvoker(delegate { mtbCD5.Text = Cd; }));
                        mtbPB5.Invoke(new MethodInvoker(delegate { mtbPB5.Text = Pb; }));
                        mtbNB5.Invoke(new MethodInvoker(delegate { mtbNB5.Text = Nb; }));
                    }
                    else
                    {
                        mtbDT5.Text = date;
                        mtbCR5.Text = Cr;
                        mtbCD5.Text = Cd;
                        mtbPB5.Text = Pb;
                        mtbNB5.Text = Nb;

                    }
                }
                */
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in update Update Upscale GUI. Ex = " + Ex.ToString());
            }
        }





        /// <summary>
        /// allow other classes and threads to update GUI -- 
        /// </summary>
        /// <param name="kVMessage"></param>
        public void UpdatekVMessage(string kVMessage)
        {
            try
            {
                if (InvokeRequired)
                {
                    mtbActualkV.Invoke(new MethodInvoker(delegate { mtbActualkV.Text = kVMessage; }));
                    mtbIOActualkV.Invoke(new MethodInvoker(delegate { mtbIOActualkV.Text = kVMessage; }));
                }
                else
                {
                    mtbActualkV.Text = kVMessage;
                    mtbActualkV.Refresh();

                    mtbIOActualkV.Text = kVMessage;
                    mtbIOActualkV.Refresh();

                }


            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in update kV message. Ex = " + Ex.ToString());
            }
        }



        /// <summary>
        /// allow other classes and threads to update GUI -- 
        /// </summary>
        /// <param name="Update Wind Speed"></param>
        public void UpdateWindSpeed(string windSpeed)
        {
            try
            {
                if (InvokeRequired)
                {
                    mtbWindSpeed.Invoke(new MethodInvoker(delegate { mtbWindSpeed.Text = windSpeed; }));
                }
                else
                {
                    mtbWindSpeed.Text = windSpeed;
                    mtbWindSpeed.Refresh();
                }
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in update wind speed.  Ex = " + Ex.ToString());
            }
        }

        /// <summary>
        /// allow other classes and threads to update GUI -- 
        /// </summary>
        /// <param name="Update Wind Direction"></param>
        public void UpdateWindDir(string windDir)
        {
            try
            {
                if (InvokeRequired)
                {
                    mtbWindDir.Invoke(new MethodInvoker(delegate { mtbWindDir.Text = windDir; }));
                }
                else
                {
                    mtbWindDir.Text = windDir;
                    mtbWindDir.Refresh();
                }
            }
            catch (Exception )
            {
                //Logger.WriteInternalLogFile("Exception in update wind direction.  Ex = " + Ex.ToString());
            }
        }



        /// <summary>
        /// allow other classes and threads to update GUI -- 
        /// </summary>
        /// <param name="progressBarPercent"></param>
        public void UpdateXrayProgressBar(int progressBarPercent)
        {
            try
            {
                if (InvokeRequired)
                {

                    mpbMaintenanceXrayRamp.Invoke(new MethodInvoker(delegate { mpbMaintenanceXrayRamp.Value = progressBarPercent; }));
                    mpbMaintenanceXrayRamp.Invoke(new MethodInvoker(delegate { mpbMaintenanceXrayRamp.Refresh(); }));
                    
                }
                else
                {

                    mpbMaintenanceXrayRamp.Value = progressBarPercent;
                    mpbMaintenanceXrayRamp.Refresh();
                }
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in update xray ramp progress bar. Ex = " + Ex.ToString());
            }
        }



        /// <summary>
        /// allow other classes and threads to update GUI -- 
        /// </summary>
        /// <param name="uAMessage"></param>
        public void UpdateuAMessage(string uAMessage)
        {
            try
            {
                if (InvokeRequired)
                {
                    mtbActualuA.Invoke(new MethodInvoker(delegate { mtbActualuA.Text = uAMessage; }));
                    mtbIOActualuA.Invoke(new MethodInvoker(delegate { mtbIOActualuA.Text = uAMessage; }));
                }
                else
                {
                    mtbActualuA.Text = uAMessage;
                    mtbActualuA.Refresh();

                    mtbIOActualuA.Text = uAMessage;
                    mtbIOActualuA.Refresh();
                }
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in update uA message. Ex = " + Ex.ToString());
            }
        }





        /// <summary>
        /// allow other classes and threads to update GUI
        /// </summary>
        /// <param name="fwMessage"></param>
        public void UpdateFilterWheelMessage(string fwMessage)
        {
            try
            {
                if (InvokeRequired)
                {
                    mtbStatusFilterWheelMessage.Invoke(new MethodInvoker(delegate { mtbStatusFilterWheelMessage.Text = fwMessage; }));
                    mtbStatusFilterWheelMessage.Invoke(new MethodInvoker(delegate { mtbStatusFilterWheelMessage.Refresh(); }));
                    mtbFWOutput.Invoke(new MethodInvoker(delegate { mtbFWOutput.Text = fwMessage; }));
                    mtbFWOutput.Invoke(new MethodInvoker(delegate { mtbFWOutput.Refresh(); }));
                }
                else
                {
                    mtbStatusFilterWheelMessage.Text = fwMessage;
                    mtbStatusFilterWheelMessage.Refresh();
                    mtbFWOutput.Text = fwMessage; 
                    mtbFWOutput.Refresh(); 
                }
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in update FW message. Ex = " + Ex.ToString());
            }
        }

        /// <summary>
        /// allow other classes and threads to update GUI
        /// </summary>
        /// <param name="msg"></param>
        public void UpdateNozzleMessage(string msg)
        {
            try
            {
                if (InvokeRequired)
                {
                    mtbNozzleControlStatus.Invoke(new MethodInvoker(delegate { mtbNozzleControlStatus.Text = msg; }));
                    mtbNozzleControlStatus.Invoke(new MethodInvoker(delegate { mtbNozzleControlStatus.Refresh(); }));
                    mtbStatusNozzleMessage.Invoke(new MethodInvoker(delegate { mtbStatusNozzleMessage.Text = msg; }));
                    mtbStatusNozzleMessage.Invoke(new MethodInvoker(delegate { mtbStatusNozzleMessage.Refresh(); }));
                }
                else
                {
                    mtbNozzleControlStatus.Text = msg;
                    mtbNozzleControlStatus.Refresh();
                    mtbStatusNozzleMessage.Text = msg;
                    mtbStatusNozzleMessage.Refresh();
                }

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in Update NZ message. Ex = " + Ex.ToString()); if (InvokeRequired)
                    if (InvokeRequired)
                    {
                        mtbNozzleControlStatus.Invoke(new MethodInvoker(delegate { mtbNozzleControlStatus.Text = "Error  See ErrorFile.txt"; }));
                        mtbNozzleControlStatus.Invoke(new MethodInvoker(delegate { mtbNozzleControlStatus.Refresh(); }));
                        mtbStatusNozzleMessage.Invoke(new MethodInvoker(delegate { mtbStatusNozzleMessage.Text = "Error  See ErrorFile.txt"; }));
                        mtbStatusNozzleMessage.Invoke(new MethodInvoker(delegate { mtbStatusNozzleMessage.Refresh(); }));
                    }
                    else
                    {
                        mtbNozzleControlStatus.Text = "Error  See ErrorFile.txt";
                        mtbNozzleControlStatus.Refresh();
                        mtbStatusNozzleMessage.Text = "Error";
                        mtbStatusNozzleMessage.Refresh();
                    }


            }
        }

        bool LogInstanceInfo()
        {

            //            FileVersionInfo myFileVersionInfo = FileVersionInfo.GetVersionInfo("WindowsSystem625.exe");   //change this for 920 etc...  
            //            mlVersionNumber.Text = myFileVersionInfo.FileVersion;

            Process currentProcess = Process.GetCurrentProcess();


            Logger.WriteInternalLogFile("Running instance name = " + currentProcess.ProcessName);

            myFileVersionInfo = FileVersionInfo.GetVersionInfo(currentProcess.ProcessName+".exe");     
            mlVersionNumber.Text = myFileVersionInfo.FileVersion;


            //var runningProcess = (from process in Process.GetProcesses()
            //                      where
            //                        process.Id != currentProcess.Id &&
            //                        process.ProcessName.Equals(
            //         currentProcess.ProcessName,
            //                          StringComparison.Ordinal)
            //                      select process).FirstOrDefault();

            //if (runningProcess != null)
            //{
            //    ShowWindow(runningProcess.MainWindowHandle, SW_SHOWMAXIMIZED);
            //    SetForegroundWindow(runningProcess.MainWindowHandle);

            //    return false;
            //}


            return true;
        }


        bool EnsureSingleInstance()
        {
            Process currentProcess = Process.GetCurrentProcess();

            var runningProcess = (from process in Process.GetProcesses()
                                  where
                                    process.Id != currentProcess.Id &&
                                    process.ProcessName.Equals(currentProcess.ProcessName,StringComparison.Ordinal)
                                  select process).FirstOrDefault();

            if (runningProcess != null)
            {
                //ShowWindow(runningProcess.MainWindowHandle, SW_SHOWMAXIMIZED);
                //SetForegroundWindow(runningProcess.MainWindowHandle);
                DialogResult dialogResult = MetroMessageBox.Show(this,"XactControl already running", "", MessageBoxButtons.OK, MessageBoxIcon.Warning, MessageBoxDefaultButton.Button1 /*,height=250*/);
                if (dialogResult == DialogResult.OK)
                {
                    Application.Exit();
                    return false;
                }
            }

            return true;
        }

        //havent been able to get these functions to work....

        //[DllImport("user32.dll", EntryPoint = "SetForegroundWindow")]
        //private static extern bool SetForegroundWindow(IntPtr hWnd);

        //[DllImport("user32.dll")]
        //private static extern Boolean ShowWindow(IntPtr hWnd, Int32 nCmdShow);

        //private const int SW_SHOWMAXIMIZED = 3;





        /// <summary>
        /// allow other classes and threads to update GUI
        /// </summary>
        /// <param name="msg"></param>
        public void UpdateDynamicRodMessage(string msg)
        {
            try
            {
                if (InvokeRequired)
                {
                    mtbStatusDynamicRodMessage.Invoke(new MethodInvoker(delegate { mtbStatusDynamicRodMessage.Text = msg; }));
                    mtbStatusDynamicRodMessage.Invoke(new MethodInvoker(delegate { mtbStatusDynamicRodMessage.Refresh(); }));
                    mtbDROutput.Invoke(new MethodInvoker(delegate { mtbDROutput.Text = msg; }));
                    mtbDROutput.Invoke(new MethodInvoker(delegate { mtbDROutput.Refresh(); }));
                }
                else
                {
                    mtbStatusDynamicRodMessage.Text =msg;
                    mtbStatusDynamicRodMessage.Refresh();
                    mtbDROutput.Text = msg;
                    mtbDROutput.Refresh();
                }

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in update DR message. Ex = " + Ex.ToString()); if (InvokeRequired)
                if(InvokeRequired)
                {
                    mtbStatusDynamicRodMessage.Invoke(new MethodInvoker(delegate { mtbStatusDynamicRodMessage.Text = "Error  See ErrorFile.txt"; }));
                    mtbStatusDynamicRodMessage.Invoke(new MethodInvoker(delegate { mtbStatusDynamicRodMessage.Refresh(); }));
                    mtbDROutput.Invoke(new MethodInvoker(delegate { mtbDROutput.Text = "Error  See ErrorFile.txt"; }));
                    mtbDROutput.Invoke(new MethodInvoker(delegate { mtbDROutput.Refresh(); }));
                }
                else
                {
                    mtbStatusDynamicRodMessage.Text = "Error  See ErrorFile.txt";
                    mtbStatusDynamicRodMessage.Refresh();
                    mtbDROutput.Text = "Error";
                    mtbDROutput.Refresh();
                }


            }
        }

        
        
        
        /// <summary>
        /// allow other classes and threads to update status GUI
        /// </summary>
        /// <param name="msg"></param>
        public void UpdateOperationMessage(string msg)
        {
            try
            {
                //log the operation messages
                //Logger.WriteLogFile( msg);
                //
                if (InvokeRequired)
                {
                    mtbStatusOperation.Invoke(new MethodInvoker(delegate { mtbStatusOperation.Text = msg; }));
                    mtbStatusOperation.Invoke(new MethodInvoker(delegate { mtbStatusOperation.Refresh(); }));
                }
                else
                {
                    mtbStatusOperation.Text = msg;
                    mtbStatusOperation.Refresh();
                }

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in update status operation message. Ex = " + Ex.ToString());
            }
        }

        /// <summary>
        /// allow other classes and threads to update GUI
        /// </summary>
        /// <param name="msg"></param>
        public void UpdateMaintTapeMessage(string msg)
        {
            try
            {
                if (InvokeRequired)
                {
                    
                    mtbTapeControlStatus.Invoke(new MethodInvoker(delegate { mtbTapeControlStatus.Text = msg; }));
                    mtbTapeControlStatus.Invoke(new MethodInvoker(delegate { mtbTapeControlStatus.Refresh(); }));
                }
                else
                {
                    mtbTapeControlStatus.Text = msg;
                    mtbTapeControlStatus.Refresh();
                }

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in Update Maint Tape Control Status message. Ex = " + Ex.ToString());
            }
        }





        //update xray progress bar


        /// <summary>
        /// allow other classes and threads to update GUI
        /// </summary>
        /// <param name="msg"></param>
        public void UpdateMaintCheckMessage(string msg)
        {
            try
            {
                if (InvokeRequired)
                {
                    mtbMaintCheckMessage.Invoke(new MethodInvoker(delegate { mtbMaintCheckMessage.Text = msg; }));
                    mtbMaintCheckMessage.Invoke(new MethodInvoker(delegate { mtbMaintCheckMessage.Refresh(); }));
                }
                else
                {
                    mtbMaintCheckMessage.Text = msg;
                    mtbMaintCheckMessage.Refresh();
                }

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in Update Maint Status message. Ex = " + Ex.ToString());
            }
        }
        /// <summary>
        /// allow other classes and threads to update GUI
        /// </summary>
        /// <param name="msg"></param>
        public void UpdateFlowCalPromptMessage(string msg)
        {
            try
            {
                if (InvokeRequired)
                {
                    tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = msg; }));
                    tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Refresh(); }));
                }
                else
                {
                    tbMetroCalPrompt.Text = msg;
                    tbMetroCalPrompt.Refresh();
                }

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in Update Cal Prompt message. Ex = " + Ex.ToString());
            }
        }


        void Form1_KeyPress(object sender, KeyPressEventArgs e)
        {
            //string value;
            //value = mtbKeyPress.Text;
            //string pressValue = e.KeyChar.ToString();
            //value += pressValue;
            //mtbKeyPress.Text = value; 
            /*
            if (e.KeyChar >= 48 && e.KeyChar <= 57)
            {
                MessageBox.Show("Form.KeyPress: '" +
                    e.KeyChar.ToString() + "' pressed.");

                switch (e.KeyChar)
                {
                    case (char)49:
                    case (char)52:
                    case (char)55:
                        MessageBox.Show("Form.KeyPress: '" +
                            e.KeyChar.ToString() + "' consumed.");
                        e.Handled = true;
                        break;
                }
            }
            */
        }


        void mtbKeyPress_KeyPress(object sender, KeyPressEventArgs e)
        {
            /*
            if (e.KeyChar >= 48 && e.KeyChar <= 57)
            {
                MessageBox.Show("Control.KeyPress: '" +
                    e.KeyChar.ToString() + "' pressed.");

                switch (e.KeyChar)
                {
                    case (char)50:
                    case (char)53:
                    case (char)56:
                        MessageBox.Show("Control.KeyPress: '" +
                            e.KeyChar.ToString() + "' consumed.");
                        e.Handled = true;
                        break;
                }
            }
            */

        }


        public void RampXraysToZero()
        {
            /*
            try
            {

                xrayOnCommand = 0;
                //ticket #65 add ramp to zero call at shutdown
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                int returnVal;

                //read presentV (actual 'kV') from NI
                double presentV = 0.0;
                presentV = readInputVoltage;
                presentV = presentV * 50.0 / 10.0;

                //ActualV.Text = presentV.ToString();
                presentV = Math.Round(presentV, 2, MidpointRounding.AwayFromZero);


                //read presentI (actual i) from NI
                double presentI = 0.0;
                presentI = readInputCurrent;
                presentI = presentI * 2000.0 / 10.0;
                presentI = Math.Round(presentI, 2, MidpointRounding.AwayFromZero);


                if (presentV > 5 && presentI > 10)
                {
                    UpdateOperationMessage("Shutting down:  ramp down xrays");
                    //Logger.WriteLogFile("Pausing shutdown to ramp down xrays...");

                    returnVal = AcquisitionControl.RampXrays(presentV, presentI, 0.0, 0.0, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                    Thread.Sleep(6000);
                    //InterlockOpen();
                    //if (metroToggleFlowCal.InvokeRequired)
                    //{
                    //    metroToggleFlowCal.Invoke(new MethodInvoker(delegate { checkState = metroToggleFlowCal.CheckState; }));
                    //}
                    //else
                    //{
                    //    checkState = metroToggleFlowCal.CheckState;
                    //}

                    if (mtbInterlockStatus.InvokeRequired)
                    {
                        mtbInterlockStatus.Invoke(new MethodInvoker(delegate { mtbInterlockStatus.Text = "OPEN"; }));

                    }
                    else
                    {
                        mtbInterlockStatus.Text = "OPEN";
                    }
                    Thread.Sleep(1000);

                }

            }
            catch (Exception Ex)
            {
                Logger.WriteErrorFile("Error:  shut down xray ramp to zero.  Ex = " + Ex.ToString());
                Logger.WriteInternalLogFile("Exception in shut down xray ramp to zero.  Ex = " + Ex.ToString());
            }
            */
            int countTimeout = 0;
            int cancelAnyRamp = 0;
            try
            {
                //if (rampActive == 1)
                //{
                if (m_oWorkerRamp.IsBusy)
                {
                    Logger.WriteInternalLogFile("In RXTZ.  worker ramp is busy.");
                }
                else
                {
                    Logger.WriteInternalLogFile("In RXTZ.  worker ramp is NOT busy.");

                }

                do
                {
                    if (cancelAnyRamp == 0)
                    {
                        try
                        {
                            if (m_oWorkerRamp.IsBusy)
                            {
                                Logger.WriteInternalLogFile("Ramp is busy. Timeout= "+countTimeout.ToString());
                                m_oWorkerRamp.CancelAsync();
                            }
                            else
                            {
                                cancelAnyRamp = 1;

                                break;
                            }
                        }
                        catch (Exception Ex)
                        {
                            Logger.WriteInternalLogFile("Ex cancel async ramp. Ex= " + Ex.ToString());
                            cancelAnyRamp = 1;

                            break;

                        }
                    }

                        countTimeout++;
                        Thread.Sleep(100);
                    } while (rampActive == 1 && countTimeout < 100);
                //}

                xrayOnCommand = 0;
                //ticket #65 add ramp to zero call at shutdown
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                int returnVal;

                //read presentV (actual 'kV') from NI
                double presentV = 0.0;
                presentV = readInputVoltage;
                presentV = presentV * 50.0 / 10.0;

                //ActualV.Text = presentV.ToString();
                presentV = Math.Round(presentV, 2, MidpointRounding.AwayFromZero);


                //read presentI (actual i) from NI
                double presentI = 0.0;
                presentI = readInputCurrent;
                presentI = presentI * 2000.0 / 10.0;
                presentI = Math.Round(presentI, 2, MidpointRounding.AwayFromZero);


                if (presentV > 0 || presentI > 0)
                {
                    UpdateOperationMessage("Ramp down X-rays");
                    //Logger.WriteLogFile("c:/temp/shutdown.txt", "Pausing shutdown to ramp down xrays...");
                    if (m_oWorkerRamp.IsBusy)
                    {
                        Logger.WriteInternalLogFile("In RXTZ after cancel async.  Worker ramp is busy.");
                    }
                    else
                    {
                        Logger.WriteInternalLogFile("In RXTZ after cancel async.  Worker ramp is NOT busy.");

                    }
                    Logger.WriteInternalLogFile("Ramping Xrays to Zero:  rampActive = " + rampActive.ToString());
                    Logger.WriteInternalLogFile("Ramping Xrays to Zero:  presentV = " + presentV.ToString());
                    Logger.WriteInternalLogFile("Ramping Xrays to Zero:  presentI = " + presentI.ToString());

                    int rtz = 0;
                    do
                    {
                        rtz++;
                        RampXraysToZeroActive = 1;
                        int RampTimeout = 0;
                        do
                        {
                            RampTimeout++;
                            Logger.WriteInternalLogFile("attempt to cancel running ramp, counter = " + RampTimeout.ToString());
                            try
                            {
                                m_oWorkerRamp.CancelAsync();
                            }
                            catch (Exception Ex)
                            {
                                Logger.WriteInternalLogFile("Ex attempt to cancel running ramp, Ex = " + Ex.ToString());

                            }
                            Thread.Sleep(100);

                        } while (m_oWorkerRamp.IsBusy && RampTimeout < 100);

                        returnVal = AcquisitionControl.RampXrays(presentV, presentI, 0.0, 0.0, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                        Logger.WriteInternalLogFile("RampXrays to zero ret val = " + returnVal.ToString());
                    } while (rtz <= 2 && returnVal == FAIL);            

                    //this is an incorrect display item
                    //if (mtbInterlockStatus.InvokeRequired)
                    //{
                    //    mtbInterlockStatus.Invoke(new MethodInvoker(delegate { mtbInterlockStatus.Text = "OPEN"; }));
                    //}
                    //else
                    //{
                    //    mtbInterlockStatus.Text = "OPEN";
                    //}
                    //Thread.Sleep(1000);

                }

            }
            catch (Exception Ex)
            {
                Logger.WriteErrorFile("Error:  shut down xray ramp to zero.  Ex = " + Ex.ToString());
             
                Logger.WriteInternalLogFile("Exception in shut down xray ramp to zero.  Ex = " + Ex.ToString());
            }
        }



        /// <summary>
        /// Override the Close Form event
        /// Perform action on program shut down
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void Form1_FormClosing(Object sender, FormClosingEventArgs e)
        {
            try
            {
                e.Cancel = true;


                //shut down cross
                //this may cause parts of cross to hang -- and require a PC reboot therefore this is removed
                //try
                //{
                //foreach (Process proc in Process.GetProcessesByName("XRS-FP"))
                //{
                //    proc.Kill();
                //}
                //}
                //catch (Exception ex)
                //{
                //    MessageBox.Show(ex.Message);
                //}


                //ticket #65 add ramp to zero call at shutdown
                //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                //int returnVal;
                double rate = 0.5;//update every half second

                //read presentV (actual 'kV') from NI
                double presentV = 0.0;
                presentV = readInputVoltage;
                presentV = presentV * 50.0 / 10.0;

                //ActualV.Text = presentV.ToString();
                presentV = Math.Round(presentV, 2, MidpointRounding.AwayFromZero);


                //read presentI (actual i) from NI
                double presentI = 0.0;
                presentI = readInputCurrent;
                presentI = presentI * 2000.0 / 10.0;
                presentI = Math.Round(presentI, 2, MidpointRounding.AwayFromZero);
                int time = 3;
                //int powerCheck = 0;
                //int powerCount = 0;
                //do
                //{
                List<double> VoltageValuesShutdown = new List<double>();
                List<double> CurrentValuesShutdown = new List<double>();

                calcLinearRampVoltageShutdown(presentV, 0.0, time, 0.5,VoltageValuesShutdown);   //present v, target v, time to transition, output rate per second
                calcLinearRampCurrentShutdown(presentI, 0.0, time, 0.5, CurrentValuesShutdown);   //present i, target i, time to transition, output rate per second

                    //powerCheck = CheckTubeOutPower(VoltageValues, CurrentValues);
                    //powerCount++;

                //} while (powerCheck == 1 && powerCount < 1);

                if (presentV > 0 && presentI > 0)
                {
                    UpdateOperationMessage("Shutting down:  ramp down xrays");
                    // Logger.WriteLogFile("Pausing shutdown to ramp down xrays...");
                   // returnVal = AcquisitionControl.RampXrays(presentV, presentI, 0.0, 0.0, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                    ShutdownXrayRamp(VoltageValuesShutdown,CurrentValuesShutdown, rate);

                    //int shCount=0;
                    //do
                    //{
                    //    //add check for shutdown counter
                    //    Thread.Sleep(100);
                    //    shCount += 1;
                    //} while (shCount < 90);

                    //Thread.Sleep(3000);
                    //AcquisitionControl.InterlockOpen(this);
                    //if (metroToggleFlowCal.InvokeRequired)
                    //{
                    //    metroToggleFlowCal.Invoke(new MethodInvoker(delegate { checkState = metroToggleFlowCal.CheckState; }));
                    //}
                    //else
                    //{
                    //    checkState = metroToggleFlowCal.CheckState;
                    //}

                    if (mtbInterlockStatus.InvokeRequired)
                    {
                        mtbInterlockStatus.Invoke(new MethodInvoker(delegate { mtbInterlockStatus.Text = "OPEN"; }));

                    }
                    else
                    {
                        mtbInterlockStatus.Text = "OPEN";
                    }
                    //Thread.Sleep((int)(rate*1000));

                }



                //In case windows is trying to shut down, don't hold the process up
                if (e.CloseReason == CloseReason.WindowsShutDown)
                {

                    if (nModbusOperations.slaveThread.IsAlive == true)
                    {

                        nModbusOperations.slaveThread.Abort();
                        Logger.WriteLogFile("1 nmodbusOperations slave thread abort.");
                    }

                }

                if (this.DialogResult == DialogResult.Cancel)
                {
                    if (nModbusOperations.slaveThread.IsAlive == true)
                    {
                        nModbusOperations.slaveThread.Abort();
                        Logger.WriteLogFile("2 nmodbusOperations slave thread abort.");
                    }
                    // Assume that X has been clicked and act accordingly.
                    // Confirm user wants to close
                    /*
                    switch (MessageBox.Show(this, "Are you sure?", "Do you still want ... ?", MessageBoxButtons.YesNo, MessageBoxIcon.Question))
                    {
                        //Stay on this form
                        case DialogResult.No:
                            e.Cancel = true;
                            break;
                        default:
                            break;
                    }
                    */
                }
                else
                {
                    try
                    {
                        if (nModbusOperations.slaveThread.IsAlive == true)
                        {
                            nModbusOperations.slaveThread.Abort();
                            Logger.WriteInternalLogFile("nodbusOperations slave thread abort at shutdown.");
                        }
                    }
                    catch
                    {
                        Logger.WriteInternalLogFile("nmodbusOperations slave thread abort at shutdown.  Thread not started");

                    }
                }
            

            }

            catch (Exception Ex)
            {
                Logger.WriteLogFile("Ex in program shutdown.  Ex = " + Ex.ToString());
            }

            finally
            {
                //Logger.wrapUpLog();
                e.Cancel = false;

                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                AcquisitionControl.InterlockOpen(this);
            }
        }



        private static void calcLinearRampVoltageShutdown(double V1, double V2, double timeInSeconds, double rate, List<double> LinearRampValuesVoltage)
        {

            LinearRampValuesVoltage.Clear();
            double delta = 0.0;
            double dnumberOfSteps;
            int numberOfSteps;

            double scaleV1 = (V1 / 50.0) * 9.99;  //NI board can not output 10.0
            double scaleV2 = (V2 / 50.0) * 9.99;  //NI board can not output 10.0

            //break down the load of the list of values in rate second increments

            //0  2000
            //2000 0
            delta = scaleV2 - scaleV1;
            dnumberOfSteps = timeInSeconds / rate;
            numberOfSteps = (int)dnumberOfSteps;

            double stepValue = 0.0;

            stepValue = delta / numberOfSteps;

            // note number of steps may need to be rounded 
            for (int i = 1; i <= numberOfSteps; i++)
            {
                LinearRampValuesVoltage.Add(scaleV1 + (stepValue * i));
            }

            string stringValue;


            for (int index = 0; index < LinearRampValuesVoltage.Count; index++)
            {
                stringValue = LinearRampValuesVoltage[index].ToString();
                //Logger.WriteLogFile("linear ramp voltage = " + stringValue);

            }

        }

        private void calcLinearRampCurrentShutdown(double presentI, double targetCurrent, int time, double rate, List<double> LinearRampValuesCurrent)
        {
            LinearRampValuesCurrent.Clear();
            double delta = 0.0;
            double numberOfSteps;

            double scaleI1 = (presentI / 2000) * 9.99;
            double scaleI2 = (targetCurrent / 2000) * 9.99;



            delta = scaleI2 - scaleI1;
            numberOfSteps = (time / rate);
            double stepValue = 0.0;
            stepValue = delta / numberOfSteps;
            double tempValue = 0;

            for (int i = 1; i <= (int)numberOfSteps; i++)
            {
                tempValue = scaleI1 + (stepValue * i);
                if (delta > 0.0 && tempValue < 0.36)
                    tempValue = 0.36;
                LinearRampValuesCurrent.Add(scaleI1 + (stepValue * i));
            }


            string stringValue;
            //dataFile6.WriteLine("START current output data array............................");
            for (int index = 0; index < LinearRampValuesCurrent.Count; index++)
            {

                stringValue = LinearRampValuesCurrent[index].ToString();

                //dataFile4.WriteLine("Outuput {0:F04}, Error P {1:F04}", OutputVoltage, Error * Kp);
                //dataFile4.WriteLine("v out= ,{0:F04}, {1:F04}", rawUPvOut_EC1[index], rawUPaOut_EC1[index]);

                //dataFile6.WriteLine(stringValue);   //this does a file write 
                //Logger.WriteLogFile("linear ramp current = " + stringValue);


            }
            //dataFile6.Close();




        }






        private void ShutdownXrayRamp(List<double> LinearRampValuesVoltageShutdown, List<double> LinearRampValuesCurrentShutdown, double rate)
        {
            /*
            string[] RampValues = new string[4];
            //grab next value for output

            //generate output

            //Update status bar and values

            double voltageOutputValue;
            double currentOutputValue;
            double actCurrent;
            double actVoltage;
            //string timeStampForLog;
            //string stringValue;
            //string[] values;

            //int counter;
            //double progress;
            //int iprogress;

            int rampIndexSD=0;

            double total;  //size of linearRampValuesVoltage
                           //AcquisitionLogic AcquisitionControl = new AcquisitionLogic();
                           //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            //values = new string[4];




            //if (Monitor.TryEnter(rampLockObj))
            //{

            try
            {

                total = LinearRampValuesVoltageShutdown.Count;
                do
                {


                    voltageOutputValue = LinearRampValuesVoltageShutdown[rampIndexSD];
                    currentOutputValue = LinearRampValuesCurrentShutdown[rampIndexSD];

                    WriteOutputVoltage(voltageOutputValue);
                    WriteOutputCurrent(currentOutputValue);
                    //this is here to allow a delay on the last two reads so that the display reflects reality.

                    actCurrent = readInputCurrent;
                    actVoltage = readInputVoltage;


                    double kVolt = actVoltage * 50.0 / 10.0;

                    kVolt = Math.Round(kVolt, 2, MidpointRounding.AwayFromZero);


                    //double uAmp = Convert.ToDouble(values[1]);
                    double uAmp = actCurrent * 2000.0 / 10.0;
                    uAmp = Math.Round(uAmp, 2, MidpointRounding.AwayFromZero);





                    //total = LinearRampValuesVoltage.Count;
                    //if (rampIndexSD < (total - 1))
                    //{
                        rampIndexSD++;
                        //m_oWorkerRamp.ReportProgress(iprogress, values);
                        //change from report progress to invoke function calls
                        UpdatekVMessage(kVolt.ToString("F2"));
                        UpdateuAMessage(uAmp.ToString("F2"));
                        Thread.Sleep((int)(rate*1000));
                        //UpdateXrayProgressBar(iprogress);


                    //}
                    //else
                    //{
                    //    //stop the timed event, and stop the thread it's running on
                    //    //try
                    //    //{
                    //    //    if (m_oWorkerRamp.CancellationPending == false)
                    //    //    {
                    //    //        //m_oWorkerRamp.ReportProgress(100, values);
                    //    //        UpdatekVMessage(kVolt.ToString("F2"));
                    //    //        UpdateuAMessage(uAmp.ToString("F2"));
                    //    //        UpdateXrayProgressBar(100);

                    //    //        //m_oWorkerRamp.CancelAsync();
                    //    //        //RampTimer.Enabled = true;

                    //    //    }
                    //    //}
                    //    //catch (Exception Ex)
                    //    //{
                    //    //    //Logger.WriteLogFile( , "ex at  ramp report progress:  " + Ex.ToString());
                    //    //}

                    //}




                } while (rampIndexSD < total);

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in Shutdown Xray Ramp logic = " + Ex.ToString());
            }
            finally
            {

                //Logger.WriteLogFile( "@finally, done with xray power ramp thread.");
                //Monitor.Exit(rampLockObj);
                WriteOutputVoltage(0.0);
                WriteOutputCurrent(0.0);
                actCurrent = readInputCurrent;
                actVoltage = readInputVoltage;
                double kVolt = actVoltage * 50.0 / 10.0;

                kVolt = Math.Round(kVolt, 2, MidpointRounding.AwayFromZero);


                //double uAmp = Convert.ToDouble(values[1]);
                double uAmp = actCurrent * 2000.0 / 10.0;
                uAmp = Math.Round(uAmp, 2, MidpointRounding.AwayFromZero);
                UpdatekVMessage(kVolt.ToString("F2"));
                UpdateuAMessage(uAmp.ToString("F2"));


            }

            //}
            //else
            //{
            //    //lock not obtained for this timer.
            //    Logger.WriteInternalLogFile("X-ray power ramp, lock not obtained for this timer....");
            //
            //}
            */

            string[] RampValues = new string[4];
            //grab next value for output

            //generate output

            //Update status bar and values

            double voltageOutputValue;
            double currentOutputValue;
            double actCurrent;
            double actVoltage;
            //string timeStampForLog;
            //string stringValue;
            //string[] values;

            //int counter;
            //double progress;
            //int iprogress;

            int rampIndexSD = 0;

            double total;  //size of linearRampValuesVoltage
                           //AcquisitionLogic AcquisitionControl = new AcquisitionLogic();
                           //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            //values = new string[4];




            //if (Monitor.TryEnter(rampLockObj))
            //{

            try
            {

                total = LinearRampValuesVoltageShutdown.Count;
                do
                {


                    voltageOutputValue = LinearRampValuesVoltageShutdown[rampIndexSD];
                    currentOutputValue = LinearRampValuesCurrentShutdown[rampIndexSD];

                    WriteOutputVoltage(voltageOutputValue);
                    WriteOutputCurrent(currentOutputValue);


                    actCurrent = readInputCurrent;
                    actVoltage = readInputVoltage;


                    double kVolt = actVoltage * 50.0 / 10.0;

                    kVolt = Math.Round(kVolt, 2, MidpointRounding.AwayFromZero);


                    //double uAmp = Convert.ToDouble(values[1]);
                    double uAmp = actCurrent * 2000.0 / 10.0;
                    uAmp = Math.Round(uAmp, 2, MidpointRounding.AwayFromZero);





                    //total = LinearRampValuesVoltage.Count;
                    //if (rampIndexSD < (total - 1))
                    //{
                    rampIndexSD++;
                    //m_oWorkerRamp.ReportProgress(iprogress, values);
                    //change from report progress to invoke function calls
                    UpdatekVMessage(kVolt.ToString("F2"));
                    UpdateuAMessage(uAmp.ToString("F2"));
                    Thread.Sleep((int)(rate * 1000));
                    //UpdateXrayProgressBar(iprogress);


                    //}
                    //else
                    //{
                    //    //stop the timed event, and stop the thread it's running on
                    //    //try
                    //    //{
                    //    //    if (m_oWorkerRamp.CancellationPending == false)
                    //    //    {
                    //    //        //m_oWorkerRamp.ReportProgress(100, values);
                    //    //        UpdatekVMessage(kVolt.ToString("F2"));
                    //    //        UpdateuAMessage(uAmp.ToString("F2"));
                    //    //        UpdateXrayProgressBar(100);

                    //    //        //m_oWorkerRamp.CancelAsync();
                    //    //        //RampTimer.Enabled = true;

                    //    //    }
                    //    //}
                    //    //catch (Exception Ex)
                    //    //{
                    //    //    //Logger.WriteLogFile("c:/temp/acquisition.txt", "ex at  ramp report progress:  " + Ex.ToString());
                    //    //}

                    //}




                } while (rampIndexSD < total);

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in Shutdown Xray Ramp logic = " + Ex.ToString());
            }
            finally
            {

                //Logger.WriteLogFile("c:/temp/Acquisition.txt", "@finally, done with xray power ramp thread.");
                //Monitor.Exit(rampLockObj);
                WriteOutputVoltage(0.0);
                WriteOutputCurrent(0.0);
                actCurrent = readInputCurrent;
                actVoltage = readInputVoltage;
                double kVolt = actVoltage * 50.0 / 10.0;

                kVolt = Math.Round(kVolt, 2, MidpointRounding.AwayFromZero);


                //double uAmp = Convert.ToDouble(values[1]);
                double uAmp = actCurrent * 2000.0 / 10.0;
                uAmp = Math.Round(uAmp, 2, MidpointRounding.AwayFromZero);
                UpdatekVMessage(kVolt.ToString("F2"));
                UpdateuAMessage(uAmp.ToString("F2"));

                AcquisitionLogic AcquisitionControl = new AcquisitionLogic();
                AcquisitionControl.InterlockOpen(this);


            }

            //}
            //else
            //{
            //    //lock not obtained for this timer.
            //    Logger.WriteInternalLogFile("X-ray power ramp, lock not obtained for this timer....");
            //
            //}



        }



        /// <summary>
        /// Adapt launch example 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e2"></param>
        private void MetroTabControl2_Selected(object sender, TabControlEventArgs e2)
        {

            //if (e2.TabPageIndex == 0)
            //{
            //    //adapt launch



            //    //use web-browser control(fully contained in program)
            //    //integration requires write to registry to force the integrated webbrowser tool to be version 11, not 7.
            //    //webBrowser1.ScriptErrorsSuppressed = true;
            //    //webBrowser1.Navigate("http://localhost:8000/view/");


            //    //launch chrome, using the correct URL:

            //    //    Process.Start("chrome", @"http://localhost:8000/view/");

            //}
            //if (e2.TabPageIndex ==0)
            //{ 
                //concentration data


                try
                {

                    rtbData.Clear();

                    mdtStart.Value = DateTime.Today.AddDays(-7);
                    mdtEnd.Value = DateTime.Today.AddDays(+1);

                    //get start time
                    DateTime Start = mdtStart.Value;

                    //get end time
                    DateTime End = mdtEnd.Value;

                    var directory = new DirectoryInfo("c:/process_data/");
                    DateTime from_date = Start;
                    DateTime to_date = End;

                    var fileList = directory.GetFiles()
                        .Where(fileVal => fileVal.LastWriteTime >= from_date && fileVal.LastWriteTime <= to_date)
                        .OrderByDescending(d => d.CreationTime)
                        .ToList();


                    filesToParse.Clear();

                    foreach (var fileName in /*fileEntries*/ fileList)
                    {
                        if (fileName.Name.Contains("data1"))
                        {
                            continue;
                        }
                        else if (fileName.Name.Contains("data2"))
                        {
                            continue;
                        }
                        else if (fileName.Name.Contains("data3"))
                        {
                            continue;
                        }
                        else
                        {
                            filesToParse.Add(fileName.Name);
                        }
                    }
                    filesToParseIndex = 0;
                    string value = filesToParse[filesToParseIndex];
                    string path = "c:/process_data/";

                    System.IO.StreamReader sr = new System.IO.StreamReader(path + value);


                    string fText = sr.ReadToEnd();
                    /*
                    string[] terms = new string[500];

                    string[] lines = Regex.Split(fText, "\n");

                    // To parse your string 
                    var elements = fText.Split(new[]
                    { '\r','\n' }, System.StringSplitOptions.RemoveEmptyEntries);   // , System.StringSplitOptions.RemoveEmptyEntries);
                                                                                    // To Loop through
                    int index = 0;
                    int termindex = 0;
                    foreach (string items in elements)
                    {
                        // enjoy
                        index++;
                        string[] lines2 = Regex.Split(items, ",");
                        if (lines2.Count() == 5)
                        {
                            //we have found a line
                            terms[termindex] = items;
                            termindex++;
                        }


                    }
                    */
                    rtbData.SelectionStart = 0;  // or wherever you want to insert in this rtb
                    rtbData.SelectionLength = 0;
                    rtbData.SelectionFont = new System.Drawing.Font("Tahoma", 14);
                    rtbData.SelectedText = fText;

                    sr.Close();
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Exception in Data view.  Ex = " + Ex.ToString());

                }

            //}
            //add upscale tab:
            //else if()



        }





        private void EnableDisableAllSettingsControls(bool set)
        {

            tbMetroMotorComPort.Enabled = set;
            tbMetroWindComPort.Enabled = set;
            tbMetroModbusComPort.Enabled = set;
            cbMetroFlowControl.Enabled = set;
            cbMetroFlowSum.Enabled = set;
            tbMetroInletHeaterRH.Enabled = set;

            cbMetroSamplePeriod.Enabled = set;
            mbEnableDisableChanges.Enabled = set;
            mbSettingsSave.Enabled = false;
            mbOptions.Enabled = false;

            tbMetroEC1kV.Enabled = set;
            tbMetroEC1uA.Enabled = set;
            tbMetroEC1RunTimePercent.Enabled = set;
            tbMetroEC1RunTimeSeconds.Enabled = false;
            cbMetroEC1Filter.Enabled = set;
            cbMetroEC1AutoCurrent.Enabled = set;

            tbMetroEC2kV.Enabled = set;
            tbMetroEC2uA.Enabled = set;
            tbMetroEC2RunTimePercent.Enabled = set;
            tbMetroEC2RunTimeSeconds.Enabled = false;
            cbMetroEC2Filter.Enabled = set;
            cbMetroEC2AutoCurrent.Enabled = set;

            tbMetroEC3kV.Enabled = set;
            tbMetroEC3uA.Enabled = set;
            tbMetroEC3RunTimePercent.Enabled = set;
            tbMetroEC3RunTimeSeconds.Enabled = false;
            cbMetroEC3Filter.Enabled = set;
            cbMetroEC3AutoCurrent.Enabled = set;

            tbMetroEC4kV.Enabled = set;
            tbMetroEC4uA.Enabled = set;
            tbMetroEC4RunTimePercent.Enabled = set;
            tbMetroEC4RunTimeSeconds.Enabled = false;
            cbMetroEC4Filter.Enabled = set;
            cbMetroEC4AutoCurrent.Enabled = set;



            tbMetroUpscaleCr.Enabled = set;
            tbMetroUpscaleCd.Enabled = set;
            tbMetroUpscalePb.Enabled = set;
            tbMetroUpscaleEC4.Enabled = set;
            tbMetroUpscaleAlarmPercent.Enabled = set;
            tbMetroNb.Enabled = set;
            tbMetroNbAlarmPercent.Enabled = set;

            tbMetroEC1FilterPos.Enabled = set;
            tbMetroEC2FilterPos.Enabled = set;
            tbMetroEC3FilterPos.Enabled = set;
            tbMetroEC4FilterPos.Enabled = set;

            tbMetroUpscalePos.Enabled = set;
            tbMetroEnergyCalPos.Enabled = set;
            tbMetroEcalkV.Enabled = set;
            tbMetroEcaluA.Enabled = set;
            tbMetroEcalTime.Enabled = set;




        }
        private void EnableDisableAllFlowCalibrationControls(bool set)
        {
            mbEnableChangesCalFlow.Enabled = set;
            metroToggleFlowCal.Enabled = set;
            metroToggleLeakCheck.Enabled = set;
            metroToggle2.Enabled = set;
            metroToggle1.Enabled = set;
            mbPumpOn.Enabled = set;

            rbMetro150.Enabled = set;
            rbMetro167.Enabled = set;
            rbMetro184.Enabled = set;

            tbMetroAmbientTemp.Enabled = false;
            tbMetroAtmPressureCal.Enabled = false;
            tbMetroSamplePressure.Enabled = false;

            bMetroEnterDataButton.Enabled = set;
            tbMetroCalPrompt.Enabled = set;
            tbMetroCalEntry.Enabled = set;
            mtbPumpError.Enabled = false;

        }

        private void EnableDisableAllMaintenanceControls(bool set)
        {
            mbNozzleUp.Enabled = set;
            mbNozzleDown.Enabled = set;
            mtbNozzleControlStatus.Enabled = false;

            //metroPanel34.Enabled = set;
            mbMoveTapeHalf.Enabled = set;
            mbMoveTapeFull.Enabled = set;
            mtbTapeControlStatus.Enabled = false;
            mtbResetTapeRemaining.Enabled = false;

            mbDynamicRodHome.Enabled = set;
            mbDynamicRodForward.Enabled = set;
            mbDynamicRodReverse.Enabled = set;
            mbMoveDynamicRodToEcalPosition.Enabled = set;
            mbMoveDynamicRodtoUpscalePosition.Enabled = set;
            mtbDynamicRodStatus.Enabled = set;

            metroTextBox24.Enabled = set;
            mtbDROutput.Enabled= false;

            mbMoveFilterWheelHome.Enabled = set;
            mtbFilterWheelMove.Enabled = set;
            mbFilterWheelAdvance.Enabled = set;
            mbFilterWheelReverse.Enabled = set;

            mbMoveFWtoEC1.Enabled = set;
            mbMoveFWtoEC2.Enabled = set;
            mbMaintMoveFWtoEC3.Enabled = set;
            mbMaintMoveFWtoEC4.Enabled = set;

            mtbFWOutput.Enabled = false;
            metroButton5.Enabled = set;
            metroButton6.Enabled = set;
            mtbMaintInterlockStatus.Enabled = false;
            metroButton7.Enabled = set;
            metroButton8.Enabled = set;
            metroTextBox1.Enabled = false;

            metroTextBox2.Enabled = set;
            mrbEcal.Enabled = set;
            mrbManual.Enabled = set;
            mrbUpscale.Enabled = set;
            metroRadioButton1.Enabled = set;
            metroRadioButton2.Enabled = set;
            metroRadioButton3.Enabled = set;
            metroRadioButton4.Enabled = set;

            mbRunManualAcq.Enabled = set;
            metroButton12.Enabled = set;
            mbTubeSeasoning.Enabled = set;
            mbWarmUp.Enabled = set;
            mtbMaintCheckMessage.Enabled = false;
            mbXrfSaveSpectra.Enabled = set;
            metroTextBox3.Enabled = set;
            mbInitXrsfp.Enabled = set;
            mtbMaintenanceTargetkV.Enabled = set;
            mtbMaintenanceTargetuA.Enabled = set;
            mtbActualkV.Enabled = false;
            mtbActualuA.Enabled = false;
            mbRampToTarget.Enabled = set;
            mbMaintenanceRampToZero.Enabled = true;


        }




        private void MetroTabControlSettings_Selected(object sender, TabControlEventArgs e)
        {

            
            if (e.TabPageIndex == 0) //Status Tab
            {

                if (DataContainer.displayItem == 10)
                {
                    //reset the display to ok --Set to 10 if the resetWarning button is pushed
                    // green if running and grey if stopped
                    if (mbRun.Text =="Run") //it's stopped
                    {
                        //mbRun.BackColor = Color.Gray;
                        metroStatusButton.BackColor = Color.Gray;
                    }
                    else
                    {
                        //mbRun.BackColor = Color.Green;
                        metroStatusButton.BackColor = Color.Green;

                    }
                    DataContainer.displayItem = 0;
                    
                }





            }
            if (e.TabPageIndex == 1) //data Tab
            {

                //from 9 2 0 

                try
                {
                    mtbDataOutputMessage.Text = "";
                    mtbDataOutputMessage.Refresh();
                    rtbData.Clear();

                    mdtStart.Value = DateTime.Today.AddDays(-7);
                    mdtEnd.Value = DateTime.Today.AddDays(+1);

                    //get start time
                    DateTime Start = mdtStart.Value;

                    //get end time
                    DateTime End = mdtEnd.Value;

                    var directory = new DirectoryInfo("c:/process_data/");
                    DateTime from_date = Start;
                    DateTime to_date = End;

                    var fileList = directory.GetFiles()
                        .Where(fileVal => fileVal.LastWriteTime >= from_date && fileVal.LastWriteTime <= to_date)
                        .OrderByDescending(d => d.CreationTime)
                        .ToList();


                    filesToParse.Clear();

                    foreach (var fileName in fileList)
                    {
                        if (fileName.Name.Contains("data1"))
                        {
                            continue;
                        }
                        else if (fileName.Name.Contains("data2"))
                        {
                            continue;
                        }
                        else if (fileName.Name.Contains("data3"))
                        {
                            continue;
                        }
                        else if (fileName.Name.Contains(".zip"))
                        {
                            continue;
                        }
                        else
                        {
                            filesToParse.Add(fileName.Name);
                        }
                    }
                    filesToParseIndex = 0;
                    string value = filesToParse[filesToParseIndex];
                    string path = "c:/process_data/";

                    //System.IO.StreamReader sr = new System.IO.StreamReader(path + value);

                    string[] logFile = File.ReadAllLines(path + value);

                    List<string> logList = new List<string>(logFile);

                    List<string> temp = new List<string>();

                    temp = AdjustDataForDisplay(logList);


                    string fText = string.Empty;
                    foreach (string s in temp)
                    {
                        fText = fText + s;
                    }


                    //string fTextTemp = sr.ReadToEnd();


                    //string fText = AdjustDisplayData(fTextTemp);

                    //var logList = new List<string>(fText);




                    rtbData.SelectionStart = 0;  // or wherever you want to insert in this rtb
                    rtbData.SelectionLength = 0;
                    //rtbData.SelectionFont = new System.Drawing.Font("Tahoma", 14);
                    //rtbData.SelectionFont = new System.Drawing.Font("TimesNewRoman", 10);
                    rtbData.SelectionFont = new System.Drawing.Font("Consolas", 10);
                    rtbData.SelectedText = fText;





                    //dataGridView1.= fText;
                    //DataTable dt = GetDataTable(txtFileName.Text);
                    //dataGridView1.DataSource = dt.DefaultView;

                    //sr.Close();




                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Exception in Data view.  Ex = " + Ex.ToString());
                }




                //end 9 2 0


                //                try
                //                {
                //                    mtbDataOutputMessage.Text = "";
                //                    mtbDataOutputMessage.Refresh();
                //                    rtbData.Clear();

                //                    mdtStart.Value = DateTime.Today.AddDays(-7);
                //                    mdtEnd.Value = DateTime.Today.AddDays(+1);

                //                    //get start time
                //                    DateTime Start = mdtStart.Value;

                //                    //get end time
                //                    DateTime End = mdtEnd.Value;

                //                    var directory = new DirectoryInfo("c:/process_data/");
                //                    DateTime from_date = Start;
                //                    DateTime to_date = End;

                //                    var fileList = directory.GetFiles()
                //                        .Where(fileVal => fileVal.LastWriteTime >= from_date && fileVal.LastWriteTime <= to_date)
                //                        .OrderByDescending(d => d.CreationTime)
                //                        .ToList();


                //                    filesToParse.Clear();

                //                    foreach (var fileName in /*fileEntries*/ fileList)
                //                    {
                //                        if (fileName.Name.Contains("data1"))
                //                        {
                //                            continue;
                //                        }
                //                        else if (fileName.Name.Contains("data2"))
                //                        {
                //                            continue;
                //                        }
                //                        else if (fileName.Name.Contains("data3"))
                //                        {
                //                            continue;
                //                        }
                //                        else
                //                        {
                //                            filesToParse.Add(fileName.Name);
                //                        }
                //                    }
                //                    filesToParseIndex = 0;
                //                    string value = filesToParse[filesToParseIndex];
                //                    string path = "c:/process_data/";

                //                    System.IO.StreamReader sr = new System.IO.StreamReader(path + value);


                //                    string fText = sr.ReadToEnd();



                //                    rtbData.SelectionStart = 0;  // or wherever you want to insert in this rtb
                //                    rtbData.SelectionLength = 0;

                //                    rtbData.SelectionFont = new System.Drawing.Font("Consolas", 10);
                //                    rtbData.SelectedText = fText;

                ////                    rtbData.SelectionFont = new System.Drawing.Font("Tahoma", 14);
                ////                    rtbData.SelectedText = fText;

                //                    sr.Close();
                //                }
                //                catch (Exception )
                //                {
                //                    //Logger.WriteInternalLogFile("Exception in Data view.  Ex = " + Ex.ToString());
                //                }


            }
            if (e.TabPageIndex == 2) //
            {
                //sub tabs
                //metroTabControl1


            }
            if (e.TabPageIndex == 3) //Settings Tab
            {
                //settings
                //read the settings and set the screen text boxes


                    //check static var to see if pw entry is needed
                if (PassContainer.passwordValid == false)
                {
                    Form fpw = new PasswordForm();
                    fpw.ShowDialog();
                }

                if ( (Keyboard.IsKeyDown(Key.LeftCtrl) && Keyboard.IsKeyDown(Key.T) && Keyboard.IsKeyDown(Key.R)))
                {
                 
                    //troubleshooting logic -- allow changes while running
                    if (troubleshooting == 0)
                    {
                        EnableDisableAllSettingsControls(true);
                        troubleshooting = 1;
                    }
                    else
                    {
                        EnableDisableAllSettingsControls(false);
                        troubleshooting = 0;
                    }
                }


                cbMetroSamplePeriod.Text = Properties.Settings.Default.SampleTime.ToString();

                try
                {
                    if (Properties.Settings.Default.SampleTime == 77)
                    {

                        if (cbMetroSamplePeriod.Items.Contains("M"))
                        {

                            cbMetroSamplePeriod.SelectedIndex = 6;

                        }
                        else
                        {
                            cbMetroSamplePeriod.Items.Add("M");
                            cbMetroSamplePeriod.SelectedIndex = 6;

                        }


                    }
                    else
                    {
                        cbMetroSamplePeriod.Text = Properties.Settings.Default.SampleTime.ToString();

                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error selecting sample time.  Ex = " + Ex.ToString());
                }

                    tbMetroUpscalePos.Text = Properties.Settings.Default.UpscaleRodPosition.ToString();
                    tbMetroEnergyCalPos.Text = Properties.Settings.Default.EcalRodPosition.ToString();
                    tbMetroEC1FilterPos.Text = Properties.Settings.Default.FWEC1.ToString();
                    tbMetroEC2FilterPos.Text = Properties.Settings.Default.FWEC2.ToString();
                    tbMetroEC3FilterPos.Text = Properties.Settings.Default.FWEC3.ToString();
                    tbMetroEC4FilterPos.Text = Properties.Settings.Default.FWEC4.ToString();

                    tbMetroEcalkV.Text = Properties.Settings.Default.EcalkV.ToString();
                    tbMetroEcaluA.Text = Properties.Settings.Default.EcaluA.ToString();
                    tbMetroEcalTime.Text = Properties.Settings.Default.EcalTime.ToString();


                    tbMetroEC1kV.Text = Properties.Settings.Default.EC1kV.ToString();
                    tbMetroEC1uA.Text = Properties.Settings.Default.EC1uA.ToString();
                    tbMetroEC1RunTimePercent.Text = Properties.Settings.Default.EC1RTP.ToString();
                    tbMetroEC1RunTimeSeconds.Text = Properties.Settings.Default.EC1RunTime.ToString();
                    cbMetroEC1Filter.Text = Properties.Settings.Default.EC1Filter.ToString();
                    cbMetroEC1AutoCurrent.Text = Properties.Settings.Default.EC1AC.ToString();

                    tbMetroEC2kV.Text = Properties.Settings.Default.EC2kV.ToString();
                    tbMetroEC2uA.Text = Properties.Settings.Default.EC2uA.ToString();
                    tbMetroEC2RunTimePercent.Text = Properties.Settings.Default.EC2RTP.ToString();
                    tbMetroEC2RunTimeSeconds.Text = Properties.Settings.Default.EC2RunTime.ToString();
                    cbMetroEC2Filter.Text = Properties.Settings.Default.EC2Filter.ToString();
                    cbMetroEC2AutoCurrent.Text = Properties.Settings.Default.EC2AC.ToString();

                    tbMetroEC3kV.Text = Properties.Settings.Default.EC3kV.ToString();
                    tbMetroEC3uA.Text = Properties.Settings.Default.EC3uA.ToString();
                    tbMetroEC3RunTimePercent.Text = Properties.Settings.Default.EC3RTP.ToString();
                    tbMetroEC3RunTimeSeconds.Text = Properties.Settings.Default.EC3RunTime.ToString();
                    cbMetroEC3Filter.Text = Properties.Settings.Default.EC3Filter.ToString();
                    cbMetroEC3AutoCurrent.Text = Properties.Settings.Default.EC3AC.ToString();

                    tbMetroEC4kV.Text = Properties.Settings.Default.EC4kV.ToString();
                    tbMetroEC4uA.Text = Properties.Settings.Default.EC4uA.ToString();
                    tbMetroEC4RunTimePercent.Text = Properties.Settings.Default.EC4RTP.ToString();
                    tbMetroEC4RunTimeSeconds.Text = Properties.Settings.Default.EC4RunTime.ToString();
                    cbMetroEC4Filter.Text = Properties.Settings.Default.EC4Filter.ToString();
                    cbMetroEC4AutoCurrent.Text = Properties.Settings.Default.EC4AC.ToString();


                //tbMetroFWMC.Text = Properties.Settings.Default.FWMC.ToString();
                //tbMetroFWHC.Text = Properties.Settings.Default.FWHC.ToString();
                //tbMetroDMC.Text = Properties.Settings.Default.DMC.ToString();
                //tbMetroDHC.Text = Properties.Settings.Default.DHC.ToString();
                //tbMetroNozzleMC.Text = Properties.Settings.Default.NozzleMC.ToString();
                //tbMetroNozzleHC.Text = Properties.Settings.Default.NozzleHC.ToString();
                //tbMetroTapeMC.Text = Properties.Settings.Default.TapeMC.ToString();
                //tbMetroTapeHC.Text = Properties.Settings.Default.TapeHC.ToString();

                tbMetroMotorComPort.Text = Properties.Settings.Default.MotorComPort.ToString();
                    tbMetroWindComPort.Text = Properties.Settings.Default.WindComPort.ToString();
                    tbMetroInletHeaterRH.Text = Properties.Settings.Default.InletHeater.ToString();

                    tbMetroUpscaleCr.Text = Properties.Settings.Default.UpscaleCr.ToString();
                    tbMetroUpscalePb.Text = Properties.Settings.Default.UpscalePb.ToString();
                    tbMetroUpscaleCd.Text = Properties.Settings.Default.UpscaleCd.ToString();
                tbMetroUpscaleEC4.Text = Properties.Settings.Default.UpscaleEC4.ToString();
                    tbMetroNb.Text = Properties.Settings.Default.Nb.ToString();
                    tbMetroNbAlarmPercent.Text = Properties.Settings.Default.NbAlarmPercent.ToString();
                    tbMetroUpscaleAlarmPercent.Text = Properties.Settings.Default.UpscaleAlarmPercent.ToString();
                    cbMetroFlowControl.Text = Properties.Settings.Default.FlowControl.ToString();
                    cbMetroFlowSum.Text = Properties.Settings.Default.FlowSum.ToString();
                    tbMetroModbusComPort.Text = Properties.Settings.Default.ModbusComPort.ToString();
                    //default enable / disable button to 'enable' everything only if stopped

                    mbSettingsSave.Enabled = false;


                if (troubleshooting == 0)
                {
                    if (mbRun.Text == "Stop")
                    {
                        mbEnableDisableChanges.Text = "Enable Changes";
                        mbEnableDisableChanges.Enabled = false;
                    }
                    else if (mbRun.Text == "Run")
                    {
                        mbEnableDisableChanges.Text = "Enable Changes";

                        //check the passwordValid
                        if (PassContainer.passwordValid == true)
                        {
                            mbEnableDisableChanges.Enabled = true;
                        }

                    }
                }
                //default to enable false:

                EnableDisableAllMaintenanceControls(false);
            }
            //throw new NotImplementedException();



            if (e.TabPageIndex == 4)  // calibration tab
            {

                if (PassContainer.passwordValid == false)
                {
                    Form fpw = new PasswordForm();
                    fpw.ShowDialog();
                }



                //disable all controls

                metroToggle1.Enabled = false;
                metroToggle2.Enabled = false;
                metroToggleLeakCheck.Enabled = false;
                metroToggleFlowCal.Enabled = false;
                mbPumpOn.Enabled = false;
                rbMetro150.Enabled = false;
                rbMetro167.Enabled = false;
                rbMetro184.Enabled = false;
                bMetroEnterDataButton.Enabled = false;

                if (mbRun.Text == "Stop")
                {
                    mbEnableChangesCalFlow.Text = "Enable Changes";
                    mbEnableChangesCalFlow.Enabled = false;

                }
                else if (mbRun.Text == "Run")
                {
                    mbEnableChangesCalFlow.Text = "Enable Changes";

                    //check the passwordValid
                    if (PassContainer.passwordValid == true)
                    {
                        mbEnableChangesCalFlow.Enabled = true;
                    }

                }







                /*
                if (mbRun.Text == "Run" )
                {
                    if (PassContainer.passwordValid == true)
                    {
                        mbEnableChangesCalibrationFlow.Enabled = true;
                    }
                }
                else
                {
                    mbEnableChangesCalibrationFlow.Enabled = false;
                    metroToggle1.Enabled = false;
                    metroToggle2.Enabled = false;
                    metroToggleLeakCheck.Enabled = false;
                    metroToggleFlowCal.Enabled = false;
                    mbPumpOn.Enabled = false;
                    rbMetro150.Enabled = false;
                    rbMetro167.Enabled = false;
                    rbMetro184.Enabled = false;
                    bMetroEnterDataButton.Enabled = false;


                }
                */
                //}
                // controls are enabled manually via the Enable Changes button but ony if STOPPED
                //else
                //{
                //    //enable all controls
                //    metroToggle1.Enabled = true;
                //    metroToggle2.Enabled = true;
                //    metroToggle5.Enabled = true;
                //    metroToggleFlowCal.Enabled = true;
                //    mbPumpOn.Enabled = true;
                //    rbMetro150.Enabled = true;
                //    rbMetro167.Enabled = true;
                //    rbMetro184.Enabled = true;
                //    bMetroEnterDataButton.Enabled = true;
                //}

            }
            if (e.TabPageIndex == 5) // maintenance
            {

                if (PassContainer.passwordValid == false)
                {
                    Form fpw = new PasswordForm();
                    fpw.ShowDialog();
                }


                //mtbKeyPress.Text = "";  //now read in the key press to enable maint functions

                if (mbRun.Text == "Stop")  //system is Running!
                {
                    EnableDisableAllMaintenanceControls(false);


                }
                else //system is stopped
                {

                    if (PassContainer.passwordValid == true)
                    {
                        EnableDisableAllMaintenanceControls(true);
                    }


                }

            }
            if(e.TabPageIndex==6)
            {

                //adapt launch

                //use web-browser control(fully contained in program)
                //integration requires write to registry to force the integrated webbrowser tool to be version 11, not 7.

            //normal
                //webBrowser1.ScriptErrorsSuppressed = true;
                //webBrowser1.Navigate("http://localhost:8000/view/");


                //launch chrome, using the correct URL:
                //add launch in chrome button:
                    Process.Start("chrome", @"http://localhost:8000/view/");

            }
        }
























        /// <summary>
        /// sub menu
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>

        private void metroTabControl1_Selected(object sender, TabControlEventArgs e)
        {
            
            if (e.TabPageIndex == 0) //IO
            {

            }
            if (e.TabPageIndex == 1) //Upscale
            {
                //Load page
              int retVal = ProcessUpscaleFiles();
                //if (retVal == PASS)
                //{
                //    Logger.WriteLogFile()
                //}

            }
            
        }


            /// <summary>
            /// Time consuming operations go here </br>
            /// i.e. Database operations,Reporting,
            /// in this case ramp logic to handle the increase in tube voltage and current 
            /// 
            /// </summary>
            /// <param name="sender"></param>
            /// <param name="e"></param>
            /// 
            void m_oWorkerRamp_DoWork(object sender, DoWorkEventArgs e)
            {

            /*
            rampLockObj = new Object();
            rampLockObj = 1;


            rampErrorIHigh = 0;
            rampErrorILow = 0;
            rampErrorVHigh = 0;
            rampErrorVLow = 0;


            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;



            //calls:   onRampTimedEvent
            LinearRampValuesCurrent = AcquisitionControl.GetRampCurrentValues();
            LinearRampValuesVoltage = AcquisitionControl.GetRampVoltageValues();
            rampIndex = 0;
            checkLastValueCounter = 0;


            var RT = StartRampTimer();

            do
            {
                Thread.Sleep(10);  //keep this thread alive the onRamptimedEvent will be called against it.


            } while (m_oWorkerRamp.CancellationPending != true);

            m_oWorkerRamp.ReportProgress(100);
            RT.Enabled = false;
            rampErrorIHigh = 0;
            rampErrorILow = 0;
            rampErrorVHigh = 0;
            rampErrorVLow = 0;
            */

            rampLockObj = new Object();
            rampLockObj = 1;



            if (rampActive == 0)
            {
                rampActive = 1;

                //init ramp control variables:
                rampIndex = 0;
                checkLastValueCounter = 0;

                rampErrorIHigh = 0;
                rampErrorILow = 0;
                rampErrorVHigh = 0;
                rampErrorVLow = 0;
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;



                //calls:   onRampTimedEvent
                LinearRampValuesCurrent = AcquisitionControl.GetRampCurrentValues();
                LinearRampValuesVoltage = AcquisitionControl.GetRampVoltageValues();


                //var RT = StartRampTimer();
                //System.Timers.Timer RT.Enabled = false ;
                //RT = StartRampTimer();
                //int rampComplete = 0;
                do
                {

                    OnRampEvent();
                    Thread.Sleep(1000);  


                } while (m_oWorkerRamp.CancellationPending != true);

                rampActive = 0;
                //RT.Enabled = false;

            }
            else
            {
                Logger.WriteInternalLogFile("Skip ramp thread.");
            }
            m_oWorkerRamp.ReportProgress(100);
            rampErrorIHigh = 0;
            rampErrorILow = 0;
            rampErrorVHigh = 0;
            rampErrorVLow = 0;





        }


        List<string> AdjustDataForDisplay(List<string> outputFileData)
        {
            int index = 0;


            List<string> returnList = new List<string>();


            int endOfElementData = 0;
            foreach (string element in outputFileData)
            {
                if (element.Contains("*****"))
                {
                    break;
                }
                endOfElementData++;
            }


            try
            {
                string temp = string.Empty;

                foreach (string item in outputFileData)
                {
                    if (index == 0)
                    {
                        //start samp
                        index++;
                        //remove commas
                        string temp1 = item.Replace(",", "");

                        string temp2 = temp1.TrimStart();
                        temp = temp2 + "\r\n";
                        returnList.Add(temp);


                    }
                    else if (index == 1)  //ec1 start time
                    {
                        //title
                        index++;
                        //call function to substitute unc with sigma
                        //temp = AdjustTitleDisplayData(item);
                        //temp = temp + "\r\n";
                        //returnList.Add(temp);

                        //string temp1 = item.Replace(",", "");
                        //temp = temp1 + "\r\n";
                        temp = "\r\n";
                        returnList.Add(temp);

                    }
                    else if (index == 2)
                    {
                        index++;
                        string temptitles = AdjustTitleDisplayData(item);
                        temptitles = temptitles + "\r\n";
                        returnList.Add(temptitles);

                    }
                    else if (index <= endOfElementData)
                    {
                        string tempstr = string.Empty;

                        index++;
                        //split index
                        //break into string []
                        //tryparse.todouble string[2-16]

                        //create a new array of the string parts string:

                        string[] eldata = item.Split(',');
                        int items = eldata.Count() - 2;

                        for (int i = 0; i < items; i++)
                        {
                            if (i == 0)
                            {
                                //element
                                //returnList.Add(eldata[i]);
                                tempstr = tempstr + eldata[i] + "\t";
                            }
                            else if (i == 1)
                            {
                                //returnList.Add(eldata[i]);
                                tempstr = tempstr + eldata[i] + "\t";
                            }
                            else if (i < items)
                            {
                                double result = 0;
                                string resultstr = string.Empty;
                                bool ret = double.TryParse(eldata[i], out result);
                                if (ret == true)
                                {
                                    if (result < 100000 && result > -100000)
                                    {
                                        //{ 0,-5}
                                        //{ 1,12:F6}
                                        //resultstr = result.ToString("    0.00");
                                        resultstr = result.ToString("00000.000");
                                    }
                                    else
                                    {//scientific notation needed
                                        resultstr = result.ToString("0.###E+000");

                                    }
                                }
                                else
                                {
                                    result = -1.0;
                                    resultstr = result.ToString("00000.000");
                                }
                                //returnList.Add(resultstr);
                                tempstr = tempstr + resultstr + "\t";
                            }
                        }
                        tempstr = tempstr + "\r\n";
                        returnList.Add(tempstr);
                    }
                    else
                    { //process data

                        index++;

                        temp = AdjustOperationalDisplayData(item);
                        temp = temp + "\r\n";

                        returnList.Add(temp);
                    }

                }

                return returnList;
            }
            catch (Exception Ex)
            {

                return returnList;
            }
        }


        string AdjustOperationalDisplayData(string input)
        {
            string adj1 = String.Empty;
            string resultstr = string.Empty;
            try
            {



                adj1 = input.Replace("=", "");
                //split all items by comma
                string[] adj5 = adj1.Split(',');

                List<string> opData = new List<string>();

                int maxLength;

                string itemTitle = adj5[1];
                string itemData = adj5[2];

                maxLength = 36;
                itemTitle = itemTitle.PadRight(maxLength);

                opData.Add(itemTitle);

                double result = 0;

                if (itemTitle.Contains("StartTime"))
                {
                    return itemTitle + "\t" + adj5[2];

                }
                else if ( (itemTitle.Contains("Start Sample Time"))  || (itemTitle.Contains("Sample Start Time")) )
                {
                    return itemTitle + "\t" + adj5[2];
                }
                else if( itemTitle.Contains("Sample Time (min)"))
                {
                    return itemTitle + "\t" + adj5[2];
                }
                else if (itemTitle.Contains("Alarm"))
                {
                    string localItem = adj5[2].TrimStart();
                    return itemTitle + "\t" + localItem;
                }
                else if (itemTitle.Contains("Pump Start Time"))
                {
                    return itemTitle + "\t" + adj5[2];
                }
                else if (itemTitle.Contains("XC version"))
                {
                    return itemTitle + "\t" + adj5[2];
                }


                else
                {
                    bool ret = double.TryParse(adj5[2], out result);
                    if (ret == true)
                    {
                        if (result < 100000 && result > -100000)
                        {
                            resultstr = result.ToString("00000.00");
                        }
                        else
                        {//scientific notation needed
                            resultstr = result.ToString("0.###E+00");

                        }
                    }
                    else
                    {
                        result = -1.0;
                        resultstr = result.ToString("00000.00");
                    }

                    opData.Add(resultstr);
                }
                //item = item.substring(0, Math.min(s.length(), 10));
                //string result = new string(item.Take(maxLength).ToArray());
                //if (item.Contains("At Sym") || item.Contains("At No"))
                //{
                //    titlesTrunc.Add(result);                    
                //    continue;
                //}
                //else
                //{
                //    result = result.PadRight(maxLength);
                //    titlesTrunc.Add(result);
                //}

                string opDataString = String.Empty;


                foreach (string item in opData)
                {
                    opDataString = opDataString + item + "\t";
                }
                //opDataString = opDataString;

                //                string adj6 = adj4.Replace(",", "\t");
                //
                //string adj7 = adj6.Replace("*****", "");
                return opDataString;

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error in Adjusting Operation Data() Error = " + Ex.ToString());
                return adj1;
            }
        }


        string AdjustTitleDisplayData(string input)
        {
            string adj1 = String.Empty;
            try
            {
                adj1 = input.Replace("Unc", "σ");
                ////                int locn1 = adj1.IndexOf("\r\n");
                ////                int locn2 = adj1.IndexOf("\r\n", locn1 + 2);
                ////                string adj2 = adj1.Substring(0, locn2 + 2); //first two lines
                ////                string adj3 = adj1.Substring(locn2 + 2); //complete string after first two lines
                //string adj2 = adj1.Replace()
                string adj3 = adj1.Replace(",,,", "");
                //string adj4 = adj3.Replace("Bl","Blank");
                //string adj4a = adj3.Replace("ass", "");
                string adj4b = adj3.Replace("alue", "");
                string adj4c = adj4b.Replace("actor", "");
                string adj4d = adj4c.Replace("orr", "");
                string adj4e = adj4d;//.Replace("onc", "");

                //split all items by comma
                string[] adj5 = adj4e.Split(',');
                List<string> titlesTrunc = new List<string>();

                foreach (string item in adj5)
                {
                    int maxLength = 13;
                    //item = item.substring(0, Math.min(s.length(), 10));
                    string result = new string(item.Take(maxLength).ToArray());
                    if (item.Contains("At Sym") || item.Contains("At No"))
                    {
                        titlesTrunc.Add(result);
                        continue;
                    }
                    else if (item.Contains("Concentration σ"))
                    {
                        string localitem = "Conc σ";
                        result = new string(localitem.PadRight(maxLength).ToArray());
                        titlesTrunc.Add(result);
                        continue;

                    }
                    else if (item.Contains("Concentra"))
                    {
                        string localitem = "Conc";
                        result = new string(localitem.PadRight(maxLength).ToArray());
                        titlesTrunc.Add(result);
                        continue;


                    }
                    else
                    {
                        result = result.PadRight(maxLength);
                        titlesTrunc.Add(result);
                    }
                }

                string titleString = String.Empty;
                foreach (string item in titlesTrunc)
                {
                    //if (item.Substring(0, 1).Contains(" "))
                    //{
                    //    string tempitem = item.Substring(1, item.Length);
                    //    titleString = titleString + tempitem + "\t";
                    //}
                    //else
                    //{
                    titleString = titleString + item.TrimStart() + "\t";
                    //}
                }
                titleString = titleString + "\r\n";

                //                string adj6 = adj4.Replace(",", "\t");
                //
                //string adj7 = adj6.Replace("*****", "");
                return titleString;

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error in Adjusting Display Data() Error = " + Ex.ToString());
                return adj1;
            }
        }
















        /// <summary>
        /// Notification is performed here to the progress bar,
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        /// 1
        void m_oWorkerRamp_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            string[] values = new string[4];

            //int countUp;
            //Here you play with the main UI thread
            //for testing add a progress bar:
            values = (string[])e.UserState;

            // make sure the data is there, via this try, otherwise you shouldn't unpack
            try
            {


                //write to GUI:
                if (values != null)
                {
                    double kVolt = Convert.ToDouble(values[0]);

                    kVolt = kVolt * 50.0 / 10.0;

                    //kVolt = Math.Round(kVolt, 2, MidpointRounding.AwayFromZero);


                    try
                    {
                        UpdatekVMessage(kVolt.ToString("F2"));
                    }
                    catch
                    {
                        //Logger.WriteErrorFile("Error: displaying read hvps voltage");
                        Logger.WriteInternalLogFile("Exception displaying read hvps voltage");

                    }
                }

                if (values != null)
                {

                    double uAmp = Convert.ToDouble(values[1]);
                    uAmp = uAmp * 2000.0 / 10.0;
                    //uAmp = Math.Round(uAmp, 2, MidpointRounding.AwayFromZero);

                    try
                    {
                        UpdateuAMessage(uAmp.ToString("F2"));
                    }
                    catch
                    {
                        //Logger.WriteErrorFile("Error: displaying hvps current");
                        Logger.WriteInternalLogFile("Exception: displaying hvps current");

                    }
                }

                //todo progress bars

                UpdateXrayProgressBar(e.ProgressPercentage);
                //mpb  MaintenanceXrayRamp.Value = e.ProgressPercentage;

                //countUp = Convert.ToInt32(values[3]);
                //if (countUp == 1)
                //{
                    //todo
                    //ProgressPercentage.Text = "Ramp Execution:  " + ProgressBar1.Value.ToString() + "%";
                //}
                //else
                //{
                    //todo
                    //int progressValue = 100 - ProgressBar1.Value;
                    //todo
                    //ProgressPercentage.Text = "Ramp Execution:  " + progressValue + "%";
                //}

            }
            catch (Exception ex)
            {
                string msg;
                msg = "Error: Ramp progress changed. Ex = " + ex.ToString();
                //Logger.WriteErrorFile(msg);
                Logger.WriteInternalLogFile(msg);
            }

        }

        /// <summary>
        /// On completed do the appropriate task
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void m_oWorkerRamp_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {

           
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            ////write the actual v and i:

            Thread.Sleep(500);
            double presentVupdate;
            double presentIupdate;
            double presentV;
            double presentI;
            delayTime = 0;
            try
            {
 
                do
                {
                    presentVupdate=0.0;
                    presentIupdate=0.0;

                    presentV = ReadInputVoltage();
                    presentVupdate = (presentV * 50.0 / 10.0);

                    presentI = ReadInputCurrent();
                    presentIupdate = (presentI * 2000.0 / 10.0);

                    if(presentVupdate>=20)
                    {
                        break;
                    }
                    if(presentIupdate>=750)
                    {
                        break;
                    }


                    if (presentVupdate < 5.0 && presentIupdate < 100.0)
                    {

                        AcquisitionControl.InterlockOpen(this);
                        xrayCommandActive = 0;
                        break;

                    }
                    else
                    {
                        xrayCommandActive = 1;  // xrays are on
                    }

                    do
                    {
                        Thread.Sleep(10);
                        delayTime++;
                    }
                    while (delayTime % 100 != 0);
                    //Thread.Sleep(250);
                    //presentV = readInputVoltage;
                    //presentV = presentV * 50.0 / 10.0;
                               //        //presentI = readInputCurrent;
            //        //presentI = presentI * 2000.0 / 10.0;



                } while (delayTime <=300);


                //add check of the command voltage:
                //if(`)
                //xrayRampCommandActive = 0;
                xrayRampCommandActive = 0;







            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Ex Ramp thread.  Ex = " + Ex.ToString());               
            }

        }




        /// <summary>
        /// Reads the data and saves it for other threads to read
        /// </summary>
        /// <returns></returns>
        private double ReadInputVoltage()
        {
            string exString="";
            double avgVoltage = 0.0;
            int readOk = 0;
            int counter = 0;
            double sum = 0.0;
            do
            {
                try
                {

#if TURNON_NIHARDWARE
                    reader = new AnalogMultiChannelReader(InputVoltage.Stream);


                    InputVoltageData = reader.ReadWaveform(2);

                    readOk = 1;

                    sum = 0.0;
                    string stringValue;


                    // Iterate over channels
                    int NumberOfReads = 0;
                    foreach (AnalogWaveform<double> waveform in InputVoltageData)
                    {
                        for (int sample = 0; sample < waveform.Samples.Count; ++sample)
                        {
                            sum = sum + waveform.Samples[sample].Value;
                            NumberOfReads++;
                            stringValue = waveform.Samples[sample].Value.ToString();


                        }
                    }
                    if (NumberOfReads > 0)
                    {
                        avgVoltage = sum / NumberOfReads;
                        break;
                    }
                    //dataFile2.WriteLine(" *** AVG=, {0}", avg);
#else
                    avgVoltage = 2.3456;
                    readOk = 1;
#endif

                }
                catch (Exception Ex)
                {
                    exString = Ex.ToString();
                    counter += 1;
                    Thread.Sleep(50);  //this delay is here in place of log file writes.
                                        //             
                }
            } while (readOk == 0 && counter < 50 /*&& sum != 0*/);

            if (counter >= 50)
            {

                string msg;
                Logger.WriteInternalLogFile("Exception in read hvps kV feedback. Count = "+counter.ToString()+"   Ex = " + exString);

                msg = "timer kV mon read Error.";
                Logger.WriteInternalLogFile(msg);
            }




            return avgVoltage;


        }



        //
        //
        /// <summary>
        ///  sets the ramp callback and timing on background worker thread 
        /// </summary>
        private System.Timers.Timer StartRampTimer()
        {
            var RampTimer = new System.Timers.Timer(1000); //was 500

            // Hook up the Elapsed event for the timer.

            //disabled
            //RampTimer.Elapsed += new ElapsedEventHandler(onRampTimedEvent);

            RampTimer.Enabled = true;
            return RampTimer;




        }





        /// <summary>
        /// Time consuming operations go here </br>
        /// i.e. Database operations,Reporting
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void m_oWorkerPump_DoWork(object sender, DoWorkEventArgs e)
        {
            try
            {
                pumpLockObj = new Object();
                pumpLockObj = 1;

                //calls:   onPumpTimedEvent
                var PT = StartPumpTimer();

                do
                {
                    Thread.Sleep(1);  //keep this thread alive the onPumpTimedEvent will be called against it.

                } while (m_oWorkerPump.CancellationPending != true);

                //Logger.WriteInternalLogFile("Pump Cancellation pending received 0");
                //Logger.WriteInternalLogFile("Pump Intention = " + PumpIntention.ToString());


                PT.Enabled = false;  

                                            


                //Logger.WriteInternalLogFile("Cancellation pending received 1");
                try
                {  //simple way to handle case where hardware is not installed (try catch)
                    //Logger.WriteInternalLogFile("Pump Cancellation pending received 2");
                    AnalogSingleChannelWriter writerOffEnd = new AnalogSingleChannelWriter(PumpOutput.Stream);
                    writerOffEnd.WriteSingleSample(true, 0.000);
                }
                catch (Exception Ex)
                {
                    //Logger.WriteInternalLogFile("Pump Cancellation pending received 3");

                    Logger.WriteInternalLogFile("Error Shut off pump.  Ex = " + Ex.ToString());
                }

                try
                {  
                    //Logger.WriteInternalLogFile("Pump Cancellation pending received 4");
                    AnalogSingleChannelWriter writerOffEnd2 = new AnalogSingleChannelWriter(PumpOutput.Stream);
                    writerOffEnd2.WriteSingleSample(true, 0.000);
                }
                catch (Exception Ex)
                {
                    //second attempt
                    //Logger.WriteInternalLogFile("Pump Cancellation pending received 5");
                    Logger.WriteErrorFile("Error: Shut off pump. Ex = " + Ex.ToString());
                    Logger.WriteInternalLogFile("Error Shut off pump. Ex = " + Ex.ToString());
                }




            }
            catch (Exception Ex)
            {
                //Logger.WriteInternalLogFile("Pump Cancellation pending received 6");
                Logger.WriteInternalLogFile("Ex in pump thread  (do work) = " + Ex.ToString());
            }
        }

        /// <summary>
        /// Notification is performed here to the GUI,
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void m_oWorkerPump_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            string[] pumpvalues = new string[10];

            double errorValue = 0.0;
            double flowValue = 0.0;
            double pumpProcessFlowValue = 0.0;
            double outputValue = 0.0;

            double flow25 = 0.0;
            double flowStd = 0.0;
            double flowAct = 0.0;
            double uflowActAmb = 0.0;

            // make sure the data is there, via this try otherwise you shouldn't unpack
            // display tape pressure and ambient pressure

            try
            {



                pumpvalues = (string[])e.UserState;

                errorValue = Convert.ToDouble(pumpvalues[0]);
                //errorValue = Math.Round(errorValue, 3, MidpointRounding.AwayFromZero);
                flowValue = Convert.ToDouble(pumpvalues[1]);
                //flowValue = Math.Round(flowValue, 3, MidpointRounding.AwayFromZero);
                pumpProcessFlowValue = Convert.ToDouble(pumpvalues[2]);
                //pumpProcessFlowValue = Math.Round(pumpProcessFlowValue, 3, MidpointRounding.AwayFromZero);
                outputValue = Convert.ToDouble(pumpvalues[3]);
                //outputValue = Math.Round(outputValue, 3, MidpointRounding.AwayFromZero);

                flow25 = Convert.ToDouble(pumpvalues[4]);
                flow25Static = Math.Round(flow25, 2, MidpointRounding.AwayFromZero);

                flowAct = Convert.ToDouble(pumpvalues[5]);
                flowActualStatic = Math.Round(flowAct, 2, MidpointRounding.AwayFromZero);

                flowStd = Convert.ToDouble(pumpvalues[6]);
                flowStandardStatic = Math.Round(flowStd, 2, MidpointRounding.AwayFromZero);

                uflowActAmb = Convert.ToDouble(pumpvalues[7]);

                processPumpErrorValue(errorValue.ToString("F3"));
                processFlowValue(flowValue.ToString("F2"));


                string displayString = CalcPumpRunPercent(outputValue.ToString("F2"));

                //processOutputValue(outputValue.ToString("F2"));
                processOutputValue(displayString);




                processPumpFlowValue(pumpProcessFlowValue.ToString("F2"));

                processFlow25(flow25.ToString("F2"));
                processFlowAct(flowAct.ToString("F2"));
                processFlowStd(flowStd.ToString("F2"));

                processFlow25System(flow25.ToString("F2"));
                processFlowActSystem(flowAct.ToString("F2"));
                processFlowStdSystem(flowStd.ToString("F2"));



                processuFlowActAmb(uflowActAmb.ToString("F2"));

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in update pump data.  Ex=  " + Ex.ToString());
            }

        }


        string CalcPumpRunPercent(string svalue)
        {

            double value = 0.0;
            double percent = 0.0;

            string outputstring = string.Empty;

            try
            {
                bool result = Double.TryParse(svalue, out value);
                if (result == true)
                {
                    percent = (value / 5.0) * 100;
                }
                else
                {
                    percent = -1;
                }

                int ipercent = (int)percent;

                outputstring = String.Format("{0:000}", ipercent);
                return outputstring;
            }
            catch (Exception Ex)
            {
                return String.Format("{0:000}", -1); 
            }


        }



        /// <summary>
        /// On completed do the appropriate task
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void m_oWorkerPump_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            try
            {
                //Logger.WriteInternalLogFile("Pump worker thread completed (Routine 1).");
                try
                {
                    //Logger.WriteInternalLogFile("Pump worker thread completed (Routine 2).");
                    AnalogSingleChannelWriter writerOffCompletion = new AnalogSingleChannelWriter(PumpOutput.Stream);
                    writerOffCompletion.WriteSingleSample(true, 0.00);

                    AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                    //Logger.WriteInternalLogFile("Pump worker thread completed (Routine 4).");

                    double flowVol = AcquisitionControl.GetFlowVolume();
                    Logger.WriteLogFile("flow Vol = " + flowVol.ToString("F3"));

                    //Logger.WriteInternalLogFile("Pump worker thread completed (Routine 5).");
                    pumpStartCounter = 0;

                    //update modbus
                    flow25Static = Math.Round(0.0, 2, MidpointRounding.AwayFromZero);
                    flowActualStatic = Math.Round(0.0, 2, MidpointRounding.AwayFromZero);
                    flowStandardStatic = Math.Round(0.0, 2, MidpointRounding.AwayFromZero);
                    //Update GUI
                    processFlow25("0.00");
                    processFlowAct("0.00");
                    processFlowStd("0.00");
                    processFlow25System("0.00");
                    processFlowActSystem("0.00");
                    processFlowStdSystem("0.00");

                    

                    processOutputValue("0.00");
                    processPumpErrorValue("0.000");


                    processuFlowActAmb("0.00");



                }
                catch (Exception Ex)
                {
                    //Logger.WriteInternalLogFile("Pump worker thread completed (Routine 3).");
                    //Logger.WriteInternalLogFile("Error:  Pump Thread Completed.  Ex =  " + Ex.ToString());
                    Logger.WriteInternalLogFile("Error:  Pump Thread Completed.  Ex =  " + Ex.ToString());

                }


                finally
                {
                    try
                    {
                        AnalogSingleChannelWriter writerOffCompletion2 = new AnalogSingleChannelWriter(PumpOutputOff.Stream);
                        writerOffCompletion2.WriteSingleSample(true, 0.00);
                    }
                    catch (Exception Ex)
                    {
                        Logger.WriteInternalLogFile("Error turning pump off.  Error = "+Ex.ToString());
                    }
                }
            }
            catch(Exception Ex2)
            {
                try
                {
                    AnalogSingleChannelWriter writerOffCompletion2 = new AnalogSingleChannelWriter(PumpOutputOff.Stream);
                    writerOffCompletion2.WriteSingleSample(true, 0.00);
                    Logger.WriteInternalLogFile("Error: in pump off.  Ex = " + Ex2.ToString());
                    Logger.WriteLogFile("Error: in pump off.  Ex = " + Ex2.ToString());
                }
                catch (Exception Ex3)
                {
                    Logger.WriteInternalLogFile("Error: pump off.  Ex = "+ Ex3.ToString());
                    Logger.WriteLogFile("Error: pump off.  Ex = " + Ex3.ToString());
                }


            }

        }

        //********** start manual upscale
        void m_oWorkerUpscale_DoWork(object sender, DoWorkEventArgs e)
        {

            try
            {

                lockUpscaleObj = new Object();
                lockUpscaleObj = 200;
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                //initialize the acquisition -- then keep the thread alive

                //onUpscaleTimedEvent will be called after start timer is initialized every 1 second
                AcquisitionControl.SetState(200);              
 
                AcquisitionControl.SetCounter(0);

                //get access to xrsfp
                _cMTFFPX myacq_xrsfp = new cMTFFPX();

                //get connected if not connected.
                var ret21 = myacq_xrsfp.Connect_MCA;

                myacq_xrsfp.AutoForm_Show = false;
                myacq_xrsfp.SpectraX_Show = false;


                var AT = StartUpscaleTimer();

                //keep this thread running
                do
                {

                    Thread.Sleep(10);  //keep this thread alive the onAcqtimedevent will be called against it at 1 second intervals.

                } while (BackgroundManager.m_oWorkerUpscale.CancellationPending != true);
                AT.Enabled = false;

                //Thread.Sleep(2000);

                //add ramp to zero here:
                //check ramp feedback and ramp to zero if needed:
                //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                //m_oWorkerRamp.CancelAsync();
                //Thread.Sleep(1000);


                //read presentV (actual 'kV') from NI
                //double presentV = 0.0;
                //presentV = readInputVoltage;
                //presentV = presentV * 50.0 / 10.0;

                //ActualV.Text = presentV.ToString();
                //presentV = Math.Round(presentV, 2, MidpointRounding.AwayFromZero);


                //read presentI (actual i) from NI
                //double presentI = 0.0;
                //presentI = readInputCurrent;
                //presentI = presentI * 2000.0 / 10.0;
                //presentI = Math.Round(presentI, 2, MidpointRounding.AwayFromZero);


                //if (presentV < 0)
                //    presentV = 0.0;
                //if (presentI < 0)
                //    presentI = 0.0;

                //Logger.WriteLogFile("sampled V or I above off zero, ramping down at acquisition cancel.");

                //int returnVal = AcquisitionControl.RampXrays(presentV, presentI, 0.0, 0.0, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);

                if (InvokeRequired)
                {
                    mbRunManualAcq.Invoke(new MethodInvoker(delegate { mbRunManualAcq.Text = "Run Acquisition"; }));
                }
                else
                {
                    mbRunManualAcq.Text = "Run Acquisition";
                }

                if (InvokeRequired)
                {
                    mrbEcal.Invoke(new MethodInvoker(delegate { mrbEcal.Enabled = true; }));
                }
                else
                {
                    mrbEcal.Enabled = true;
                }
                if (InvokeRequired)
                {
                    mrbUpscale.Invoke(new MethodInvoker(delegate { mrbUpscale.Enabled = true; }));
                }
                else
                {
                    mrbUpscale.Enabled = true;
                }
                if (InvokeRequired)
                {
                    mrbManual.Invoke(new MethodInvoker(delegate { mrbManual.Enabled = true; }));
                }
                else
                {
                    mrbManual.Enabled = true;
                }



            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("**** Ex in Upscale thread = " + Ex.ToString());
            }


        }

        //********** end manual upscale




        // *** start leak check

        //m_oLeakCheck_DoWork
        /// <summary>
        /// Create the thread and start the timer that calls on the thread
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void m_oLeakCheck_DoWork(object sender, DoWorkEventArgs e)
        {

            leakCheckActive = 1;
            try
            {

                lockLeakCheckObj = new Object();
                lockLeakCheckObj = 17;
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                //init state machine
                AcquisitionControl.SetState(400);    //400-499 = leak check state machine
                AcquisitionControl.SetCounter(0);

                var LC = StartLeakCheckTimer();

                //keep this thread running
                do
                {
                    Thread.Sleep(10);  //keep this thread alive the onAcqtimedevent will be called against it at 1 second intervals.
                } while (BackgroundManager.m_oLeakCheck.CancellationPending != true);
                LC.Enabled = false;
                leakCheckActive = 0;


            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Ex in Leak Check thread = " + Ex.ToString());
                if (BackgroundManager.m_oLeakCheck.IsBusy)
                {
                    BackgroundManager.m_oLeakCheck.CancelAsync();
                }
                leakCheckActive = 0;
            }


        }

        // *** end leak check



        // *** start tube seasoning


        //m_oWrkerTubeSeasoning_DoWork
        /// <summary>
        /// Create the thread and start the timer that calls on the thread
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void m_oWorkerTubeSeasoning_DoWork(object sender, DoWorkEventArgs e)
        {


            try
            {

                lockTubeSeasoningObj = new Object();
                lockTubeSeasoningObj = 19;
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                //initialize the acquisition -- then keep the thread alive

                //onUpscaleTimedEvent will be called after start timer is initialized every 1 second
                //init state machine
                AcquisitionControl.SetStateTS(500);    //500-599 = tube seasoning state machine
                AcquisitionControl.SetCounterTS(0);


                var TS = StartTubeSeasoningTimer();

                //keep this thread running
                do
                {
                    Thread.Sleep(1);  //keep this thread alive the onAcqtimedevent will be called against it at 1 second intervals.

                } while (BackgroundManager.m_oWorkerTubeSeasoning.CancellationPending != true);
                TS.Enabled = false;
                //RampXraysToZero();
                manualTubeSeasoning = 0;
                manualWarmUp = 0;
                //TubeSeasoningTime = 0;



            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Ex in Tube Seasoning thread = " + Ex.ToString());
            }


        }


        // *** start five minute


        //m_oWrkerTubeSeasoning_DoWork
        /// <summary>
        /// Create the thread and start the timer that calls on the thread
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void m_oWorkerFiveMinute_DoWork(object sender, DoWorkEventArgs e)
        {


            try
            {

                lockFiveMinuteObj = new Object();
                lockFiveMinuteObj = 19.0552;
                //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                fiveMinuteCounter = 0;

                //could do the work here
                //but using a timer to time seconds in a background worker thread also is reasonable
                var FM = StartFiveMinuteTimer();

                //keep this thread running
                do
                {
                    Thread.Sleep(10);  //keep this thread alive the onAcqtimedevent will be called against it at 1 second intervals.
                    if(fiveMinuteCounter>195)  //changed to three minutes + 15 seconds to cancel
                    {
                        BackgroundManager.m_oWorkerFiveMinute.CancelAsync();
                    }
                } while (BackgroundManager.m_oWorkerFiveMinute.CancellationPending != true);
                FM.Enabled = false;



            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Ex in Five Minute thread = " + Ex.ToString());
            }


        }








        //*** start manual acquisition
        void m_oWorkerManualAcq_DoWork(object sender, DoWorkEventArgs e)
        {

            try
            {

                lockManualAcqObj = new Object();
                lockManualAcqObj = 3;
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                //initialize the acquisition -- then keep the thread alive

                //onUpscaleTimedEvent will be called after start timer is initialized every 1 second
                AcquisitionControl.SetState(300);    //init the modbus regs
                SaveButton = 0;
                AcquisitionControl.SetCounter(0);

                //get access to xrsfp
                _cMTFFPX myacq_xrsfp = new cMTFFPX();

                //get connected if not connected.
                var ret21 = myacq_xrsfp.Connect_MCA;

                myacq_xrsfp.AutoForm_Show = false;
                myacq_xrsfp.SpectraX_Show = false;

                returnManualFWHome = FAIL;

                var AT = StartManualAcqTimer();

                

                //keep this thread running
                do
                {

                    Thread.Sleep(10);  //keep this thread alive the onAcqtimedevent will be called against it at 1 second intervals.

                } while (BackgroundManager.m_oWorkerManualAcq.CancellationPending != true);
                AT.Enabled = false;

                //Thread.Sleep(2000);


                //m_oWorkerRamp.CancelAsync();  //stop existing thread
                //Thread.Sleep(1000);


                //read presentV (actual 'kV') from NI
                //double presentV = 0.0;
                //presentV = readInputVoltage;
                //presentV = presentV * 50.0 / 10.0;

                ////ActualV.Text = presentV.ToString();
                //presentV = Math.Round(presentV, 2, MidpointRounding.AwayFromZero);


                ////read presentI (actual i) from NI
                //double presentI = 0.0;
                //presentI = readInputCurrent;
                //presentI = presentI * 2000.0 / 10.0;
                //presentI = Math.Round(presentI, 2, MidpointRounding.AwayFromZero);


                //if (presentV < 0)
                //    presentV = 0.0;
                //if (presentI < 0)
                //    presentI = 0.0;

                //Logger.WriteLogFile("sampled V or I above off zero, ramping down at acquisition cancel.","c:/temp/ManualAcq.txt");

                //int returnVal = AcquisitionControl.RampXrays(presentV, presentI, 0.0, 0.0, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);


                if (InvokeRequired)
                {
                    mbRunManualAcq.Invoke(new MethodInvoker(delegate { mbRunManualAcq.Text = "Run Acquisition"; }));
                }
                else
                {
                    mbRunManualAcq.Text = "Run Acquisition";
                }

                if (InvokeRequired)
                {
                    mrbEcal.Invoke(new MethodInvoker(delegate { mrbEcal.Enabled = true; }));
                }
                else
                {
                    mrbEcal.Enabled = true;
                }
                if (InvokeRequired)
                {
                    mrbUpscale.Invoke(new MethodInvoker(delegate { mrbUpscale.Enabled = true; }));
                }
                else
                {
                    mrbUpscale.Enabled = true;
                }
                if (InvokeRequired)
                {
                    mrbManual.Invoke(new MethodInvoker(delegate { mrbManual.Enabled = true; }));
                }
                else
                {
                    mrbManual.Enabled = true;
                }

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Ex in Manual Acquisition thread = " + Ex.ToString());
            }


        }



        //***end manual acquisition    






        //********************************************************* start manual ecal

        /// <summary>
        /// Set up back ground thread for acquisitions </br>
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void m_oWorkerEcal_DoWork(object sender, DoWorkEventArgs e)
        {


            try
            {

                lockEcalObj = new Object();
                lockEcalObj = 11;




                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                //initialize the acquisition -- then keep the thread alive

                //onEcalTimedEvent will be called after start timer is initialized every 1 second

                AcquisitionControl.SetState(100);    //init the modbus regs

                AcquisitionControl.SetCounter(0);

                //get access to xrsfp
                _cMTFFPX myacq_xrsfp = new cMTFFPX();

                //get connected if not connected.
                var ret21 = myacq_xrsfp.Connect_MCA;

                myacq_xrsfp.AutoForm_Show = false;
                myacq_xrsfp.SpectraX_Show = false;


                var AT = StartEcalTimer();

                //keep this thread running
                do
                {

                    Thread.Sleep(1);  //keep this thread alive the onAcqtimedevent will be called against it at 1 second intervals.

                } while (BackgroundManager.m_oWorkerEcal.CancellationPending != true);
                AT.Enabled = false;

                //Thread.Sleep(2000);

                //add ramp to zero here:
                //check ramp feedback and ramp to zero if needed:
                //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;


                //m_oWorkerRamp.CancelAsync();

                //Thread.Sleep(1000);

                /*
                //read presentV (actual 'kV') from NI
                double presentV = 0.0;
                presentV = readInputVoltage;
                presentV = presentV * 50.0 / 10.0;

                //ActualV.Text = presentV.ToString();
                presentV = Math.Round(presentV, 2, MidpointRounding.AwayFromZero);


                //read presentI (actual i) from NI
                double presentI = 0.0;
                presentI = readInputCurrent;
                presentI = presentI * 2000.0 / 10.0;
                presentI = Math.Round(presentI, 2, MidpointRounding.AwayFromZero);


                if (presentV < 0)
                    presentV = 0.0;
                if (presentI < 0)
                    presentI = 0.0;

               Logger.WriteLogFile(   "sampled V or I above off zero, ramping down at acquisition cancel.");

               int returnVal = AcquisitionControl.RampXrays(presentV, presentI, 0.0, 0.0, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);

                //move nozzle down
                //Logger.WriteLogFile(   "Stopping....Moving Nozzle Down.");
                //AcquisitionControl.NozzleDown(SerialManager, this);
                Thread.Sleep(6000);
                AcquisitionControl.InterlockOpen(this);


                */


                if (InvokeRequired)
                {
                     mbRunManualAcq.Invoke(new MethodInvoker(delegate { mbRunManualAcq.Text = "Run Acquisition"; }));
                }
                else
                {
                     mbRunManualAcq.Text = "Run Acquisition";
                }

                if (InvokeRequired)
                {
                    mrbEcal.Invoke(new MethodInvoker(delegate { mrbEcal.Enabled = true; }));
                }
                else
                {
                    mrbEcal.Enabled = true;
                }
                if (InvokeRequired)
                {
                    mrbUpscale.Invoke(new MethodInvoker(delegate { mrbUpscale.Enabled = true; }));
                }
                else
                {
                    mrbUpscale.Enabled = true;
                }
                if (InvokeRequired)
                {
                    mrbManual.Invoke(new MethodInvoker(delegate { mrbManual.Enabled = true; }));
                }
                else
                {
                    mrbManual.Enabled = true;
                }



            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Ex in Ecal thread = " + Ex.ToString());
            }


        }


        //************************************************************** end manual ecal


        /// <summary>
        /// Set up back ground thread for acquisitions </br>
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void m_oWorkerAcq_DoWork(object sender, DoWorkEventArgs e)
        {


            try
            {

                lockObj = new Object();
                lockObj = 1;


                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                //test logic here:





                //end test logic:

                AcquireRequestStarted = DateTime.Now;

                Logger.WriteLogFile(   "state 0 (init).  Set flow volume to zero.");

                AcquisitionControl.SetFlowVolume(0);

                AcquisitionControl.SetState(8);    //init the modbus regs: state(08)

                

                AcquisitionControl.SetCounter(0);
                AcquisitionControl.SetSamplePeriod(Properties.Settings.Default.SampleTime);


                //get access to xrsfp
                _cMTFFPX myacq_xrsfp = new cMTFFPX();

                //get connected if not connected.
                var ret21 = myacq_xrsfp.Connect_MCA;


                myacq_xrsfp.AutoForm_Show = false;
                myacq_xrsfp.SpectraX_Show = false;

                AcquireRequestStarted = DateTime.Now;

                AcquireStart = AcquisitionControl.CalculateAcquireStartTime(AcquireRequestStarted);  //this is how long you wait to start

                AcquisitionControl.SetAcquireStartTime(AcquireStart);


                var AT = StartAcqTimer();

                //keep this thread running
                do
                {

                    Thread.Sleep(10);  //keep this thread alive the onAcqtimedevent will be called against it at 1 second intervals.

                } while (BackgroundManager.m_oWorkerAcq.CancellationPending != true);

                AT.Enabled = false;


                Thread.Sleep(1000);
                //add pump off:
                try
                {
                    int returnVal09 = AcquisitionControl.PumpOff(m_oWorkerPump);
                    if (returnVal09 == PASS)
                    {

                        Logger.WriteLogFile("PUMP OFF after acq thread ended.");

                    }
                    else
                    {

                        Logger.WriteInternalLogFile("Error at Control state <stop acq>  Pump off.");

                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error at pump off.  Ex = "+Ex.ToString());
                }



// remove unnecessary ramp cancel
 //               m_oWorkerRamp.CancelAsync();
 //               Thread.Sleep(1000);
 



                //read presentV (actual 'kV') from NI
                double presentV = 0.0;
                presentV = readInputVoltage;
                presentV = presentV * 50.0 / 10.0;



                //read presentI (actual i) from NI
                double presentI = 0.0;
                presentI = readInputCurrent;
                presentI = presentI * 2000.0 / 10.0;
 


                if (presentV < 0)
                    presentV = 0.0;
                if (presentI < 0)
                    presentI = 0.0;


                //if (presentV > 3 || presentI > 250)
                //{
                //    Logger.WriteLogFile("Sampled V or I above off zero, ramping down at acquisition cancel.");

                //    int returnVal = AcquisitionControl.RampXrays(presentV, presentI, 0.0, 0.0, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);


                //}



                //move nozzle down
                //  
                //UpdateOperationMessage("Stop Instrument.  Moving Nozzle Down.");
                Logger.WriteLogFile("Stopping....Moving Nozzle Down.");
                AcquisitionControl.NozzleDown(SerialManager, this);

                //

                UpdateOperationMessage("Stop complete");



            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Ex in acq thread = " + Ex.ToString());

            }


        }

        //*********************************************************** start ecal progress changed

        void m_oWorkerEcal_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {

            //define the strings in the update array 
            string[] values = new string[50];


            values = (string[])e.UserState;

            // make sure the data is there, via this try otherwise you shouldn't unpack
            try
            {

                //write to GUI:
                string counter = Convert.ToString(values[0]);



            }
            catch (Exception ex)
            {
                string msg;
                msg = "Ecal progress changed ex= " + ex.ToString();
                Logger.WriteInternalLogFile(msg);
                //write to ecal text box
            }





        }


        //*********************************************************** end ecal progress changed

        //*********************************************************** start upscale progress changed

        void m_oWorkerUpscale_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {

            //define the strings in the update array 
            string[] values = new string[50];


            values = (string[])e.UserState;

            // make sure the data is there, via this try otherwise you shouldn't unpack
            try
            {

                //write to GUI:
                string counter = Convert.ToString(values[0]);



            }
            catch (Exception ex)
            {
                string msg;
                msg = "Upscale progress changed ex= " + ex.ToString();
                Logger.WriteInternalLogFile(msg);
                //write to ecal text box
            }
        }


        //*********************************************************** end upscale progress changed

        //*** start manual acq progress changed
        void m_oWorkerManualAcq_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {

            //define the strings in the update array 
            string[] values = new string[50];


            values = (string[])e.UserState;

            // make sure the data is there, via this try otherwise you shouldn't unpack
            try
            {

                //write to GUI:
                string counter = Convert.ToString(values[0]);



            }
            catch (Exception ex)
            {
                string msg;
                msg = "Manual Acquisition progress changed ex= " + ex.ToString();
                Logger.WriteInternalLogFile(msg);
                //write to ecal text box
            }
        }
        //end *** manual acq progress changed

        // *** start leak check progress changed
        void m_oLeakCheck_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            //access to GUI occurs here without the method invoker

            //define the strings in the update array 
            string[] values = new string[50];


            values = (string[])e.UserState;

            // make sure the data is there, via this try otherwise you shouldn't unpack
            try
            {

                //write to GUI:
                string counter = Convert.ToString(values[0]);



            }
            catch (Exception ex)
            {
                string msg;
                msg = "Error:  Leak Check progress changed Ex = " + ex.ToString();
                Logger.WriteInternalLogFile(msg);
            }
        }

        // *** end leak check progress changed


        /// <summary>
        /// Notification is performed here to the progress bar, and GUI
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void m_oWorkerAcq_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {

            //define the strings in the update array 
            string[] values = new string[4];


            //Here you play with the main UI thread
            //for testing add a progress bar:
            values = (string[])e.UserState;

            // make sure the data is there, via this try otherwise you shouldn't unpack
            try
            {

                //write to GUI:
                string counter = Convert.ToString(values[0]);
                //todo
                //tbmetroAcqTime.Text = counter.ToString();

                //todo
                //bhc disable operation text by commenting out
                //mtbStatusOperation.Text = values[1];


                //todo
                //acqProgressBar.Value = e.ProgressPercentage;



            }
            catch (Exception ex)
            {
                string msg;
                msg = "Acq progress changed ex= " + ex.ToString();
                Logger.WriteInternalLogFile(msg);
            }





        }


        /// <summary>
        /// On completed do the appropriate task
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void m_oWorkerEcal_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            Logger.WriteLogFile( "m_oWorkerEcal_RunWorkerCompleted routine called.", "c:/temp/ManualEcal.txt");

            //handle ecal completion
            //output data
            //message box?

            if (WarmUpActive ==2)
            {
                WarmUpActive = 0;

                
                if (mbWarmUp.InvokeRequired)
                {
                    mbWarmUp.Invoke(new MethodInvoker(delegate { mbWarmUp.Text = "Warm Up"; }));
                    mbWarmUp.Invoke(new MethodInvoker(delegate { mbWarmUp.Refresh(); }));
                }
                else
                {
                    mbWarmUp.Text = "Warm Up";
                    mbWarmUp.Refresh();
                }
                
            }
            else
            {

                DialogResult dialogResult = MetroMessageBox.Show(this, "Turn off X-rays?", "Ecal Completed.", MessageBoxButtons.YesNo, MessageBoxIcon.Information, MessageBoxDefaultButton.Button1 /*,height=250*/);


                if (dialogResult == DialogResult.Yes)
                {

                    RampXraysToZero();
                    
                }










            }

        }

        /// <summary>
        /// On completed do the appropriate task
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void m_oWorkerUpscale_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            Logger.WriteLogFile( "m_oWorkerUpscale_RunWorkerCompleted routine called.", "c:/temp/ManualUpscale.txt");

            //handle ecal completion
            //output data
            //message box?









        }


        /// <summary>
        /// On completed do the appropriate task
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void m_oWorkerTubeSeasoning_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            Logger.WriteLogFile("m_oWorkerTubeSeasoning_RunWorkerCompleted routine called.");
            if(WarmUpActive==1)
            {
                BackgroundManager.m_oWorkerEcal.RunWorkerAsync();
                WarmUpActive = 2;

                /*
                if (mbWarmUp.InvokeRequired)
                {
                    mbWarmUp.Invoke(new MethodInvoker(delegate { mbWarmUp.Text = "Warm Up"; }));
                    mbWarmUp.Invoke(new MethodInvoker(delegate { mbWarmUp.Refresh(); }));
                }
                else
                {
                    mbWarmUp.Text = "Warm Up";
                    mbWarmUp.Refresh();
                }
                */

            }



        }





        /// <summary>
        /// On completed do the appropriate task
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void m_oWorkerAcq_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            Logger.WriteLogFile(   "m_oWorkerAcq_RunWorkerCompleted routine called.");


        }



        /// <summary>
        /// 
        /// </summary>
        private void StartReadInputTimer()
        {


            lockTimerObj = new Object();
            lockTimerObj = 2;

            //read input timer set to 1 second
            IOReadAndDisplayGUITimer.Interval = 250;
            IOReadAndDisplayGUITimer.Tick += new EventHandler(ReadInputTimer_Tick);
            IOReadAndDisplayGUITimer.Start();

            //not yet used
            //GUIControlFlashTimer.Interval = 500;
            //GUIControlFlashTimer.Tick += new EventHandler(GUIFlashInputTimer_Tick);

 

            // Hook up the Elapsed event for the timer.
            ///timer.Elapsed += new ElapsedEventHandler(OnTimedEvent);

            ///timer.Enabled = true;

        }

        private void StopInterlockToggleTimer()
        {
            ToggleInterlockTimer.Stop();
            

        }

        /// <summary>
        /// 
        /// </summary>
        private void StartInterlockToggleTimer()
        {


            lockToggleInterlockTimerObj = new Object();
            lockToggleInterlockTimerObj = 2.891;

            //read input timer set to 2 second
            //IOReadAndDisplayGUITimer.Interval = 2000;
            ToggleInterlockTimer.Interval = 1000;
            ToggleInterlockTimer.Tick += new EventHandler(ToggleInterlockTimer_Tick);
            ToggleInterlockTimer.Start();
            


            //not yet used
            //GUIControlFlashTimer.Interval = 500;
            //GUIControlFlashTimer.Tick += new EventHandler(GUIFlashInputTimer_Tick);

            //this launches on NON-gui thread timer:
            ///var timer = new System.Timers.Timer(5000);    //5000 is normal for five second update rate

            // Hook up the Elapsed event for the timer.
            ///timer.Elapsed += new ElapsedEventHandler(OnTimedEvent);

            ///timer.Enabled = true;


        }


        /// <summary>
        /// 
        /// </summary>
        private void StartReadWindSpeedInputTimer()
        {


            lockWindSpeedTimerObj = new Object();
            lockWindSpeedTimerObj = 20;

            //read input timer set to 1 second
            IOReadWindSpeedAndDisplayGUITimer.Interval = 2000;
            IOReadWindSpeedAndDisplayGUITimer.Tick += new EventHandler(ReadInputWindSpeedTimer_Tick);
            IOReadWindSpeedAndDisplayGUITimer.Start();



        }





        /// <summary>
        /// todo depricated?
        /// </summary>
        private void StartErrorMonitorTimer()
        {


            errorMonitorTimer.Interval = 1000;
            //errorMonitorTimer.Tick += new EventHandler(errorMonitorTimer_Tick);
            //errorMonitorTimer.Start();

        }





        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private double ReadInputCurrent()
        {
            double avgCurrent = 0.0;
            int readOk = 0;
            int counter = 0;
            string exString = "";

            do
            {

                try
                {
#if TURNON_NIHARDWARE
                    reader = new AnalogMultiChannelReader(InputCurrent.Stream);
                    InputCurrentData = reader.ReadWaveform(2);

                    readOk = 1;
                    double sum = 0.0;
                    string stringValue;


                    // Iterate over channels
                    int NumberOfReads = 0;
                    foreach (AnalogWaveform<double> waveform in InputCurrentData)
                    {
                        for (int sample = 0; sample < waveform.Samples.Count; ++sample)
                        {
                            sum = sum + waveform.Samples[sample].Value;
                            NumberOfReads++;
                            stringValue = waveform.Samples[sample].Value.ToString();

                            //dataFile2.WriteLine(stringValue);   //this does a file write (many be a real time restriction here!)
                        }
                    }
                    if (NumberOfReads > 0)
                    {
                        avgCurrent = sum / NumberOfReads;
                        break;
                    }
                    //dataFile2.WriteLine(" *** AVG=, {0}", avg);

#else
                    avgCurrent = 4.567;
                    readOk = 1;
#endif


                }
                catch (Exception Ex)
                {
                    //string msg;
                    exString = Ex.ToString();
                    //msg = "hvps CURRENT input read ex= " + e.ToString();
                    //Logger.WriteErrorFile(msg);
                    //msg = "hvps read error counter = " + counter.ToString();
                    //Logger.WriteInternalLogFile("Exception in Read HVPS input current.  Ex = "+Ex.ToString());
                    counter += 1;
                    Thread.Sleep(50);

                }
            } while (readOk == 0 && counter < 50);

            if (counter >= 50)
            {
                Logger.WriteInternalLogFile("Exceptions in Read HVPS input current = " + counter.ToString()+"   Ex = " + exString);

                //Logger.WriteInternalLogFile("hvps (form1)read error.  counter = " + counter.ToString());
            }

            return avgCurrent;
        }


//        private void InterlockOpen()
//        {
//            DigitalSingleChannelWriter Port00writer = new DigitalSingleChannelWriter(InterlockOutput.Stream);
//#if TURNON_NIHARDWARE
//            Port00writer.WriteSingleSampleSingleLine(true, false);




//#endif
//        }



        private void InterlockControlWatchdogToggle()
        {
            if (interlockControlWatchdogToggle == 1)
            {
                interlockControlWatchdogToggle = 0;
                try
                {
                    DigitalSingleChannelWriter Port10writer = new DigitalSingleChannelWriter(InterlockControlWatchdogOutput.Stream);
#if TURNON_NIHARDWARE
                    Port10writer.WriteSingleSampleSingleLine(true, true);
#endif
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error: in Interlock Watchdog Ouput set true. Ex = " + Ex.ToString());
                }
            }
            else
            {
                interlockControlWatchdogToggle = 1;
                try
                {
                    DigitalSingleChannelWriter Port10writer = new DigitalSingleChannelWriter(InterlockControlWatchdogOutput.Stream);
#if TURNON_NIHARDWARE
                    Port10writer.WriteSingleSampleSingleLine(true, false);
#endif
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error: in Interlock Watchdog Ouput set false. Ex = " + Ex.ToString());
                }

            }
        }



 






    private void InterlockClose()
        {

            try
            {
                DigitalSingleChannelWriter Port00writer = new DigitalSingleChannelWriter(InterlockOutput.Stream);
#if TURNON_NIHARDWARE
                Port00writer.WriteSingleSampleSingleLine(true, true);
#endif
            }
            catch (Exception Ex)
            {
                Logger.WriteErrorFile("Error: in Interlock Close. Ex = " + Ex.ToString());
            }
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <param name="e"></param>
        private void OnRampEvent()
        {


            string[] RampValues = new string[4];


            double voltageOutputValue;
            double currentOutputValue;

            double voltageOutputValueOld = 0;
            double currentOutputValueOld = 0;

            double actCurrent;
            double actVoltage;
            //string timeStampForLog;
            //string stringValue;
            string[] values;

            int counter;
            double progress;
            int iprogress;

            int total;  //size of linearRampValuesVoltage
                        //AcquisitionLogic AcquisitionControl = new AcquisitionLogic();
                        //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            int rampIndexLocal = 0;
            values = new string[4];




            //if (Monitor.TryEnter(rampLockObj))
            //{

            try
            {

                total = LinearRampValuesVoltage.Count;

                rampIndexLocal = rampIndex;
                if (rampIndexLocal >= total - 1)
                {
                    rampIndexLocal = total - 1;
                }
                voltageOutputValue = LinearRampValuesVoltage[rampIndexLocal];
                currentOutputValue = LinearRampValuesCurrent[rampIndexLocal];

                if (rampIndex >= 1 && rampIndex <= total - 2)
                {
                    voltageOutputValueOld = LinearRampValuesVoltage[rampIndexLocal - 1];
                    currentOutputValueOld = LinearRampValuesCurrent[rampIndexLocal - 1];
                }
                else if (rampIndex >= (total - 1))
                {
                    voltageOutputValueOld = LinearRampValuesVoltage[rampIndexLocal];
                    currentOutputValueOld = LinearRampValuesCurrent[rampIndexLocal];
                }


                WriteOutputVoltage(voltageOutputValue);
                WriteOutputCurrent(currentOutputValue);

                actCurrent = readInputCurrent;
                actVoltage = readInputVoltage;

                //read back voltage from HVPS:
                //check for within +/- 5 percent
                AcquisitionLogic AcquisitionControl = new AcquisitionLogic();

                if (rampIndexLocal != 0)
                {
                    Logger.WriteLogFile("," + checkLastValueCounter.ToString() + "," + rampIndex.ToString() + "," + actCurrent.ToString("F2") + "," + currentOutputValueOld.ToString("F2") + "," + rampErrorIHigh.ToString() + "," + rampErrorILow.ToString() + "," + actVoltage.ToString("F2") + "," + voltageOutputValueOld.ToString("F2") + "," + rampErrorVHigh.ToString() + "," + rampErrorVLow.ToString() + ",","C:/ces/internallog/vinfo.csv");
                }
                if (rampIndex >= 2)
                {

                    if ((actCurrent > (currentOutputValueOld * 1.050)) && (currentOutputValueOld > 0.35) && (currentOutputValue > 0.35))  //0.35 to avoid noise 
                    {
                        rampErrorIHigh++;
                        if (rampErrorIHigh > 2)
                        {
                            //systemError.Add(1);
                            //errorString.Add("Actual Xray current too hi");
                            AcquisitionControl.SetAlarmValue(101);
                            WriteAlarmToModbus(101);
                            Halt("Actual Xray Current too high.  Cmd=" + currentOutputValueOld.ToString("F4") + " Act=" + actCurrent.ToString("F4"));
                        }


                    }
                    else
                    {
                        rampErrorIHigh = 0;
                    }

                    if (actCurrent < (currentOutputValueOld * .95) && (currentOutputValueOld > 0.35) && (currentOutputValue > 0.35))
                    {
                        rampErrorILow++;
                        if (rampErrorILow > 2)
                        {
                            //systemError.Add(2);
                            //errorString.Add("Actual Xray Current too low");
                            AcquisitionControl.SetAlarmValue(101);
                            WriteAlarmToModbus(101);
                            //Halt("Actual Xray Current too low");
                            Halt("Actual Xray Current too low  Cmd=" + currentOutputValueOld.ToString("F4") + " Act=" + actCurrent.ToString("F4"));

                        }
                    }
                    else
                    {
                        rampErrorILow = 0;
                    }

                    if (actVoltage > (voltageOutputValueOld * 1.05) && (voltageOutputValueOld > 0.35) && (voltageOutputValue > 0.35))
                    {
                        rampErrorVHigh++;
                        if (rampErrorVHigh > 2)
                        {
                            //systemError.Add(3);
                            //errorString.Add("Actual voltage too hi");
                            AcquisitionControl.SetAlarmValue(100);
                            WriteAlarmToModbus(100);
                            //Halt("Actual Xray voltage too high");
                            Halt("Actual Xray Voltage too high  Cmd=" + voltageOutputValueOld.ToString("F4") + " Act=" + actVoltage.ToString("F4"));

                        }
                    }
                    else
                    {
                        rampErrorVHigh = 0;
                    }

                    if (actVoltage < (voltageOutputValueOld * .95) && (voltageOutputValueOld > 0.35) && (voltageOutputValue > 0.35))
                    {
                        rampErrorVLow++;
                        if (rampErrorVLow > 2)
                        {
                            //systemError.Add(4);
                            //errorString.Add("Actual voltage too low.");
                            AcquisitionControl.SetAlarmValue(100);
                            WriteAlarmToModbus(100);
                            //Halt("Actual Xray voltage too low");
                            Halt("Actual Xray Voltage too low  Cmd=" + voltageOutputValueOld.ToString("F4") + " Act=" + actVoltage.ToString("F4"));
                        }
                    }
                    else
                    {
                        rampErrorVLow = 0;
                    }

                }
                //no check of first two feedback values in ramp (often are negative from HW)


                counter = rampIndex;



                //
                //int icountUp = 1;

                //if (icountUp == 1)
                //{
                progress = (counter / total) * 100.0;
                iprogress = (int)progress;
                //}
                //else
                //{
                //    progress = 100 - ((counter / total) * 100.0);
                //    iprogress = (int)progress;
                //}

                values[0] = actVoltage.ToString("F2");
                values[1] = actCurrent.ToString("F2");
                values[2] = Error.ToString();
                values[3] = iprogress.ToString();


                double kVolt = actVoltage * 50.0 / 10.0;
                kVolt = Math.Round(kVolt, 2, MidpointRounding.AwayFromZero);

                //double uAmp = Convert.ToDouble(values[1]);
                double uAmp = actCurrent * 2000.0 / 10.0;
                uAmp = Math.Round(uAmp, 2, MidpointRounding.AwayFromZero);

                //total = LinearRampValuesVoltage.Count;


                if (checkLastValueCounter >= 1)
                {
                    try
                    {
                        if (m_oWorkerRamp.CancellationPending == false)
                        {
                            //m_oWorkerRamp.ReportProgress(100, values);
                            UpdatekVMessage(kVolt.ToString("F2"));
                            UpdateuAMessage(uAmp.ToString("F2"));
                            //UpdateXrayProgressBar(100);

                            if (m_oWorkerRamp.IsBusy)
                            {
                                m_oWorkerRamp.CancelAsync();
                            }
                            //RampTimer.Enabled = true;

                        }
                    }
                    catch (Exception Ex)
                    {
                        Logger.WriteInternalLogFile("Error cancel ramp async. Ex = " + Ex.ToString());
                    }

                }




                if (rampIndex < (total))
                {
                    rampIndex++;
                    //m_oWorkerRamp.ReportProgress(iprogress, values);
                    //change from report progress to invoke function calls
                    UpdatekVMessage(kVolt.ToString("F2"));
                    UpdateuAMessage(uAmp.ToString("F2"));
                    //UpdateXrayProgressBar(iprogress);


                }
                else
                {

                    //stop the timed event, and stop the thread it's running on
                    //set checkLastValue
                    checkLastValueCounter++;
                    //try
                    //{
                    //if (m_oWorkerRamp.CancellationPending == false)
                    //{
                    //m_oWorkerRamp.ReportProgress(100, values);
                    UpdatekVMessage(kVolt.ToString("F2"));
                    UpdateuAMessage(uAmp.ToString("F2"));
                    //UpdateXrayProgressBar(100);

                    //m_oWorkerRamp.CancelAsync();
                    //RampTimer.Enabled = true;

                    //}
                    //}
                    //catch (Exception Ex)
                    //{
                    //    Logger.WriteLogFile("c:/temp/acquisition.txt", "ex at worker ramp report progress:  " + Ex.ToString());
                    //}
                }







            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in ramp timer logic = " + Ex.ToString());
            }
            finally
            {
                //Logger.WriteLogFile("c:/temp/Acquisition.txt", "@finally, done with xray power ramp thread.");
                //Monitor.Exit(rampLockObj);
            }

            //}
            //else
            //{
            //lock not obtained for this timer.
            //    Logger.WriteInternalLogFile("X-ray power ramp, lock not obtained for this timer....");

            //}

        }






        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <param name="e"></param>
        /// 
        //private void onRampTimedEvent(object source, ElapsedEventArgs e)
        //{

        //    string[] RampValues = new string[4];


        //    double voltageOutputValue;
        //    double currentOutputValue;

        //    double voltageOutputValueOld = 0;
        //    double currentOutputValueOld = 0;

        //    double actCurrent;
        //    double actVoltage;
        //    //string timeStampForLog;
        //    //string stringValue;
        //    string[] values;

        //    int counter;
        //    double progress;
        //    int iprogress;

        //    int total;  //size of linearRampValuesVoltage
        //                //AcquisitionLogic AcquisitionControl = new AcquisitionLogic();
        //                //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
        //    int rampIndexLocal = 0;
        //    values = new string[4];

        //    if (Monitor.TryEnter(rampLockObj))
        //    {

        //        try
        //        {

        //            total = LinearRampValuesVoltage.Count;

        //            rampIndexLocal = rampIndex;
        //            if (rampIndexLocal >= total - 1)
        //            {
        //                rampIndexLocal = total - 1;
        //            }
        //            voltageOutputValue = LinearRampValuesVoltage[rampIndexLocal];
        //            currentOutputValue = LinearRampValuesCurrent[rampIndexLocal];

        //            if (rampIndex >= 1 && rampIndex <= total - 2)
        //            {
        //                voltageOutputValueOld = LinearRampValuesVoltage[rampIndexLocal - 1];
        //                currentOutputValueOld = LinearRampValuesCurrent[rampIndexLocal - 1];
        //            }
        //            else if (rampIndex >= (total - 1))
        //            {
        //                voltageOutputValueOld = LinearRampValuesVoltage[rampIndexLocal];
        //                currentOutputValueOld = LinearRampValuesCurrent[rampIndexLocal];
        //            }


        //            WriteOutputVoltage(voltageOutputValue);
        //            WriteOutputCurrent(currentOutputValue);

        //            actCurrent = readInputCurrent;
        //            actVoltage = readInputVoltage;

        //            //read back voltage from HVPS:
        //            //check for within +/- 5 percent
        //            AcquisitionLogic AcquisitionControl = new AcquisitionLogic();
        //            if (rampIndexLocal != 0)
        //            {
        //                Logger.WriteLogFile( "," + checkLastValueCounter.ToString() + "," + rampIndex.ToString() + "," + actCurrent.ToString("F2") + "," + currentOutputValueOld.ToString("F2") + "," + rampErrorIHigh.ToString() + "," + rampErrorILow.ToString() + "," + actVoltage.ToString("F2") + "," + voltageOutputValueOld.ToString("F2") + "," + rampErrorVHigh.ToString() + "," + rampErrorVLow.ToString() + ",", "C:/ces/internallog/vinfo.csv");
        //            }
        //            if (rampIndex >= 2)
        //            {

        //                if (actCurrent > (currentOutputValueOld * 1.050) && (currentOutputValueOld > 0) && (currentOutputValue > 0))
        //                {
        //                    rampErrorIHigh++;
        //                    if (rampErrorIHigh > 2)
        //                    {
        //                        systemError.Add(1);
        //                        //errorString.Add("Actual Xray current too hi");
        //                        AcquisitionControl.SetAlarmValue(101);
        //                        WriteAlarmToModbus(101);
        //                        Halt("Actual Xray Current too high.  Cmd=" + currentOutputValueOld.ToString("F4") + " Act=" + actCurrent.ToString("F4"));
        //                    }


        //                }
        //                else
        //                {
        //                    rampErrorIHigh = 0;
        //                }

        //                if (actCurrent < (currentOutputValueOld * .95) && (currentOutputValueOld > 0) && (currentOutputValue >0))
        //                {
        //                    rampErrorILow++;
        //                    if (rampErrorILow > 2)
        //                    {
        //                        systemError.Add(2);
        //                        //errorString.Add("Actual Xray Current too low");
        //                        AcquisitionControl.SetAlarmValue(101);
        //                        WriteAlarmToModbus(101);
        //                        //Halt("Actual Xray Current too low");
        //                        Halt("Actual Xray Current too low  Cmd=" + currentOutputValueOld.ToString("F4") + " Act=" + actCurrent.ToString("F4"));
        //                    }
        //                }
        //                else
        //                {
        //                    rampErrorILow = 0;
        //                }

        //                if (actVoltage > (voltageOutputValueOld * 1.05) && (voltageOutputValueOld > 0) && (voltageOutputValue >0))
        //                {
        //                    rampErrorVHigh++;
        //                    if (rampErrorVHigh > 2)
        //                    {
        //                        systemError.Add(3);
        //                        //errorString.Add("Actual voltage too hi");
        //                        AcquisitionControl.SetAlarmValue(100);
        //                        WriteAlarmToModbus(100);
        //                        //Halt("Actual Xray voltage too hi");
        //                        Halt("Actual Xray Voltage too high  Cmd=" + voltageOutputValueOld.ToString("F4") + " Act=" + actVoltage.ToString("F4"));
        //                    }
        //                }
        //                else
        //                {
        //                    rampErrorVHigh = 0;
        //                }

        //                if (actVoltage < (voltageOutputValueOld * .95) && (voltageOutputValueOld > 0) && (voltageOutputValue>0))
        //                {
        //                    rampErrorVLow++;
        //                    if (rampErrorVLow > 2)
        //                    {
        //                        systemError.Add(4);
        //                        //errorString.Add("Actual voltage too low.");
        //                        AcquisitionControl.SetAlarmValue(100);
        //                        WriteAlarmToModbus(100);
        //                        //Halt("Actual Xray voltage too low");
        //                        Halt("Actual Xray Voltage too low  Cmd=" + voltageOutputValueOld.ToString("F4") + " Act=" + actVoltage.ToString("F4"));

        //                    }
        //                }
        //                else
        //                {
        //                    rampErrorVLow = 0;
        //                }

        //            }
        //            //no check of first two feedback values in ramp (often are negative from HW)


        //            counter = rampIndex;



        //            //
        //            //int icountUp = 1;

        //            //if (icountUp == 1)
        //            //{
        //            progress = (counter / total) * 100.0;
        //            iprogress = (int)progress;
        //            //}
        //            //else
        //            //{
        //            //    progress = 100 - ((counter / total) * 100.0);
        //            //    iprogress = (int)progress;
        //            //}

        //            values[0] = actVoltage.ToString("F2");
        //            values[1] = actCurrent.ToString("F2");
        //            values[2] = Error.ToString();
        //            values[3] = iprogress.ToString();


        //            double kVolt = actVoltage * 50.0 / 10.0;
        //            kVolt = Math.Round(kVolt, 2, MidpointRounding.AwayFromZero);

        //            //double uAmp = Convert.ToDouble(values[1]);
        //            double uAmp = actCurrent * 2000.0 / 10.0;
        //            uAmp = Math.Round(uAmp, 2, MidpointRounding.AwayFromZero);

        //            //total = LinearRampValuesVoltage.Count;


        //            if (checkLastValueCounter >= 1)
        //            {
        //                try
        //                {
        //                    if (m_oWorkerRamp.CancellationPending == false)
        //                    {
        //                        //m_oWorkerRamp.ReportProgress(100, values);
        //                        UpdatekVMessage(kVolt.ToString("F2"));
        //                        UpdateuAMessage(uAmp.ToString("F2"));
        //                        //UpdateXrayProgressBar(100);

        //                        m_oWorkerRamp.CancelAsync();
        //                        //RampTimer.Enabled = true;

        //                    }
        //                }
        //                catch (Exception Ex)
        //                {
        //                    Logger.WriteInternalLogFile("Error cancel ramp async. Ex = " + Ex.ToString());
        //                }

        //            }




        //            if (rampIndex < (total))
        //            {
        //                rampIndex++;
        //                //m_oWorkerRamp.ReportProgress(iprogress, values);
        //                //change from report progress to invoke function calls
        //                UpdatekVMessage(kVolt.ToString("F2"));
        //                UpdateuAMessage(uAmp.ToString("F2"));
        //                //UpdateXrayProgressBar(iprogress);


        //            }
        //            else
        //            {

        //                //stop the timed event, and stop the thread it's running on
        //                //set checkLastValue
        //                checkLastValueCounter++;
        //                //try
        //                //{
        //                //if (m_oWorkerRamp.CancellationPending == false)
        //                //{
        //                //m_oWorkerRamp.ReportProgress(100, values);
        //                UpdatekVMessage(kVolt.ToString("F2"));
        //                UpdateuAMessage(uAmp.ToString("F2"));
        //                //UpdateXrayProgressBar(100);

        //                //m_oWorkerRamp.CancelAsync();
        //                //RampTimer.Enabled = true;

        //                //}
        //                //}
        //                //catch (Exception Ex)
        //                //{
        //                //    Logger.WriteLogFile("c:/temp/acquisition.txt", "ex at worker ramp report progress:  " + Ex.ToString());
        //                //}
        //            }







        //        }
        //        catch (Exception Ex)
        //        {
        //            Logger.WriteInternalLogFile("Exception in ramp timer logic = " + Ex.ToString());
        //        }
        //        finally
        //        {
        //            //Logger.WriteLogFile("c:/temp/Acquisition.txt", "@finally, done with xray power ramp thread.");
        //            Monitor.Exit(rampLockObj);
        //        }

        //    }
        //    else
        //    {
        //        //lock not obtained for this timer.
        //        Logger.WriteInternalLogFile("X-ray power ramp, lock not obtained for this timer....");

        //    }

        //}


        /*
        private void onRampTimedEvent(object source, ElapsedEventArgs e)
        {

            string[] RampValues = new string[4];
            //grab next value for output

            //generate output

            //Update status bar and values

            double voltageOutputValue;
            double currentOutputValue;
            double actCurrent;
            double actVoltage;
            //string timeStampForLog;
            //string stringValue;
            string[] values;

            int counter;
            double progress;
            int iprogress;

            double total;  //size of linearRampValuesVoltage
                           //AcquisitionLogic AcquisitionControl = new AcquisitionLogic();
                           //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            values = new string[4];




            if (Monitor.TryEnter(rampLockObj))
            {

                try
                {


                    total = LinearRampValuesVoltage.Count;


                    voltageOutputValue = LinearRampValuesVoltage[rampIndex];
                    currentOutputValue = LinearRampValuesCurrent[rampIndex];

                    WriteOutputVoltage(voltageOutputValue);
                    WriteOutputCurrent(currentOutputValue);
                    //this is here to allow a delay on the last two reads so that the display reflects reality.
                    if (rampIndex >= total - 2)
                    {
                        //   Thread.Sleep(290);
                    }

                        actCurrent = readInputCurrent;
                        actVoltage = readInputVoltage;
                    //if (rampIndex > 10)
                    // {
                    //     voltageOutputValue = LinearRampValuesVoltage[rampIndex - 1];
                    //     currentOutputValue = LinearRampValuesCurrent[rampIndex - 1];
                    // }

                    //this update
                    //timeStampForLog = GetTimeStampStr();
                    //stringValue = timeStampForLog + ",OutputVoltage," + voltageOutputValue.ToString() + ",Actual Voltage," + actVoltage.ToString() + ",OutputCurrent," + currentOutputValue.ToString() + ",Actual Current," + actCurrent.ToString();
                    //dataFileCR.WriteLine(stringValue);   //this does a file write 

                    //read back voltage from HVPS:
                    //check for within +/- 5 percent
                    AcquisitionLogic AcquisitionControl = new AcquisitionLogic();

                    if (rampIndex > 12)
                    {
                        if (actCurrent > (currentOutputValue * 1.050))
                        {
                            systemError.Add(1);
                            errorString.Add("Actual Xray current too hi");
                            AcquisitionControl.SetAlarmValue(101);
                            WriteAlarmToModbus(101);
                            Halt("Actual Xray Current too hi");


                        }
                        if (actCurrent < (currentOutputValue * .50))
                        {
                            systemError.Add(2);
                            errorString.Add("Actual Xray Current too low");
                            AcquisitionControl.SetAlarmValue(101);
                            WriteAlarmToModbus(101);
                            Halt("Actual Xray Current too low");
                        }

                        if (actVoltage > (voltageOutputValue * 1.50))
                        {
                            systemError.Add(3);
                            errorString.Add("Actual voltage too hi");
                            AcquisitionControl.SetAlarmValue(100);
                            WriteAlarmToModbus(100);
                            Halt("Actual Xray voltage too hi");

                        }
                        if (actVoltage < (voltageOutputValue * .50))
                        {
                            systemError.Add(4);
                            errorString.Add("Actual voltage too low.");
                            AcquisitionControl.SetAlarmValue(100);
                            WriteAlarmToModbus(100);
                            Halt("Actual Xray voltage too low");

                        }
                    }


                    counter = rampIndex;



                    //
                    int icountUp = 1;

                    if (icountUp == 1)
                    {
                        progress = (counter / total) * 100.0;
                        iprogress = (int)progress;
                    }
                    else
                    {
                        progress = 100 - ((counter / total) * 100.0);
                        iprogress = (int)progress;
                    }

                    values[0] = actVoltage.ToString("F2");
                    values[1] = actCurrent.ToString("F2");
                    values[2] = Error.ToString();
                    values[3] = icountUp.ToString();


                    double kVolt = actVoltage * 50.0 / 10.0;

                    kVolt = Math.Round(kVolt, 2, MidpointRounding.AwayFromZero);


                    //double uAmp = Convert.ToDouble(values[1]);
                    double uAmp = actCurrent * 2000.0 / 10.0;
                    uAmp = Math.Round(uAmp, 2, MidpointRounding.AwayFromZero);





                    //total = LinearRampValuesVoltage.Count;
                    if (rampIndex < (total - 1))
                    {
                        rampIndex++;
                        //m_oWorkerRamp.ReportProgress(iprogress, values);
                        //change from report progress to invoke function calls
                        UpdatekVMessage(kVolt.ToString("F2"));
                        UpdateuAMessage(uAmp.ToString("F2"));
                        UpdateXrayProgressBar(iprogress);


                    }
                    else
                    {
                        //stop the timed event, and stop the thread it's running on
                        try
                        {
                            if (m_oWorkerRamp.CancellationPending == false)
                            {
                                //m_oWorkerRamp.ReportProgress(100, values);
                                UpdatekVMessage(kVolt.ToString("F2"));
                                UpdateuAMessage(uAmp.ToString("F2"));
                                UpdateXrayProgressBar(100);

                                m_oWorkerRamp.CancelAsync();
                                //RampTimer.Enabled = true;

                            }
                        }
                        catch (Exception Ex)
                        {
                            Logger.WriteLogFile(   "ex at worker ramp report progress:  " + Ex.ToString());
                        }
                    }





                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Exception in ramp timer logic = " + Ex.ToString());
                }
                finally
                {
                    //Logger.WriteLogFile(   "@finally, done with xray power ramp thread.");
                    Monitor.Exit(rampLockObj);
                }

            }
            else
            {
                //lock not obtained for this timer.
                Logger.WriteInternalLogFile("X-ray power ramp, lock not obtained for this timer....");

            }

        }
        */


        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private System.Timers.Timer StartPumpTimer()
        {

            pumpStartCounter = 0;
            var PumpTimer = new System.Timers.Timer(1000);
            PumpTimer.Elapsed += new ElapsedEventHandler(onPumpTimedEvent);
            
            //PumpTimer.Priority = ThreadPriority.AboveNormal;
            //thread2.Name = "ThreadTwo";
            //thread2.Priority = ThreadPriority.BelowNormal;
            //Thread thread3 = new Thread(priorityTest.ThreadMethod);
            PumpTimer.Enabled = true;
            return PumpTimer;

        }
        public void processPumpErrorValue(string value)
        {

            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processPumpErrorValue), new object[] { value });
                return;
            }

            //todo
            mtbPumpError.Text = value;
            //
        }
        public void processFlowValue(string value)
        {

            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processFlowValue), new object[] { value });
                return;
            }

            //todo
            //tbFlow.Text = value;

        }
        public void processPumpFlowValue(string value)
        {

            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processPumpFlowValue), new object[] { value });
                return;
            }

            //todo
            //tbPumpProcessFlow.Text = value;
        }

        public void processOutputValue(string svalue)
        {


            try
            {


                if (InvokeRequired)
                {
                    this.Invoke(new Action<string>(processOutputValue), new object[] { svalue });
                    return;
                }

                //todo
                //mtbPumpRunPercent.Text = string.Empty;
                mtbPumpRunPercent.Text = svalue;
            }
            catch (Exception Ex)
            {

            }






            /*
                        double value=0.0;
                        double percent = 0.0;

                        string outputstring = string.Empty;

                        try
                        {
                            bool result = Double.TryParse(svalue, out value);
                            if (result == true)
                            {
                                percent = (value / 5.0) * 100;
                            }
                            else
                            {
                                percent = -1;
                            }

                            int ipercent = (int)percent;

                            outputstring = String.Format("{0:000}", ipercent);
                            if(InvokeRequired)
                            {
                                this.Invoke(new Action<string>(processOutputValue), new object[] { outputstring });
                                return;
                            }

                            //todo
                            mtbPumpRunPercent.Text = string.Empty;
                            mtbPumpRunPercent.Text = outputstring;
                        }
                        catch (Exception Ex)
                        {

                        }
            */
        }

        public void processFlow25(string value)
        {
            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processFlow25), new object[] { value });
                return;
            }

            //todo
            mtbFlow25.Text = value;

        }
        public void processFlow25System(string value)
        {
            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processFlow25System), new object[] { value });
                return;
            }

            //todo
            mtbFlow25System.Text = value;

        }


        public void processuFlowActAmb(string value)
        {
            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processuFlowActAmb), new object[] { value });
                return;
            }

            //todo
            tbuFlowActAmb.Text = value;

        }


        public void processFlowStd(string value)
        {
            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processFlowStd), new object[] { value });
                return;
            }

            //todo
            mtbFlowStd.Text = value;

        }
        public void processFlowStdSystem(string value)
        {
            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processFlowStdSystem), new object[] { value });
                return;
            }

            //todo
            mtbFlowStdSystem.Text = value;

        }




        public void processFlowAct(string value)
        {
            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processFlowAct), new object[] { value });
                return;
            }

            //todo
            mtbFlowAct.Text = value;

        }
        public void processFlowActSystem(string value)
        {
            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processFlowActSystem), new object[] { value });
                return;
            }

            //todo
            mtbFlowActSystem.Text = value;

        }




        /// <summary>
        /// Sets up timer to periodically call acquisition control logic every 1 second
        /// preforms control tasks and interacts with other threads: pump, ramp, and GUI, also interacts with cross via com interface for c# via translation utility to create dll from comm object.
        /// 
        /// </summary>
        private System.Timers.Timer StartAcqTimer()
        {
            var acqTimer = new System.Timers.Timer(1000);
            // Hook up the Elapsed event for the timer.
            acqTimer.Elapsed += new ElapsedEventHandler(onAcqTimedEvent);
            acqTimer.Enabled = true;
            return acqTimer;
        }


        /// <summary>
        /// ecal timer called against the ecal background worker thread
        /// </summary>
        /// <returns></returns>
        private System.Timers.Timer StartEcalTimer()
        {
            var EcalTimer = new System.Timers.Timer(1000);
            // Hook up the Elapsed event for the timer.
            EcalTimer.Elapsed += new ElapsedEventHandler(onEcalTimedEvent);
            EcalTimer.Enabled = true;
            return EcalTimer;
        }

        /// <summary>
        /// upscale timer called against the upscale background worker thread
        /// </summary>
        /// <returns></returns>
        private System.Timers.Timer StartUpscaleTimer()
        {
            var UpscaleTimer = new System.Timers.Timer(1000);
            // Hook up the Elapsed event for the timer.
            UpscaleTimer.Elapsed += new ElapsedEventHandler(onUpscaleTimedEvent);
            UpscaleTimer.Enabled = true;
            return UpscaleTimer;
        }

        /// <summary>
        /// upscale timer called against the upscale background worker thread
        /// </summary>
        /// <returns></returns>
        private System.Timers.Timer StartManualAcqTimer()
        {
            var ManualAcqTimer = new System.Timers.Timer(1000);
            // Hook up the Elapsed event for the timer.
            ManualAcqTimer.Elapsed += new ElapsedEventHandler(onManualAcqTimedEvent);
            ManualAcqTimer.Enabled = true;
            return ManualAcqTimer;
        }


        /// <summary>
        /// leak check timer called against the leak check background worker thread
        /// </summary>
        /// <returns></returns>
        private System.Timers.Timer StartLeakCheckTimer()
        {
            var LeakCheckTimer = new System.Timers.Timer(1000);
            // Hook up the Elapsed event for the timer.
            LeakCheckTimer.Elapsed += new ElapsedEventHandler(onLeakCheckTimedEvent);
            LeakCheckTimer.Enabled = true;
            return LeakCheckTimer;
        }



        /// <summary>
        /// tube seasoning timer called against the tube seasoning background worker thread
        /// </summary>
        /// <returns></returns>
        private System.Timers.Timer StartTubeSeasoningTimer()
        {
            var TubeSeasoningTimer = new System.Timers.Timer(1000);
            // Hook up the Elapsed event for the timer.
            TubeSeasoningTimer.Elapsed += new ElapsedEventHandler(onTubeSeasoningTimedEvent);
            TubeSeasoningTimer.Enabled = true;
            return TubeSeasoningTimer;
        }

        /// <summary>
        /// One seconds timer called against the 'Five Minute' background worker thread
        /// </summary>
        /// <returns></returns>
        private System.Timers.Timer StartFiveMinuteTimer()
        {
            var FiveMinuteTimer = new System.Timers.Timer(1000);
            // Hook up the Elapsed event for the timer.
            FiveMinuteTimer.Elapsed += new ElapsedEventHandler(onFiveMinuteTimedEvent);
            FiveMinuteTimer.Enabled = true;
            return FiveMinuteTimer;
        }







        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void ReadInputTimer_Tick(object sender, EventArgs e)  //timer tick 1/4 sec
        {
            //Logger.WriteErr
            //Stopwatch sw = new Stopwatch();
            //sw.Start();

            double relativeHumV = 0.00;
            double sampleT = 0.00;

            if (Monitor.TryEnter(lockTimerObj))
            {

                try
                {
                    readTimerLockedCounter = 0;
                    readInputTimerCounter++;

                    if (waiting == 1)
                    {
                        waitingCounter++;
                        if (waitingCounter == (5 * 4))
                        {
                            waiting = 0;
                            waitingCounter = 0;
                        }
                    }


                    //read hardware from this thread:    
                    double presentV = 0.0;

                    presentV = ReadInputVoltage();
                    readInputVoltage = presentV;
                    presentV = (presentV * 5.0);//(presentV * 50.0 / 10.0);


                    if (presentV < 3)
                    {
                        presentV = 0.0;
                    }


                    double presentI = 0.0;
                    presentI = ReadInputCurrent();
                    readInputCurrent = presentI;

                    presentI = (presentI * 200.0);//(presentI * 2000.0 / 10.0);

                    if (presentI < 90)
                    {
                        presentI = 0.0;
                    }


                    //leak check on
                    if (leakCheckActive == 1 && readInputTimerCounter % 2 == 0)
                    {
                        //Logger.WriteInternalLogFile("A start");
                        readOnlySamplePressureValue = ReadOnlySamplePressure();
                        //Logger.WriteInternalLogFile("A end");

                    }
                    else if (readInputTimerCounter == 4)
                    {
                        //temp test: remove the read only sample pressure unless leak check is 'active'
                        readOnlySamplePressureValue = ReadOnlySamplePressure();

                    }

                    if (readInputTimerCounter % 4 == 0)
                    {
                        //Logger.WriteInternalLogFile("B start");
                        processInputCurrent(presentI.ToString("F2"));
                        processInputVoltage(presentV.ToString("F2"));
                        //Logger.WriteInternalLogFile("B end");
                        InterlockControlWatchdogToggle();   //toggle watchdog IO
                    }

                    if (readInputTimerCounter == 4)
                    {

                        //Logger.WriteInternalLogFile("C start");

                        flowSensorVoltage = InputAveraging(pumpStartCounter);


                        //check the passwordValid and check time
                        if (PassContainer.passwordValid == true)
                        {
                            if (PassContainer.enableOneTime == true)
                            {
                                //EnableDisableAllSettingsControls(true);
                                mbEnableDisableChanges.Enabled = true;

                                EnableDisableAllMaintenanceControls(true);


                                //EnableDisableAllFlowCalibrationControls(true);
                                mbEnableChangesCalFlow.Enabled = true;
                                PassContainer.enableOneTime = false;
                            }

                            //check the countdown
                            var TimeRemaining = PassContainer.pwEnd - System.DateTime.Now;

                            string msg;
                            msg = "Time Remaining PW = " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2");
                            if (TimeRemaining.Seconds % 10 == 0)
                            {
                                Logger.WriteInternalLogFile(msg);
                            }

                            if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
                            {
                                Logger.WriteInternalLogFile("Password timeout.");
                                PassContainer.passwordValid = false;
                                EnableDisableAllMaintenanceControls(false);
                                EnableDisableAllFlowCalibrationControls(false);
                                EnableDisableAllSettingsControls(false);

                            }
                        }

                        //Logger.WriteInternalLogFile("C end");

                    }
                    if (readInputTimerCounter == 8)
                    {

                        flowSensorVoltage = InputAveraging(pumpStartCounter);


                    }
                    if (readInputTimerCounter == 12)
                    {

                        flowSensorVoltage = InputAveraging(pumpStartCounter);

                        ReadTubeTemp();          //bhcop1

                        ReadEnclosureTemp();      //bhcop2

                        ReadAmbientTemp();        //bhcop3

                        //sample temp value is used in the RH calculation below:
                        sampleT = ReadSampleTemp();  //bhcop4

                        ReadAtmPress();  //bhcop5

                        ReadFilamentMonitor();     //bhcop6

                        relativeHumV = ReadRelativeHumidity();

                        ReadSamplePressure();

                        //calculate true RH:
                        double trueRH = ((relativeHumV / 5.0) - 0.16) / (0.0062 * (1.0546 - (0.00216 * sampleT)));

                        //for sensors arriving 02.17.2020
                        //sensor RH = ((V -0.825 )/0.03) 
                        //log new sensor data:
                        //
                        double newRH = (relativeHumV - 0.825) / 0.03;

                        //Logger.WriteInternalLogFile("for test: RH       = " + trueRH.ToString("F4"));
                        //Logger.WriteInternalLogFile("for test: RH value = " + newRH.ToString("F4"));



                        relativeHumidityStatic = Math.Round(trueRH, 0, MidpointRounding.AwayFromZero);

                        //display data
                        processRelativeHumidityValue(trueRH.ToString("F2"));

                        int value = Properties.Settings.Default.InletHeater;
                        if (trueRH >= Properties.Settings.Default.InletHeater && mbRun.Text == "Stop")   // run is active -- over ride manual dialog
                        {

                            //ON
                            DigitalSingleChannelWriter Port30writerOut = new DigitalSingleChannelWriter(InletHeaterOutput.Stream);
#if TURNON_NIHARDWARE
                            Port30writerOut.WriteSingleSampleSingleLine(true, true);
#endif
                        }
                        else if (trueRH <= (Properties.Settings.Default.InletHeater - 2) && mbRun.Text == "Stop")  // run is active -- over ride manual dialog
                        {
                            //OFF
                            DigitalSingleChannelWriter Port30writerOff = new DigitalSingleChannelWriter(InletHeaterOutput.Stream);
#if TURNON_NIHARDWARE
                            Port30writerOff.WriteSingleSampleSingleLine(true, false);
#endif
                        }


                        //////////////////////////////////////////////
                        // for testing:  read LL inputs continuously for display purposes
                        //ReadFWLLHome();
                        // note:  this causes a problem with normal acquisition serial port comm with ez4axis
                        /////////////////////////////////////////////

                        //Logger.WriteInternalLogFile("E end");

                    }
                    else if (readInputTimerCounter >= 16)
                    {

                        double SDDTemp = ReadSDDTemp();
                        sDDTempStatic = Math.Round(SDDTemp, 2, MidpointRounding.AwayFromZero);
                        processSDDTempValue(SDDTemp.ToString("F2"));

                        double DPPTemp = ReadDPPTemp();
                        dPPTempStatic = Math.Round(DPPTemp, 2, MidpointRounding.AwayFromZero);

                        processDPPTempValue(DPPTemp.ToString("F2"));


                        readInputTimerCounter = 0;
                        ushort[] rTC = new ushort[6];
                        rTC = nModbusOperations.ModbusDateTimeArrayFromDTNow(DateTime.Now);

                        AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                        DataStore dataStoreLive = AcquisitionControl.getDataStore();

                        nModbusOperations.updateModbusSlaveRegisters(dataStoreLive, rTC, 810);



                        double flowVol = AcquisitionControl.GetFlowVolume();
                        //Logger.WriteLogFile(   "flow Vol = " + flowVol.ToString("F3"));
                        volumeStatic = Math.Round(flowVol, 2, MidpointRounding.AwayFromZero);
                        processVolumeTempValue(volumeStatic.ToString("F2"));

                        //update modbus real time (instantaneous) info here:
                        List<double> listData = new List<double>();

                        listData = CaptureInstantSystemValues();
                        ushort[] systemValues = new ushort[78];
                        systemValues = nModbusOperations.ModbusTelemetryArrayLiveData(listData);
                        nModbusOperations.updateModbusSlaveRegisters(dataStoreLive, systemValues, 817);




                    }



                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Ex in input timer:  " + Ex.ToString());
                }
                finally
                {
                    //Logger.WriteLogFile("c:/temp/inputtimer.txt", "Done with timer task.");
                    Monitor.Exit(lockTimerObj);

                }

            }
            else
            {
                readTimerLockedCounter++;
                //lock not obtained for this timer.
                if (readTimerLockedCounter > 50)
                {
                    Logger.WriteInternalLogFile("Error: lock not obtained for input read timer before timer called.");
                }
            


            }

            //sw.Stop();
            //string ExecutionTimeTaken = string.Format("TOTAL:  Seconds :{0} Mili seconds :{1}", sw.Elapsed.Seconds, sw.Elapsed.TotalMilliseconds);
            //Logger.WriteInternalLogFile("Timer execution:  " + ExecutionTimeTaken);
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void ToggleInterlockTimer_Tick(object sender, EventArgs e)
        {

            if (Monitor.TryEnter(lockToggleInterlockTimerObj))
            {

                InterlockTimerCounter = 0;
                bool currentLow;
                bool voltageLow;
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;


                try
                {
                    //check the ramp up active



                    //readInputTimerCounter++;


                    //read kV input
                    //read uA input
                    //if both are LOW, then toggle interlock ....

                    //presentV = ReadInputVoltage();



                    if(readInputVoltage < 1.5)
                    {
                        voltageLow = true;

                    }
                    else
                    {
                        voltageLow = false;
                    }
                    if(readInputCurrent <1.5)
                    {
                        currentLow = true;

                    }
                    else
                    {
                        currentLow = false;
                    }

                    if(xrayOnCommand==1)
                    {
                        xrayOnCommandCounter++;
                        if(xrayOnCommandCounter>=30)
                        {
                            xrayOnCommandCounter = 30;
                        }
                    }
                    else
                    {
                        xrayOnCommandCounter = 0;
                    }
                    if(xrayRampCommandActive==0)
                    {
                        xrayOnCommandCounter+=5 ;                        
                    }


                    if(currentLow==true && voltageLow==true && xrayOnCommand==1 && xrayOnCommandCounter>=30 && xrayCommandActive==0)
                    {
                        //toggle interlock here
                        if(toggleInterlockTimerCounter==1)
                        {
                            //turn ON
                            AcquisitionControl.InterlockClose(this);
                            toggleInterlockTimerCounter = 0;
                        }
                        else
                        {
                            //turn OFF

                          AcquisitionControl.InterlockOpen(this);
                          toggleInterlockTimerCounter = 1;
                        }


                    }
                    else if(currentLow == true && voltageLow == true && xrayCommandActive ==1 && xrayOnCommandCounter>10)
                    {
                        //check interlock!
                        if (mtbInterlockStatus.InvokeRequired)
                        {
                            mtbInterlockStatus.Invoke(new MethodInvoker(delegate { mtbInterlockStatus.Text = "Check Interlock"; }));
                            //f.mtbInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbInterlockStatus.Refresh(); }));

                            //f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Text = "OFF"; }));
                            //f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Refresh(); }));
                        }
                        else
                        {
                            mtbInterlockStatus.Text = "Check Interlock";
                            //f.mtbInterlockStatus.Refresh();
                            //f.mtbStatusXrayStatus.Text = "OFF";
                            //f.mtbStatusXrayStatus.Refresh();
                        }

                        if (mtbMaintInterlockStatus.InvokeRequired)
                        {
                            mtbMaintInterlockStatus.Invoke(new MethodInvoker(delegate { mtbMaintInterlockStatus.Text = "Check Interlock"; }));
                            mtbMaintInterlockStatus.Invoke(new MethodInvoker(delegate { mtbMaintInterlockStatus.Refresh(); }));
                        }
                        else
                        {
                            mtbMaintInterlockStatus.Text = "Check Interlock";
                            mtbMaintInterlockStatus.Refresh();
                        }



                    }

                    //                            DigitalSingleChannelWriter Port30writerOut = new DigitalSingleChannelWriter(InletHeaterOutput.Stream);
                    //#if TURNON_NIHARDWARE
                    //                            Port30writerOut.WriteSingleSampleSingleLine(true, true);
                    //#endif


                    //                    DigitalSingleChannelWriter Port30writerOff = new DigitalSingleChannelWriter(InletHeaterOutput.Stream);
                    //#if TURNON_NIHARDWARE
                    //                    Port30writerOff.WriteSingleSampleSingleLine(true, false);
                    //#endif







                    //}
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Ex in toggle interlock timer:  " + Ex.ToString());
                }
                finally
                {
                    //Logger.WriteLogFile("c:/temp/inputtimer.txt", "Done with timer task.");
                    Monitor.Exit(lockToggleInterlockTimerObj);

                }

            }
            else
            {
                InterlockTimerCounter++;
                if (InterlockTimerCounter > 50)
                {
                    //lock not obtained for this timer.
                    Logger.WriteInternalLogFile("Error: lock not obtained for Toggle Interlock timer before timer called.");
                }

            }
        }




        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void ReadInputWindSpeedTimer_Tick(object sender, EventArgs e)
        {
            //every ___ seconds read input and make requests and get response 

            //perform timed serial transactions with the wind speed and direction sensor and save the data to 
            //file and to data set for display to modbus and adapt

            if (Monitor.TryEnter(lockWindSpeedTimerObj))
            {
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                string windSpeed = String.Empty;
                string windDirection = String.Empty;
                try
                {

                    int retVal = AcquisitionControl.GetWindSpeedandDirection(SerialWindSpeedandDirManager, out windSpeed, out windDirection);
                    if (retVal == PASS && windSpeedAndDirResponseCounter >= 2)
                    {
                        windSpeedAndDirResponseCounter = 0;
                        UpdateWindSpeed(windSpeed);
                        UpdateWindDir(windDirection);
                    }
                    else if (retVal ==FAIL)
                    {
                        UpdateWindDir(windDirection);
                        UpdateWindSpeed(windSpeed);
                    }

                }
                catch (Exception )
                {
                    //Logger.WriteLogFile(   "Exception in  WindSpeed timer.  Ex = " + Ex.ToString());

                }
                finally
                {
                    //Logger.WriteLogFile("c:/temp/WindSpeed.txt", "@finally. Done with timer logic.");
                    Monitor.Exit(lockWindSpeedTimerObj);
                }

            }
            else
            {
                Logger.WriteLogFile(   "WindSpeedLockNotObtained for this timer.");

            }
        }

        /// <summary>
        /// Monitors Error list for new error and displays and takes action.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void errorMonitorTimer_Tick(object sender, EventArgs e)
        {

            //monitor for errors
            //check error variable.

            //systemError. // = new List<int>();   //if error occurs set here for logging and display and action


            //display status
            //tbmetroStatus.Text = "ok";


            // controlled shut down instrument if running

            //ramp to zero

            //pump off
            //abort xrsfp acquisition
            //


            //take action

            //log actions

            //email actions





        }


        private void WriteOutputVoltage(double outputVoltage)
        {
#if TURNON_NIHARDWARE
            //this is the HVPS voltage
            int writeOk = 0;
            int counter = 0;
            do
            {
                try
                {

                    if(outputVoltage<0)
                    {
                        outputVoltage = 0.0;
                        Logger.WriteInternalLogFile("Write Output Voltage = " + outputVoltage.ToString() + " changed to 0.0");
                    }


                    AnalogSingleChannelWriter HVPSVoltageOutput = new AnalogSingleChannelWriter(OutputVoltage.Stream);
                    HVPSVoltageOutput.WriteSingleSample(true, outputVoltage);
                    writeOk = 1;

                }
                catch (Exception e)
                {
                    Logger.WriteInternalLogFile("Error: hvps Voltage output " + e.ToString());
                    Logger.WriteInternalLogFile("hvps read counter = " + counter.ToString());
                    counter += 1;

                }
            } while (writeOk == 0 && counter < 10);


#endif


        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="outputCurrent"></param>
        private void WriteOutputCurrent(double outputCurrent)
        {
#if TURNON_NIHARDWARE
            //this is the HVPS current
            int writeOk = 0;
            int counter = 0;
            do
            {
                if(outputCurrent<0)
                {
                    outputCurrent = 0;
                    Logger.WriteInternalLogFile("Write Output Current = " + outputCurrent.ToString() + " changed to 0.0");
                }

                try
                {
                    AnalogSingleChannelWriter HVPSCurrentOutput = new AnalogSingleChannelWriter(OutputCurrent.Stream);
                    HVPSCurrentOutput.WriteSingleSample(true, outputCurrent);
                    writeOk = 1;
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Exception in HVPS output current.  Ex = "+Ex.ToString());
                    counter += 1;
                }
            } while (writeOk == 0 && counter < 10);
            if (counter >= 10)
            {
                ////''ErrorFile.WriteLine("  EXCEPTION HVPS current output   ", e.ToString());
                Logger.WriteInternalLogFile("Error: HVPS current output.");
                ////ErrorFile.WriteLine(" counter = ", counter.ToString());
                //Logger.WriteErrorFile(" counter = " + counter.ToString());
                //counter += 1;
            }

#endif

        }


        /// <summary>
        /// begins the read of feedback and PID output for pump control
        /// </summary>
        /// <param name="source"></param>
        /// <param name="e"></param>
        /// NOTE update to include read of temp and pressure via static variables 
        /// so as to not use invoke to pull data from the GUI
        private void onPumpTimedEvent(object source, ElapsedEventArgs e)
        {
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            



            if (Monitor.TryEnter(pumpLockObj) && m_oWorkerPump.CancellationPending == false)
            {

                try
                {
                    AcquisitionControl.SetPumpLockCounter(0);

                    //Logger.WriteLogFile( "PumpTimer START","c:/temp/pumpdata2.txt");

                    int pumpcounter;  //state machine for flow calibration

                    //get the flow cal or leak check input
                    System.Windows.Forms.CheckState checkState = System.Windows.Forms.CheckState.Unchecked;
                    System.Windows.Forms.CheckState checkStateLeakCheck = System.Windows.Forms.CheckState.Unchecked;

                    if (metroToggleFlowCal.InvokeRequired)
                    {
                        metroToggleFlowCal.Invoke(new MethodInvoker(delegate { checkState = metroToggleFlowCal.CheckState; }));
                    }
                    else
                    {
                        checkState = metroToggleFlowCal.CheckState;
                    }



                    if (metroToggleLeakCheck.InvokeRequired)
                    {
                        metroToggleLeakCheck.Invoke(new MethodInvoker(delegate { checkStateLeakCheck = metroToggleLeakCheck.CheckState; }));
                    }
                    else
                    {
                        checkStateLeakCheck = metroToggleLeakCheck.CheckState;
                    }





                    //only do a flow cal if NOT doing a leak check:
                    if (checkState == System.Windows.Forms.CheckState.Checked && checkStateLeakCheck == System.Windows.Forms.CheckState.Unchecked)
                    {

                        pumpcounter = AcquisitionControl.GetPumpCounter();  //updated to pump counter

                        if (pumpcounter == 0)
                        {

                            flowCalCompleted = 0;
                            flowCalStarted = 1;
                            SaveExistingParameters(Properties.Settings.Default.TnistCalAdj, Properties.Settings.Default.PnistCalAdj,Properties.Settings.Default.PSnistCalAdj,Properties.Settings.Default.yint, Properties.Settings.Default.slope, Properties.Settings.Default.NormalFlow);

                            

                            Properties.Settings.Default.TnistCalAdj = 0;
                            Properties.Settings.Default.PnistCalAdj = 0;
                            Properties.Settings.Default.PSnistCalAdj = 0;

                            Properties.Settings.Default.yint = 0.1;
                            Properties.Settings.Default.slope = 0.99;

                            double tnistCA = Properties.Settings.Default.TnistCalAdj;
                            double pnistCA = Properties.Settings.Default.PnistCalAdj;
                            double psnistCA = Properties.Settings.Default.PSnistCalAdj;

                            double yintValue = Properties.Settings.Default.yint;
                            double slopeValue = Properties.Settings.Default.slope;

                            Logger.WriteLogFile( "START FLOW CALIBRATION", "C:/temp/CalValues.txt");
                            Logger.WriteLogFile( "tnistcal adj = " + tnistCA.ToString("F2"), "C:/temp/CalValues.txt");
                            Logger.WriteLogFile("pnistcal adj = " + pnistCA.ToString("F2"), "C:/temp/CalValues.txt" );
                            Logger.WriteLogFile( "psnistcal adj = " + psnistCA.ToString("F2"), "C:/temp/CalValues.txt");
                            Logger.WriteLogFile( "yint = " + yintValue.ToString("F2"), "C:/temp/CalValues.txt");
                            Logger.WriteLogFile( "slope = " + slopeValue.ToString("F2"), "C:/temp/CalValues.txt");





                            //Properties.Settings.Default.Save();
                            if (tbMetroCalPrompt.InvokeRequired)
                            {
                                tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "FLOW CALIBRATION."; }));
                            }
                            else
                            {
                                tbMetroCalPrompt.Text = "FLOW CALIBRATION.";
                            }

                            //while it is possible to do this here, a separate cal for sample pressure appears to be a better solution
                            //if (tbMetroCalPrompt.InvokeRequired)
                            //{
                            //    tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "Setting pump output to zero."; }));
                            //}
                            //else
                            //{
                            //    tbMetroCalPrompt.Text = "Setting pump output to zero.";
                            //}


                            //PumpSetPoint = 0;


                            Thread.Sleep(2000);
                            AcquisitionControl.SetPumpCounter(1);
                           
                        }
                        else if (pumpcounter == 1)
                        {
                            if (tbMetroCalPrompt.InvokeRequired)
                            {
                                tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "Enter Tnist (from meter)"; }));
                            }
                            else
                            {
                                tbMetroCalPrompt.Text = "Enter Tnist (from meter)";
                            }

                            if (tbMetroCalEntry.InvokeRequired)
                            {
                                //set:
                                //Properties.Settings.Default.Tnist= "abc";
                                //Properties.Settings.Default.Save();
                                //string Tnistkey = ConfigurationManager.AppSettings["Tnist"];
                                //string keyvalue = System.Configuration.ConfigurationManager.AppSettings["keyname"];
                                //Now access the Setting class via Properties:



                                //set:
                                //Properties.Settings.Default.Tnist= "abc";
                                //Properties.Settings.Default.Save();

                                //get:
                                double Tnistvalue = Properties.Settings.Default.Tnist;
                                tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Text = Tnistvalue.ToString(); }));

                            }
                            else
                            {
                                double Tnistvalue = Properties.Settings.Default.Tnist;
                                tbMetroCalEntry.Text = Tnistvalue.ToString();

                            }
                            AcquisitionControl.SetPumpCounter(2);
                        }
                        else if (pumpcounter == 2)
                        {

                            if (bMetroEnterDataButton.InvokeRequired)
                            {
                                if (enterDataButtonClicked == true)
                                {
                                    //save the tnist value:
                                    enterDataButtonClicked = false;

                                    if (tbMetroCalPrompt.InvokeRequired)
                                    {
                                        string value;
                                        tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { value = tbMetroCalEntry.Text; }));
                                        tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "Enter Tnist (from meter)"; }));

                                    }
                                    if (tbMetroCalEntry.InvokeRequired)
                                    {

                                        tbMetroCalEntry.Invoke(new MethodInvoker(delegate { Tnistvalue = tbMetroCalEntry.Text; }));
                                        double dTnistvalue = Properties.Settings.Default.Tnist = Convert.ToDouble(Tnistvalue);

                                        double tAmbient = Convert.ToDouble(tbMetroAmbientTempCal.Text);


                                        double tCalAdj = tAmbient - dTnistvalue;
                                        Properties.Settings.Default.TnistCalAdj = tCalAdj;
                                        Properties.Settings.Default.Save();
                                    }


                                    AcquisitionControl.SetPumpCounter(3);
                                }
                            }
                        }
                        else if (pumpcounter == 3)
                        {
                            if (tbMetroCalPrompt.InvokeRequired)
                            {
                                tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "Enter Pnist (from meter)"; }));
                            }

                            if (tbMetroCalEntry.InvokeRequired)
                            {

                                //get:
                                double Pnistvalue = Properties.Settings.Default.Pnist;
                                tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Text = Pnistvalue.ToString(); }));

                            }

                            AcquisitionControl.SetPumpCounter(4);

                        }
                        else if (pumpcounter == 4)
                        {
                            if (bMetroEnterDataButton.InvokeRequired)
                            {
                                if (enterDataButtonClicked == true)
                                {
                                    //save the tnist value:
                                    enterDataButtonClicked = false;

                                    if (tbMetroCalPrompt.InvokeRequired)
                                    {
                                        string value;
                                        tbMetroCalEntry.Invoke(new MethodInvoker(delegate { value = tbMetroCalEntry.Text; }));

                                    }
                                    if (tbMetroCalEntry.InvokeRequired)
                                    {

                                        tbMetroCalEntry.Invoke(new MethodInvoker(delegate { Pnistvalue = tbMetroCalEntry.Text; }));
                                        Properties.Settings.Default.Pnist = Convert.ToDouble(Pnistvalue);

                                        string AtmPress = "";
                                        double dAtmPress;

                                        string SamPress = "";
                                        //double dSamPress;

                                        double dPnistvalue = Convert.ToDouble(Pnistvalue);
                                        //double PnistCalAdj;

                                        tbMetroAtmPressureCal.Invoke(new MethodInvoker(delegate { AtmPress = tbMetroAtmPressureCal.Text; }));  //read in the sensor value

                                        tbMetroSamplePressureCal.Invoke(new MethodInvoker(delegate { SamPress = tbMetroSamplePressureCal.Text; }));  //read in the sensor value

                                        double dPnistCalAdj = 0.0;
                                        //double dPSnistCalAdj = 0.0;

                                        dAtmPress = Convert.ToDouble(AtmPress);
                                        dPnistCalAdj = dAtmPress - dPnistvalue;       //adj = total - meter    

                                        Properties.Settings.Default.PnistCalAdj = dPnistCalAdj;
                                        Properties.Settings.Default.Save();

                                        //add sample pressure 
                                        //Properties.Settings.Default.PSnist = Convert.ToDouble(Pnistvalue);  //the read from the pressure meter

                                        //dSamPress = Convert.ToDouble(SamPress);

                                        //dPSnistCalAdj = (dSamPress - dPnistvalue);    //adj = total - meter

                                        //set this the same as the PnistCalAdj

                                        //for now make the PSnistCalAdj the same as the PnistCalAdj
                                        Properties.Settings.Default.PSnistCalAdj = dPnistCalAdj;
                                        Properties.Settings.Default.Save();


                                    }
                                    AcquisitionControl.SetPumpCounter(5);
                                }
                            }
                        }
                        else if (pumpcounter == 5)
                        {

                            if (tbMetroCalPrompt.InvokeRequired)
                            {
                                tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "Starting pump."; }));
                            }
                            rbMetro167.Invoke(new MethodInvoker(delegate { mrb167 = rbMetro167.Checked; }));
                            


                            //if (tbMetroCalPrompt.InvokeRequired)
                            //{
                            //    tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "Starting pump."; }));
                            //}



                            if (tbMetroCalPrompt.InvokeRequired)
                            {
                                tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "Setting Flow to MID range. Enter measured flow:  "; }));
                            }

                            if (tbMetroCalEntry.InvokeRequired)
                            {

                                //get:
                                flowPumpSetPoint = Properties.Settings.Default.NormalFlow;
                                PumpSetPoint = 4.00;  //guess for act flow at 16.7

                                //double Pnistvalue = Properties.Settings.Default.Pnist;
                                tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Text = "16.20"; }));
                            }
                            AcquisitionControl.SetPumpCounter(6);



                        }
                        else if (pumpcounter == 6)
                        {
                            if (bMetroEnterDataButton.InvokeRequired)
                            {
                                if (enterDataButtonClicked == true)
                                {
                                    //save the tnist value:
                                    enterDataButtonClicked = false;

                                    if (tbMetroCalEntry.InvokeRequired)
                                    {
                                        tbMetroCalEntry.Invoke(new MethodInvoker(delegate { sfNormalMeas = tbMetroCalEntry.Text; }));
                                        fNormalMeas = Convert.ToDouble(sfNormalMeas);


                                        tbuFlowActAmb.Invoke(new MethodInvoker(delegate { suflowActAmb_167 = tbuFlowActAmb.Text; }));

                                        uflowActAmb_167 = Convert.ToDouble(suflowActAmb_167);

                                        Properties.Settings.Default.uFlowActAmb_167 = uflowActAmb_167;

                                        Properties.Settings.Default.Save();



                                    }
                                    AcquisitionControl.SetPumpCounter(7);
                                }
                            }
                        }
                        else if (pumpcounter == 7)
                        {
                            if (tbMetroCalPrompt.InvokeRequired)
                            {
                                tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "Setting Flow to LOW range.  Enter measured flow:  "; }));
                            }

                            if (tbMetroCalEntry.InvokeRequired)
                            {
                                flowPumpSetPoint = Properties.Settings.Default.LowFlow;
                                PumpSetPoint = 3.68;  //flow act  guess @ 15

                                tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Text = "14.40"; }));

                            }
                            AcquisitionControl.SetPumpCounter(8);



                        }

                        else if (pumpcounter == 8)
                        {
                            if (bMetroEnterDataButton.InvokeRequired)
                            {
                                if (enterDataButtonClicked == true)
                                {
                                    //save the tnist value:
                                    enterDataButtonClicked = false;

                                    if (tbMetroCalEntry.InvokeRequired)
                                    {
                                        tbMetroCalEntry.Invoke(new MethodInvoker(delegate { sfLowMeas = tbMetroCalEntry.Text; }));
                                        fLowMeas = Convert.ToDouble(sfLowMeas);


                                        tbuFlowActAmb.Invoke(new MethodInvoker(delegate { suflowActAmb_150 = tbuFlowActAmb.Text; }));
                                        uflowActAmb_150 = Convert.ToDouble(suflowActAmb_150);


                                        Properties.Settings.Default.uFlowActAmb_150 = uflowActAmb_150;

                                        Properties.Settings.Default.Save();



                                    }
                                    AcquisitionControl.SetPumpCounter(9);
                                }
                            }



                        }

                        else if (pumpcounter == 9)
                        {
                            if (tbMetroCalPrompt.InvokeRequired)
                            {
                                tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "Setting Flow to HI range.  Enter measured flow:  "; }));
                            }

                            if (tbMetroCalEntry.InvokeRequired)
                            {
                                flowPumpSetPoint = Properties.Settings.Default.HighFlow;
                                PumpSetPoint = 4.32;  //initial guess act flow for 18.4

                                Properties.Settings.Default.Save();

                                tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Text = "17.90"; }));

                            }
                            AcquisitionControl.SetPumpCounter(10);
                        }
                        else if (pumpcounter == 10)
                        {
                            if (bMetroEnterDataButton.InvokeRequired)
                            {
                                if (enterDataButtonClicked == true)
                                {
                                    //save the tnist value:
                                    enterDataButtonClicked = false;

                                    if (tbMetroCalEntry.InvokeRequired)
                                    {
                                        tbMetroCalEntry.Invoke(new MethodInvoker(delegate { sfHiMeas = tbMetroCalEntry.Text; }));
                                        fHiMeas = Convert.ToDouble(sfHiMeas);

                                        tbuFlowActAmb.Invoke(new MethodInvoker(delegate { suflowActAmb_184 = tbuFlowActAmb.Text; }));

                                        uflowActAmb_184 = Convert.ToDouble(suflowActAmb_184);

                                        Properties.Settings.Default.uFlowActAmb_184 = uflowActAmb_184;

                                        Properties.Settings.Default.Save();




                                    }
                                    AcquisitionControl.SetPumpCounter(11);

                                }


                            }


                        }
                        else if (pumpcounter == 11)
                        {

                            tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Text = ""; }));
                            AcquisitionControl.SetPumpCounter(12);

                        }
                        else if (pumpcounter == 12)
                        {
                            tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "Calculating ....."; }));
                            Regression regression = new Regression();
                            double[] xVals = new double[3];
                            double[] yVals = new double[3];
                            double yint = 0.00;
                            double rsquared = 0.00;
                            double slope = 0.00;

                            xVals[0] = Properties.Settings.Default.uFlowActAmb_150;             // uncalibrated actaul flow uflowACT --              //flow value low
                            xVals[1] = Properties.Settings.Default.uFlowActAmb_167;             //flow value normal
                            xVals[2] = Properties.Settings.Default.uFlowActAmb_184;             //flow value hi

                            yVals[0] = fLowMeas;        //measured flow low    (you enter the flow ACTUAL from the meter)
                            yVals[1] = fNormalMeas;     //measured flow normal (you enter the flow ACTUAL from the meter)
                            yVals[2] = fHiMeas;         //measured flow hi     (you enter the flow ACTUAL from the meter)

                            regression.LinearRegression(xVals, yVals, 0, 3, out rsquared, out yint, out slope);
                            //16.70 = slope*x+yint
                            //16.70-yint = slope*x
                            //(16.70-yint)/slope = x

                            double AT = ambientTempStatic;//Convert.ToDouble(tbMetroAmbientTempCal.Text);
                            double BP = ambientPressureStatic;// Convert.ToDouble(tbMetroAtmPressureCal.Text);


                            flowPumpSetPoint = (16.70 - yint) / slope;  


                            PumpSetPoint = (flowPumpSetPoint - yint) * (((273.15) / (273.15 + AT)) * (760.0 / BP) * (1 / (5 * slope))) + 1;

                            Properties.Settings.Default.NormalFlow = PumpSetPoint;


                            Properties.Settings.Default.yint = yint;
                            Properties.Settings.Default.slope = slope;
                            Properties.Settings.Default.Save();
                           

                            Logger.WriteLogFile("END FLOW CALIBRATION", "C:/temp/CalValues.txt");
                            Logger.WriteLogFile( "tnistcal adj = " + Properties.Settings.Default.TnistCalAdj.ToString("F2"), "C:/temp/CalValues.txt");
                            Logger.WriteLogFile("pnistcal adj = " + Properties.Settings.Default.PnistCalAdj.ToString("F2"), "C:/temp/CalValues.txt" );
                            Logger.WriteLogFile( "yint = " + Properties.Settings.Default.yint.ToString("F2"), "C:/temp/CalValues.txt" );
                            Logger.WriteLogFile( "slope = " + Properties.Settings.Default.slope.ToString("F2"), "C:/temp/CalValues.txt" );
                            Logger.WriteLogFile( "rsquared = " + rsquared.ToString("F2"), "C:/temp/CalValues.txt");


                            tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "rsq = " + rsquared.ToString("F2") + " yint = " + yint.ToString("F3") + " slope = " + slope.ToString("F2") + " psp = " + PumpSetPoint.ToString("F2"); }));
                            AcquisitionControl.SetPumpCounter(13);

                        }
                        else if (pumpcounter == 13)
                        {
                            //turn off calibration.... switch
                            //via invoke
                            //reset other variables

                            //PumpSetPoint = Properties.Settings.Default.NormalFlow;
                            PumpSetPoint = Properties.Settings.Default.RunModeFlow;

                            //tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "Setting Flow to Normal (16.7L/m).  Turning off Flow Calibration. "; }));
                            tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "Setting Flow to Normal = " + Properties.Settings.Default.RunModeFlow.ToString("F2") + " Turning off Flow Calibration. "; }));



                            flowCalCompleted = 1;

                            if (metroToggleFlowCal.InvokeRequired)
                            {
                                metroToggleFlowCal.Invoke(new MethodInvoker(delegate { metroToggleFlowCal.CheckState = System.Windows.Forms.CheckState.Unchecked; }));
                            }
                            else
                            {
                                metroToggleFlowCal.CheckState = System.Windows.Forms.CheckState.Unchecked;
                            }

                        }
                    }


                    //
                    //
                    //
                    //if(flowCalCompleted==0 && flowCalStarted ==1)
                    //{
                    //    double Tnist;
                    //    double Pnist;
                    //    double PSnist;
                    //    double yint;
                    //    double slope;
                    //    double NormalFlow;

                    //    GetStoredFlowParameters(out Tnist, out Pnist, out PSnist, out yint, out slope, out NormalFlow);
                    //    //restore the old values

                    //    Properties.Settings.Default.NormalFlow = NormalFlow;

                    //    Properties.Settings.Default.yint = yint;
                    //    Properties.Settings.Default.slope = slope;

                    //    Properties.Settings.Default.TnistCalAdj = Tnist;
                    //    Properties.Settings.Default.PnistCalAdj = Pnist;
                    //    Properties.Settings.Default.PSnistCalAdj = PSnist;

                    //    Properties.Settings.Default.Save();
                    //    flowCalStarted = 0;
                    //    flowCalCompleted = 0;

                    //}

                    //if(flowCalCompleted==1)
                    //{
                    //    flowCalCompleted = 0;
                    //}


                    else if (checkState == System.Windows.Forms.CheckState.Unchecked  && checkStateLeakCheck ==System.Windows.Forms.CheckState.Unchecked)
                    {
                        if(flowCalStarted==1 && flowCalCompleted==0)
                        {
                            //recover settings    

                            double TnistR;
                            double PnistR;
                            double PSnistR;
                            double yintR;
                            double slopeR;
                            double NormalFlowR;

                            GetStoredFlowParameters(out TnistR, out PnistR, out PSnistR, out yintR, out slopeR, out NormalFlowR);
                            //restore the old values

                            Properties.Settings.Default.NormalFlow = NormalFlowR;

                            Properties.Settings.Default.yint = yintR;
                            Properties.Settings.Default.slope = slopeR;

                            Properties.Settings.Default.TnistCalAdj = TnistR;
                            Properties.Settings.Default.PnistCalAdj = PnistR;
                            Properties.Settings.Default.PSnistCalAdj = PSnistR;

                            Properties.Settings.Default.Save();
                            flowCalStarted = 0;
                            flowCalCompleted = 0;
                        }
                        if(flowCalStarted==1 && flowCalCompleted==1)
                        {
                            flowCalStarted = 0;
                            flowCalCompleted = 0;
                            Properties.Settings.Default.Save();
                        }

                        AcquisitionControl.SetPumpCounter(0);   //reset the state machine counter in case you immediately do another flow calibration
                                                                //by setting the toggle to calibrate

                        double AT = ambientTempStatic; //Convert.ToDouble(tbMetroAmbientTempCal.Text);

                        double BP = ambientPressureStatic; //Convert.ToDouble(tbMetroAtmPressureCal.Text);


                        if (Properties.Settings.Default.FlowControl.Contains("Std"))
                        {
                            rbStandard = true;
                            rbActual = false;
                            if (tbMetroCalPrompt.InvokeRequired)
                            {
                                tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "Measuring Flow.  Controlling to Std"; }));
                            }

                        }
                        else if (Properties.Settings.Default.FlowControl.Contains("Act"))
                        {
                            rbActual = true;
                            rbStandard = false;
                            if (tbMetroCalPrompt.InvokeRequired)
                            {
                                tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "Measuring Flow.  Controlling to Act"; }));
                            }

                        }

                        double yint;
                        double slope;

                        if (mbRun.Text.Contains("Stop"))   //check the run button -- if it says STOP run at 16.7
                        {

                            yint = Properties.Settings.Default.yint;
                            slope = Properties.Settings.Default.slope;


                            flowPumpSetPoint = Properties.Settings.Default.RunModeFlow; //was 16.70;    //pump setpoint
                            //flowPumpSetPoint = 16.70;    //pump setpoint 48 change to parameterized value



                                if (rbActual == true)
                                {
                                    PumpSetPoint = ((flowPumpSetPoint - yint) * (((273.15) / (273.15 + AT)) * (BP / 760.0) * (1 / (5 * slope)))) + 1;
                                }
                                else if (rbStandard == true)
                                {
                                    PumpSetPoint = ((flowPumpSetPoint / (5.0 * slope)) * (273.15 / 298.15)) - ((yint) * (273.15 / (273.15 + AT) * (1 / (5.0 * slope)) * (BP / 760.0))) + 1;
                                }

                        }


                        else  //run at selected speed   instrument is stopped, may run at selected speed.
                        {


                            rbMetro150.Invoke(new MethodInvoker(delegate { mrb150 = rbMetro150.Checked; }));
                            yint = Properties.Settings.Default.yint;
                            slope = Properties.Settings.Default.slope;
                            if (mrb150 == true)
                            {


                                flowPumpSetPoint = 15.00;

                                if (rbActual == true)
                                {
                                    PumpSetPoint = ((flowPumpSetPoint - yint) * (((273.15) / (273.15 + AT)) * (BP / 760.0) * (1 / (5 * slope)))) + 1;
                                }
                                else if (rbStandard == true)
                                {
                                    PumpSetPoint = ((flowPumpSetPoint / (5.0 * slope)) * (273.15 / 298.15)) - ((yint) * (273.15 / (273.15 + AT) * (1 / (5.0 * slope)) * (BP / 760.0))) + 1;
                                }

                            }
                            rbMetro167.Invoke(new MethodInvoker(delegate { mrb167 = rbMetro167.Checked; }));
                            yint = Properties.Settings.Default.yint;
                            slope = Properties.Settings.Default.slope;
                            if (mrb167 == true)
                            {


                                flowPumpSetPoint = 16.70;


                                //                            PumpSetPoint = ((flowPumpSetPoint - yint) * (((273.15) / (273.15 + AT)) * (BP/760.0) * (1 / (5 * slope))))  + 1;

                                if (rbActual == true)
                                {
                                    PumpSetPoint = ((flowPumpSetPoint - yint) * (((273.15) / (273.15 + AT)) * (BP / 760.0) * (1 / (5 * slope)))) + 1;
                                }
                                else if (rbStandard == true)
                                {
                                    PumpSetPoint = ((flowPumpSetPoint / (5.0 * slope)) * (273.15 / 298.15)) - ((yint) * (273.15 / (273.15 + AT) * (1 / (5.0 * slope)) * (BP / 760.0))) + 1;
                                }


                            }
                            rbMetro184.Invoke(new MethodInvoker(delegate { mrb184 = rbMetro184.Checked; }));
                            yint = Properties.Settings.Default.yint;
                            slope = Properties.Settings.Default.slope;
                            if (mrb184 == true)
                            {


                                flowPumpSetPoint = (18.40);
                                if (rbActual == true)
                                {
                                    PumpSetPoint = ((flowPumpSetPoint - yint) * (((273.15) / (273.15 + AT)) * (BP / 760.0) * (1 / (5 * slope)))) + 1;
                                }
                                else if (rbStandard == true)
                                {
                                    PumpSetPoint = ((flowPumpSetPoint / (5.0 * slope)) * (273.15 / 298.15)) - ((yint) * (273.15 / (273.15 + AT) * (1 / (5.0 * slope)) * (BP / 760.0))) + 1;
                                }


                            }
                            if (mrb150 == false && mrb167 == false && mrb184 == false)
                            {
                                flowPumpSetPoint = 16.7;
                                if (rbActual == true)
                                {
                                    PumpSetPoint = ((flowPumpSetPoint - yint) * (((273.15) / (273.15 + AT)) * (BP / 760.0) * (1 / (5 * slope)))) + 1;
                                }
                                else if (rbStandard == true)
                                {
                                    PumpSetPoint = ((flowPumpSetPoint / (5.0 * slope)) * (273.15 / 298.15)) - ((yint) * (273.15 / (273.15 + AT) * (1 / (5.0 * slope)) * (BP / 760.0))) + 1;
                                }

                            }

                        }

                    }

                    // do work here

                    //control logic here, called every 1 second:

                    //read feedback and conduct PID

                    string[] values = new string[10];
                    //string timeStampValue;
                    //double tapePressure;
                    //double tapePressureValue=0;
                    //double ambientPressureValue=0;
                    double outputVoltage = 0;

                    string strSetPoint = string.Empty;
                    double setPoint;
                    double PG;
                    double IG;
                    double DG;

                    //bilinear transform digital filter values:
                    //double K;
                    //double Fc;
                    //double Fs;
                    //double a0, a1, a2, b0, b1, b2, n;
                    //double Q = .7071; // this is 1 over square root of 2, used for unity gain band pass


                    double[] inputValues = new double[10];
                    int differenceValue = 0;

                    System.TimeSpan difference = DateTime.Now.Subtract(DateTime.Now);

                    if (m_oWorkerPump.CancellationPending != true)
                    {
                        try
                        {
                            try
                            {
                                //get the previous time
                                DateTime ptp = AcquisitionControl.GetPumpTimePrevious();
                                DateTime ptnow = DateTime.Now;
                                //DateTime ptdifference = ptnow - ptp;
                                difference = ptnow.Subtract(ptp);
                                AcquisitionControl.SetPumpTimePrevious(ptnow);
                            }
                            catch
                            {
                                differenceValue = 1;
                            }

                            if(difference.Seconds >1.25 && pumpStartCounter>5)  //wait until 5 counts for things to stabilize a bit
                            {
                                differenceValue = (int)difference.Seconds;
                            }
                            else
                            {
                                differenceValue = 1;
                            }




                            /////// identify the start of pump logic thread
                            //Logger.WriteLogFile(   "START pump thread:  " + pumpStartCounter.ToString());


                            pumpStartCounter++;
                            if (pumpStartCounter > 900000)
                            {                             
                                pumpStartCounter = 900000;  //dont let it roll over
                            }

                            setPoint = PumpSetPoint; // Convert.ToDouble(retVal);

                            //actionPAS();
                            PG = 1.1; // Convert.ToDouble(sProportionalGain);

                            //actionIAS();
                            IG = 0.4; // Convert.ToDouble(sIntegralGain);

                            //actionDAS();
                            DG = 0.1; // Convert.ToDouble(sDerivativeGain);

                            double errorValue = 0.0;
                            double flowValue = 0.0;
                            double processFlowValue = 0.0;

                            if (m_oWorkerPump.CancellationPending == false)
                            {
                                OutputCalc(setPoint, PG, IG, DG, pumpStartCounter, out errorValue, out flowValue, out outputVoltage, out processFlowValue); //, K, n, a0, a1, a2, b0, b1, b2, inputValues, inputIndex);

                            }
                            double Flow25 = ((flowValue * 5) - 5) * (298.15 / 273.15);  //cpmverts flow sensor from 0C to 25C

                            //...add AT read here: corr
                            //...add AP read here: corr

                            double AT = 23.5;  //dummy default value
                            double AP = 756.5; //dummy default value




                            AT = ambientTempStatic;

                            AP = ambientPressureStatic;


                            double uFlowActAmb = Flow25 * (((273.15 + AT) / (298.15)) * (760.0 / AP));

                            double FlowAct = uFlowActAmb * Properties.Settings.Default.slope + Properties.Settings.Default.yint;

                            double FlowStd = FlowAct * ((298.15) / (273.15 + AT)) * (AP / 760.0);


                            AcquisitionControl.SetFlowStd(FlowStd);
                            AcquisitionControl.SetFlowAct(FlowAct);
                            AcquisitionControl.SetFlow25(Flow25);

                            //this is critical as the pump thread may not be called perfectly one time per second
                            //get the number of missed pump threads since last execution, and average the flow

                            double stdFlow;
                            stdFlow = (FlowStd / 60.0) * differenceValue;
                            //Logger.WriteLogFile( "std flow value to sum: " + stdFlow.ToString("F3")+" (L)","c:/temp/pumpdata.txt");

                            double actFlow;
                            actFlow = (FlowAct / 60.0) * differenceValue;
                            //Logger.WriteLogFile( "act flow value to sum: " + actFlow.ToString("F3")+ " (L)","c:/temp/pumpdata.txt");

                            if (Properties.Settings.Default.FlowSum.Contains("Std"))
                            {
                                //Logger.WriteLogFile("std flow summing...." + stdFlow.ToString("F3"),"c:/temp/pumpdata.txt" );

                                AcquisitionControl.AddFlowVolume(stdFlow);   //flow = N liters/min for 60 seconds.
                                double stdFlowSubtotal = AcquisitionControl.GetFlowVolume();
                                //Logger.WriteLogFile("std flow subtotal = "+ stdFlowSubtotal.ToString("F3") +"(L)","c:/temp/pumpdata.txt" );

                                /////////////////////////////////////////////////
                                //BHC temp -- comment out for testing
                                FlowAvgCounter++;
                                /////////////////////////////////////////////////



                                AcquisitionControl.SetFlowStd60s(FlowStd);
                                if(FlowAvgCounter>=60)
                                {
                                    FlowAvgCounter = 0;

                                    double FlowAvg60s = AcquisitionControl.GetFlowStd60s();
                                    AcquisitionControl.ClrFlowStd60s();

                                    if(FlowAvg60s<= Properties.Settings.Default.FlowError)
                                    {

                                        WriteAlarmToModbus(111);
                                        AcquisitionControl.SetAlarmValue(111);

                                        //BHC TEST for testing without pump running:  comment out line below
                                        // or build with TURNOFF_LOWFLOW defined in properties
                                        //bhc debug
#if TURNON_LOWFLOW
                                        Halt("Low Flow Error.  Flow = "+FlowAvg60s.ToString("F2"));
#endif
                                        //bhc debug


                                    }
                                    else if(FlowAvg60s>Properties.Settings.Default.FlowError && FlowAvg60s< Properties.Settings.Default.FlowWarning)
                                    {
                                        if (HaltEnabled==1)  //halt has happened so dont overwrite it
                                        {
                                            WriteAlarmToModbus(211);
                                            AcquisitionControl.SetAlarmValue(211);
                                            Warning("Low Flow Warning.  Flow = " + FlowAvg60s.ToString("F2"));
                                        }
                                    }

                                }

                            }
                            else if (Properties.Settings.Default.FlowSum.Contains("Act"))
                            {
                                AcquisitionControl.AddFlowVolume(actFlow);   //flow = N liters/min for 60 seconds.
                                double actFlowSubtotal = AcquisitionControl.GetFlowVolume();
                                FlowAvgCounter++;
                                AcquisitionControl.SetFlowAct60s(FlowAct);
                                if (FlowAvgCounter >= 60)
                                {
                                    FlowAvgCounter = 0;

                                    double FlowAvg60s =  AcquisitionControl.GetFlowAct60s();
                                    AcquisitionControl.ClrFlowAct60s();
                                    if (FlowAvg60s <= Properties.Settings.Default.FlowError)
                                    {
                                        WriteAlarmToModbus(211);
                                        AcquisitionControl.SetAlarmValue(211);

                                        //bhc debug
#if TURNON_LOWFLOW
                                        Halt("Low Flow Error.  Flow = " + FlowAvg60s.ToString("F2"));
#endif
                                        //bhc debug
                                    }
                                    else if (FlowAvg60s > Properties.Settings.Default.FlowError && FlowAvg60s < Properties.Settings.Default.FlowWarning)
                                    {

                                        WriteAlarmToModbus(111);
                                        AcquisitionControl.SetAlarmValue(111);
                                        Warning("Low Flow Warning.  Flow = " + FlowAvg60s.ToString("F2"));

                                    }

                                }




                            }



                            inputIndex++;
                            if (inputIndex >= 2)
                                inputIndex = 0;

                            values[0] = errorValue.ToString();
                            values[1] = flowValue.ToString();
                            values[2] = processFlowValue.ToString();
                            values[3] = outputVoltage.ToString();
                            values[4] = Flow25.ToString();
                            values[5] = FlowAct.ToString();
                            values[6] = FlowStd.ToString();
                            values[7] = uFlowActAmb.ToString();
                            

                            //or call settext
                            if (m_oWorkerPump.CancellationPending == false)
                            {
                                //if (pumpStartCounter > 5)
                                //{
                                    m_oWorkerPump.ReportProgress(0, values);
                                //}
                            }
                        }
                        catch (Exception Ex)
                        {

                            Logger.WriteInternalLogFile("Error in pump OUTPUT timer.  Ex = " + Ex.ToString());

                        }
                    }      //(m_oWorkerPump.CancellationPending != true
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in pump timer logic. Ex = " + Ex.ToString());
                }
                finally
                {
                    //Logger.WriteLogFile(   "@finally, done with pump thread:  " + pumpStartCounter.ToString());
                    //Logger.WriteLogFile("@finally, done with pump thread:  " + pumpStartCounter.ToString(),"c:/temp/pumpdata2.txt" );

                    Monitor.Exit(pumpLockObj);

                }


            }

            else
            {
                //lock not obtained for this timer.  Pump output calcs and other threads took longer than 1 second.
                if(AcquisitionControl.GetPumpLockCounter() >100)
                {
                    Logger.WriteInternalLogFile("Pump timer lock not obtained for this timer.  Counter = " + AcquisitionControl.GetPumpLockCounter().ToString());
                    Monitor.Exit(pumpLockObj);
                    AcquisitionControl.SetPumpLockCounter(0);

                }
                AcquisitionControl.SetPumpLockCounter(AcquisitionControl.GetPumpLockCounter() + 1);
   

            }



        }
        //end pump timed event


        public void SaveExistingParameters(double TnistCA, double PnistCA, double PSnistCA, double yint, double slope, double normalFlow)
        {

            init_TnistCA = TnistCA;
            init_PnistCA = PnistCA;
            init_PSnistCA = PSnistCA;
            init_yint = yint;
            init_slope = slope;
            init_NormalFlow = normalFlow;


            Logger.WriteLogFile("Initial FLOW CALIBRATION", "C:/temp/CalValues_init.txt");
            Logger.WriteLogFile("tnistcal adj = " + TnistCA.ToString("F2"), "C:/temp/CalValues_init.txt");
            Logger.WriteLogFile("pnistcal adj = " + PnistCA.ToString("F2"), "C:/temp/CalValues_init.txt");
            Logger.WriteLogFile("psnistcal adj = " + PSnistCA.ToString("F2"), "C:/temp/CalValues_init.txt");
            Logger.WriteLogFile("yint = " + yint.ToString("F2"), "C:/temp/CalValues_init.txt");
            Logger.WriteLogFile("slope = " + slope.ToString("F2"), "C:/temp/CalValues_init.txt");
            Logger.WriteLogFile("normal flow = " + normalFlow.ToString("F2"), "C:/temp/CalValues_init.txt");


        }


        public void GetStoredFlowParameters(out double TnistCA, out double PnistCA, out double PSnistCA, out double yint, out double slope, out double normalFlow)
        {

            TnistCA =init_TnistCA;
            PnistCA =init_PnistCA;
            PSnistCA =init_PSnistCA;
            yint =init_yint;
            slope =init_slope;
            normalFlow = init_NormalFlow;


            Logger.WriteLogFile("Get Stored FLOW CALIBRATION", "C:/temp/CalValues_stored.txt");
            Logger.WriteLogFile("tnistcal adj = " + TnistCA.ToString("F2"), "C:/temp/CalValues_stored.txt");
            Logger.WriteLogFile("pnistcal adj = " + PnistCA.ToString("F2"), "C:/temp/CalValues_stored.txt");
            Logger.WriteLogFile("psnistcal adj = " + PSnistCA.ToString("F2"), "C:/temp/CalValues_stored.txt");
            Logger.WriteLogFile("yint = " + yint.ToString("F2"), "C:/temp/CalValues_stored.txt");
            Logger.WriteLogFile("slope = " + slope.ToString("F2"), "C:/temp/CalValues_stored.txt");
            Logger.WriteLogFile("Normal Flow = " + normalFlow.ToString("F2"), "C:/temp/CalValues_stored.txt");


        }





        // ****** start leak check

        /// <summary>
        /// Perform Leak check prompts and actions
        /// </summary>
        void LeakCheckStateMachine()
        {
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            int leakCheckCounter;    //steps through the state machine

            leakCheckCounter = AcquisitionControl.GetLeakCheckCounter();

            switch (leakCheckCounter)
            {
                case 0:
                    { // pump must be running to create this thread of execution  NEED to redesign -- so that the state machine may run without being on the pump thread.


                        if (tbMetroCalPrompt.InvokeRequired)
                        {
                            tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "When flow constant, close Pump Valve.  When closed, Press 'Enter Data' Button."; }));
                        }
                        //else
                        //{
                        //    tbMetroCalPrompt.Text = "Close Pump Valve.  When Closed Press 'Enter Data' Button.";
                        //}
                        if (bMetroEnterDataButton.InvokeRequired)
                        {
                            if (enterDataButtonClicked == true)
                            {
                                
                                enterDataButtonClicked = false;


                                AcquisitionControl.SetLeakCheckCounter(1);
                            }
                        }

                        break;

                        //check enter pressed
                        //    AcquisitionControl.SetLeakCheckCounter(1);
                    }
                case 1:
                    {
                        //set pump output to zero:
                        PumpSetPoint = 0;
                        PumpLeakCheckTimer = 0;
                        //string initialValue;
                        //initialValue = tbMetroSamplePressureCal.Text;
                        AcquisitionControl.SetLeakCheckCounter(2);

                        break;
                    }
                case 2:
                    {
                        //begin count down
                        PumpLeakCheckTimer++;
                        int secRemaining = 88 - PumpLeakCheckTimer;


                        if (tbMetroCalPrompt.InvokeRequired)
                        {
                            tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "Seconds Remaining = " + secRemaining.ToString() + " sec"; }));
                        }
                        if (secRemaining <= 0)
                        {
                            AcquisitionControl.SetLeakCheckCounter(3);
                        }
                        break;
                    }
                case 3:
                    {
                        //begin count down
                        //PumpLeakCheckTimer++;
                        //int secRemaining = 90 - PumpLeakCheckTimer;


                        if (tbMetroCalPrompt.InvokeRequired)
                        {
                            tbMetroCalPrompt.Invoke(new MethodInvoker(delegate { tbMetroCalPrompt.Text = "Recording Pressure..."; }));

                        }

                        //string finalValue;
                        //finalValue = tbMetroSamplePressureCal.Text;

                        break;
                    }

            }

            //prompt for close valve

            //if closed turn off pump--by setting the voltage to zero.   MUST RESET PID.

            //start 90 second timer

            //check displayed pressure

            //record value

            //prompt to open value






        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <param name="e"></param>
        private void onManualAcqTimedEvent(object source, ElapsedEventArgs e)
        {


            // only execute the code within this method if we are able to
            // a lock. This will ensure that any Timer firings will be
            // ignored that occur while we're already doing work (OnTimer) 

            // if (!Monitor.TryEnter(obj, 2000))
            // {
            //     throw new Exception("can not lock");
            // }

            if (Monitor.TryEnter(lockManualAcqObj))
            {
                try
                {

                    ManualAcqLockCounter = 0;
                    // do work here


                    AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                    //fired every one second....
                    string[] ManualAcqValues = new string[10];

                    AcquisitionControl.IncTimerCounter();

                    try
                    {
                        int getState;
                        //private object lockObj;

                        getState = AcquisitionControl.GetState();
                        ManualAcqValues[0] = getState.ToString();

                    }
                    catch
                    {
                        ManualAcqValues[1] = "message empty.";

                    }

                    BackgroundManager.m_oWorkerManualAcq.ReportProgress(AcquisitionControl.GetState(), ManualAcqValues);




                    int curState = AcquisitionControl.GetState();


                    switch (curState)
                    {

                        case 300:
                            {

                                try
                                {

                                    //disable the text box and buttons for saving?
                                    if (AcquisitionControl.GetCounter() == 0)
                                    {

                                        Logger.WriteLogFile( "Starting Manual Acq (300)", "c:/temp/ManualAcq.txt");
                                        if (metroRadioButton1.InvokeRequired)
                                        {
                                            metroRadioButton1.Invoke(new MethodInvoker(delegate { EC1maset = metroRadioButton1.Checked; }));
                                        }
                                        if (metroRadioButton2.InvokeRequired)
                                        {
                                            metroRadioButton2.Invoke(new MethodInvoker(delegate { EC2maset = metroRadioButton2.Checked; }));
                                        }
                                        if (metroRadioButton3.InvokeRequired)
                                        {
                                            metroRadioButton3.Invoke(new MethodInvoker(delegate { EC3maset = metroRadioButton3.Checked; }));
                                        }
                                        if (metroRadioButton4.InvokeRequired)
                                        {
                                            metroRadioButton4.Invoke(new MethodInvoker(delegate { EC4maset = metroRadioButton4.Checked; }));
                                        }

                                        string secondsStr = String.Empty;
                                        int seconds = 0;
                                        try
                                        {
                                            if (metroTextBox2.InvokeRequired)
                                            {
                                                metroTextBox2.Invoke(new MethodInvoker(delegate { secondsStr = metroTextBox2.Text; }));
                                            }

                                            seconds = Convert.ToInt32(secondsStr);
                                            AcquisitionControl.SetCounter(1);
                                        }
                                        catch
                                        {
                                            //retry
                                            HaltManualAcq("Enter valid time in seconds");
                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(300);
                                        }
                                    }
                                    else if (AcquisitionControl.GetCounter() <= 3)
                                    {

                                        UpdateMaintCheckMessage("Move FW Home");
                                        Thread.Sleep(1000);
                                        int return1031 = AcquisitionControl.MoveFWHome(SerialManager, this);
                                        if (return1031 == PASS)
                                        {
                                            Logger.WriteLogFile( "Done Manual Acq (300)", "c:/temp/ManualAcq.txt");
                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(302);
                                        }
                                        else
                                        {
                                            AcquisitionControl.SetCounter(AcquisitionControl.GetCounter() + 1);

                                        }
                                    }
                                    else
                                    {


                                        HaltManualAcq("Error Manual Acq, move FW Home  ");

                                    }

                                }
                                catch (Exception Ex)
                                {
                                    HaltManualAcq("Error Manual Acq, move FW Home  Ex=" + Ex.ToString());

                                }

                            }
                            break;

                        case 302:
                            {
                              
                                try
                                {
                                    if (AcquisitionControl.GetCounter() == 0)
                                    {
                                        if (EC1maset == true)
                                        {
                                            UpdateMaintCheckMessage("Move FW to EC1");
                                            fwECend = 1;
                                            Logger.WriteLogFile("Starting Manual Acq (302) Move FW to EC1", "c:/temp/ManualAcq.txt");
                                            returnManualFWHome = AcquisitionControl.MoveFWEC(SerialManager, 0, 1, this);
                                        }
                                        else if (EC2maset == true)
                                        {
                                            UpdateMaintCheckMessage("Move FW to EC2");
                                            fwECend = 2;
                                            Logger.WriteLogFile("Starting Manual Acq (302) Move FW to EC2", "c:/temp/ManualAcq.txt");
                                            returnManualFWHome = AcquisitionControl.MoveFWEC(SerialManager, 0, 2, this);
                                        }
                                        else if (EC3maset == true)
                                        {
                                            UpdateMaintCheckMessage("Move FW to EC3");
                                            fwECend = 3;
                                            Logger.WriteLogFile("Starting Manual Acq (302) Move FW to EC3", "c:/temp/ManualAcq.txt");
                                            returnManualFWHome = AcquisitionControl.MoveFWEC(SerialManager, 0, 3, this);
                                        }
                                        else if (EC4maset == true)
                                        {
                                            UpdateMaintCheckMessage("Move FW to EC4");
                                            fwECend = 4;
                                            Logger.WriteLogFile("Starting Manual Acq (302) Move FW to EC4", "c:/temp/ManualAcq.txt");
                                            returnManualFWHome = AcquisitionControl.MoveFWEC(SerialManager, 0, 4, this);
                                        }
                                        AcquisitionControl.SetCounter(1);


                                    }
                                    else if (AcquisitionControl.GetCounter() <= 4)
                                    {

                                        if (returnManualFWHome == PASS)
                                        {
                                            Logger.WriteLogFile("Done Manual Acq (302) Move FW to EC", "c:/temp/ManualAcq.txt");


                                            int position = AcquisitionControl.PollMotorPosition(1, SerialManager);  //1=FW
                                            //check motor position
                                            //int position = 0;
                                            //int positionold = 0;
                                            //int posCounter = 0;
                                            //do
                                            //{
                                            //    int returnVal27 = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);  //1=FW
                                            //    Logger.WriteLogFile("EC " + fwECend.ToString() + " (destination) motor position, after move = " + position.ToString(), "c:/temp/ManualAcq.txt");
                                            //    Logger.WriteLogFile("Check FW motor postion returned: " + returnVal27.ToString(), "c:/temp/ManualAcq.txt");

                                            //    if ((position > 0) && (positionold > 0) && (position == positionold))
                                            //    {
                                            //        break;
                                            //    }
                                            //    positionold = position;
                                            //    Thread.Sleep(1000);
                                            //    posCounter++;
                                            //} while (posCounter < 30);

                                            if (fwECend == 1)
                                            {


                                                if (position.ToString().Contains(Properties.Settings.Default.FWEC1.ToString()))
                                                {
                                                    //UpdateOperationMessage("Move FW to EC1 Pass");
                                                    UpdateMaintCheckMessage("Move FW to EC1 Pass");
                                                    UpdateFilterWheelMessage("FW at EC1 (" + Properties.Settings.Default.FWEC1.ToString() + ")");
                                                    //AcquisitionControl.SetEnergyConditionPrevious(1);
                                                    AcquisitionControl.SetCounter(0);
                                                    AcquisitionControl.SetState(304);
                                                }
                                                else
                                                {

                                                    HaltManualAcq("Error: Failed to move FW to EC1");

                                                }
                                            }
                                            if (fwECend == 2)
                                            {


                                                if (position.ToString().Contains(Properties.Settings.Default.FWEC2.ToString()))
                                                {
                                                    //UpdateOperationMessage("Move FW to EC1 Pass");
                                                    UpdateMaintCheckMessage("Move FW to EC2 Pass");
                                                    UpdateFilterWheelMessage("FW at EC2 (" + Properties.Settings.Default.FWEC2.ToString() + ")");
                                                    //AcquisitionControl.SetEnergyConditionPrevious(1);
                                                    AcquisitionControl.SetCounter(0);
                                                    AcquisitionControl.SetState(304);
                                                }
                                                else
                                                {

                                                    HaltManualAcq("Error: Failed to move FW to EC2");

                                                }
                                            }
                                            if (fwECend == 3)
                                            {


                                                if (position.ToString().Contains(Properties.Settings.Default.FWEC3.ToString()))
                                                {
                                                    //UpdateOperationMessage("Move FW to EC1 Pass");
                                                    UpdateMaintCheckMessage("Move FW to EC3 Pass");
                                                    UpdateFilterWheelMessage("FW at EC3 (" + Properties.Settings.Default.FWEC3.ToString() + ")");
                                                    //AcquisitionControl.SetEnergyConditionPrevious(1);
                                                    AcquisitionControl.SetCounter(0);
                                                    AcquisitionControl.SetState(304);
                                                }
                                                else
                                                {

                                                    HaltManualAcq("Error: Failed to move FW to EC3");

                                                }
                                            }
                                            if (fwECend == 4)
                                            {


                                                if (position.ToString().Contains(Properties.Settings.Default.FWEC4.ToString()))
                                                {
                                                    //UpdateOperationMessage("Move FW to EC1 Pass");
                                                    UpdateMaintCheckMessage("Move FW to EC4 Pass");
                                                    UpdateFilterWheelMessage("FW at EC4 (" + Properties.Settings.Default.FWEC4.ToString() + ")");
                                                    //AcquisitionControl.SetEnergyConditionPrevious(1);
                                                    AcquisitionControl.SetCounter(0);
                                                    AcquisitionControl.SetState(304);
                                                }
                                                else
                                                {

                                                    HaltManualAcq("Error: Failed to move FW to EC4");

                                                }
                                            }

                                        }
                                        else
                                        {
                                            HaltManualAcq("Error: Move FW ");
                                        }
                                    }
                                    else
                                    {
                                        HaltManualAcq("Error: FW Position retry");
                                    }
                                    
                                }
                                catch (Exception Ex)
                                {
                                    HaltManualAcq("Error move FW (302) Ex=" + Ex.ToString());
                                }
                            }
                            break;

                        case 304:

                            {
                                try
                                {

                                    int destinationV = 0;// Properties.Settings.Default.EcalkV;
                                    int destinationI = 0;// Properties.Settings.Default.EcaluA;

                                    if (EC1maset == true)
                                    {
                                        UpdateMaintCheckMessage("Ramp Xrays to EC1");
                                        Logger.WriteLogFile( "Ramp Xrays to EC1","c:/temp/ManualAcq.txt");

                                        destinationV = Properties.Settings.Default.EC1kV;
                                        destinationI = Properties.Settings.Default.EC1uA;
                                        //inform cross
                                    }
                                    else if (EC2maset == true)
                                    {
                                        UpdateMaintCheckMessage("Ramp Xrays to EC2");
                                        Logger.WriteLogFile( "Ramp Xrays to EC2", "c:/temp/ManualAcq.txt");
                                        destinationV = Properties.Settings.Default.EC2kV;
                                        destinationI = Properties.Settings.Default.EC2uA;
                                        //inform cross
                                    }
                                    else if (EC3maset == true)
                                    {
                                        UpdateMaintCheckMessage("Ramp Xrays to EC3");
                                        Logger.WriteLogFile( "Ramp Xrays to EC3","c:/temp/ManualAcq.txt");
                                        destinationV = Properties.Settings.Default.EC3kV;
                                        destinationI = Properties.Settings.Default.EC3uA;
                                        //inform cross

                                    }
                                    else if (EC4maset == true)
                                    {
                                        UpdateMaintCheckMessage("Ramp Xrays to EC4");
                                        Logger.WriteLogFile("Ramp Xrays to EC4", "c:/temp/ManualAcq.txt");
                                        destinationV = Properties.Settings.Default.EC4kV;
                                        destinationI = Properties.Settings.Default.EC4uA;
                                        //inform cross

                                    }



                                    else
                                    {
                                        UpdateMaintCheckMessage("No EC selected");
                                        HaltManualAcq("No EC selected");
                                    }

                                    UpdateMaintCheckMessage("Setting Xrays to (" + destinationV.ToString() + " kV and " + destinationI.ToString() + " uA)");
                                    Thread.Sleep(1500);
                                    double presentV = readInputVoltage;
                                    presentV = presentV * 50.0 / 10.0;


                                    double presentI = readInputCurrent;
                                    presentI = presentI * 2000.0 / 10.0;


                                    Logger.WriteLogFile( "Manual Acq ramp V from: " + presentV.ToString("F2") + " to: " + destinationV.ToString("F2"), "c:/temp/ManualAcq.txt");
                                    Logger.WriteLogFile( "Manual Acq ramp I from: " + presentI.ToString("F2") + " to: " + destinationI.ToString("F2"),"c:/temp/ManualAcq.txt");
                                    int returnVal25 = AcquisitionControl.RampXrays(presentV, presentI, destinationV, destinationI, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                                    if (returnVal25 == PASS)
                                    {

                                            Logger.WriteLogFile("Manual Acquire Ramping X-rays ", "c:/temp/ManualAcq.txt");
                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(306);

                                        //// poll for ramp active
                                        //int rampCounter = 0;
                                        //do
                                        //{
                                        //    Thread.Sleep(500);
                                        //    rampCounter++;
                                        //    Logger.WriteLogFile("Waiting for ramp to complete. Counter = "+rampCounter.ToString(), "c:/temp/ManualAcq.txt" );


                                        //} while (rampActive == 1 && rampCounter < 60);

                                        //if (rampCounter<60)
                                        //{
                                        //    Logger.WriteLogFile("Done (304) Ramp Xrays ", "c:/temp/ManualAcq.txt");
                                        //    AcquisitionControl.SetCounter(0);
                                        //    AcquisitionControl.SetState(306);

                                        //}
                                        //else
                                        //{
                                        //    HaltManualAcq("Manual Acq Unable to Ramp X-rays");
                                        //
                                        //}

                                    }
                                    else
                                    {
                                        HaltManualAcq("Manual Acq Error:  Ramp Xrays");
                                    }
                                }
                                catch (Exception Ex)
                                {
                                    Logger.WriteInternalLogFile("Error in Manual Acq (304) Ex=" + Ex.ToString());
                                    HaltManualAcq("Ex=" + Ex.ToString());

                                }

                            }

                            break;

                        case 306:
                            {

                                int ecLoad = 0;
                                if (EC1maset == true)
                                {
                                    ecLoad = 1;
                                }
                                else if (EC2maset == true)
                                {
                                    ecLoad = 2;
                                }
                                else if (EC3maset == true)
                                {
                                    ecLoad = 3;
                                }
                                else if (EC4maset == true)
                                {
                                    ecLoad = 4;
                                }


                                try
                                {
                                    Logger.WriteLogFile("state = 306. loading master tfr file", "c:/temp/ManualAcq.txt" );

                                    if (AcquisitionControl.GetCounter() == 0)
                                    {
                                        AcquisitionControl.SetCounter(1);
                                        UpdateMaintCheckMessage("Loading Master TFR File = " + ecLoad.ToString());
                                    }


                                    int returnVal26 = AcquisitionControl.LoadMTFRFile(ecLoad);
                                    if (returnVal26 == PASS)
                                    {
                                        // poll for ramp active
                                        int rampCounter = 0;
                                        do
                                        {
                                            Thread.Sleep(1000);
                                            rampCounter++;
                                            Logger.WriteLogFile("Waiting for ramp to complete. Counter = " + rampCounter.ToString(), "c:/temp/ManualAcq.txt");


                                        } while (rampActive == 1 && rampCounter < 60);

                                        if (rampCounter < 60)
                                        {
                                            Logger.WriteLogFile("Done (306) Check Ramp Xrays ", "c:/temp/ManualAcq.txt");
                                            Logger.WriteLogFile("Load MFTRFile + cond code returned: true", "c:/temp/ManualAcq.txt");
                                            UpdateMaintCheckMessage("Done Xray ramp");
                                            Thread.Sleep(1000);
                                            UpdateMaintCheckMessage("Done loading .tfr file and condition");
                                            Thread.Sleep(1000);
;                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(308);

                                        }
                                        else
                                        {
                                            HaltManualAcq("Manual Acq Unable to Ramp X-rays");

                                        }


                                    }
                                    else
                                    {
                                        Logger.WriteInternalLogFile("Unable to load tfr file  " + ecLoad.ToString());
                                        HaltManualAcq("Unable to load tfr file " + ecLoad.ToString());
                                    }



                                }
                                catch (Exception Ex)
                                {
                                    Logger.WriteInternalLogFile("Error in Manual Acq (306) Ex=" + Ex.ToString());
                                    HaltManualAcq("Error (306) Ex=" + Ex.ToString());


                                }
                                break;

                            }


                        case 308:
                            {
                                int ecLoad = 0;
                                if (EC1maset == true)
                                {
                                    ecLoad = 1;
                                }
                                else if (EC2maset == true)
                                {
                                    ecLoad = 2;
                                }
                                else if (EC3maset == true)
                                {
                                    ecLoad = 3;
                                }
                                else if(EC4maset==true)
                                {
                                    ecLoad = 4;
                                }

                                Logger.WriteLogFile("state 308. Start and Wait for ec time to expire.", "c:/temp/ManualAcq.txt" );
                                UpdateMaintCheckMessage("Start Acq and wait...");
                                if (AcquisitionControl.GetCounter() == 0)
                                {
                                    string secondsStr = string.Empty;
                                    int seconds = 0;
                                    //get time in seconds

                                    if (metroTextBox2.InvokeRequired)
                                    {
                                        metroTextBox2.Invoke(new MethodInvoker(delegate { secondsStr = metroTextBox2.Text; }));
                                    }

                                    seconds = Convert.ToInt32(secondsStr);
                                    //DateTime ectime;

                                    float kV;
                                    string kVs;



                                    if (mtbIOActualkV.InvokeRequired)
                                    {
                                        mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                    }
                                    else
                                    {
                                        actualValueV = mtbIOActualkV.Text;
                                    }

                                    kVs = actualValueV;
                                    kV = Convert.ToSingle(kVs);
                                    bool boolresponse_kV = myxrsfp.Send_kV[kV];


                                    float uA;
                                    string uAs;
                                    if (mtbIOActualuA.InvokeRequired)
                                    {
                                        mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                    }
                                    else
                                    {
                                        actualValueI = mtbIOActualuA.Text;
                                    }
                                    uAs = actualValueI;
                                    uA = Convert.ToSingle(uAs);
                                    bool boolresponse_uA = myxrsfp.Send_uA[uA];


                                    //ectime = DateTime.Now.AddSeconds(seconds);  
                                    //TimeSpan time = ectime - DateTime.Now;
                                    //Logger.WriteLogFile("Manual Acq start time: " + DateTime.Now.ToString(), "c:/temp/ManualAcq.txt" );
                                    //UpdateMaintCheckMessage("Manual Acq start time: " + DateTime.Now.ToString());


                                    //AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) + (time.Hours * 3600));
                                    //AcquisitionControl.StartXrsfpAcquisition(67);

                                    //Thread.Sleep(1000);
                                    float deadTime = 0.0F;

                                    if (ecLoad == 1)
                                    {
                                        if (Properties.Settings.Default.EC1AC.Contains("ON"))
                                        {
                                            Logger.WriteLogFile("EC1 AutoCurrent = ON", "c:/temp/ManualAcq.txt");
                                            Thread.Sleep(1000);
                                            AcquisitionControl.AutoCurrent((readInputCurrent * 2000.0 / 10.0), (readInputVoltage * 50.0 / 10.0), m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                                            
                                            deadTime = AcquisitionControl.GetDeadTime();
                                            //float kV;
                                            //string kVs;



                                            if (mtbIOActualkV.InvokeRequired)
                                            {
                                                mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                            }
                                            else
                                            {
                                                actualValueV = mtbIOActualkV.Text;
                                            }

                                            kVs = actualValueV;
                                            kV = Convert.ToSingle(kVs);
                                            boolresponse_kV = myxrsfp.Send_kV[kV];


                                            //float uA;
                                            //string uAs;
                                            if (mtbIOActualuA.InvokeRequired)
                                            {
                                                mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                            }
                                            else
                                            {
                                                actualValueI = mtbIOActualuA.Text;
                                            }
                                            uAs = actualValueI;
                                            uA = Convert.ToSingle(uAs);
                                            boolresponse_uA = myxrsfp.Send_uA[uA];

                                        }
                                        else
                                        {
                                            deadTime = AcquisitionControl.GetDeadTime();
                                        }
                                    }
                                    if (ecLoad == 2)
                                    {
                                        if (Properties.Settings.Default.EC2AC.Contains("ON"))
                                        {
                                            Logger.WriteLogFile("EC2 AutoCurrent = ON", "c:/temp/ManualAcq.txt");
                                            Thread.Sleep(1000);

                                            AcquisitionControl.AutoCurrent((readInputCurrent * 2000.0 / 10.0), (readInputVoltage * 50.0 / 10.0), m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                                            deadTime = AcquisitionControl.GetDeadTime();

                                            //float kV;
                                            //string kVs;



                                            if (mtbIOActualkV.InvokeRequired)
                                            {
                                                mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                            }
                                            else
                                            {
                                                actualValueV = mtbIOActualkV.Text;
                                            }

                                            kVs = actualValueV;
                                            kV = Convert.ToSingle(kVs);
                                            boolresponse_kV = myxrsfp.Send_kV[kV];


                                            //float uA;
                                            //string uAs;
                                            if (mtbIOActualuA.InvokeRequired)
                                            {
                                                mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                            }
                                            else
                                            {
                                                actualValueI = mtbIOActualuA.Text;
                                            }
                                            uAs = actualValueI;
                                            uA = Convert.ToSingle(uAs);
                                            boolresponse_uA = myxrsfp.Send_uA[uA];

                                        }
                                        else
                                        {
                                            deadTime = AcquisitionControl.GetDeadTime();
                                        }
                                    }
                                    if (ecLoad == 3)
                                    {
                                        if (Properties.Settings.Default.EC3AC.Contains("ON"))
                                        {
                                            Logger.WriteLogFile("EC3 AutoCurrent = ON", "c:/temp/ManualAcq.txt");
                                            Thread.Sleep(1000);
                                            AcquisitionControl.AutoCurrent((readInputCurrent * 2000.0 / 10.0), (readInputVoltage * 50.0 / 10.0), m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                                            deadTime = AcquisitionControl.GetDeadTime();
                                            //float kV;
                                            //string kVs;



                                            if (mtbIOActualkV.InvokeRequired)
                                            {
                                                mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                            }
                                            else
                                            {
                                                actualValueV = mtbIOActualkV.Text;
                                            }

                                            kVs = actualValueV;
                                            kV = Convert.ToSingle(kVs);
                                            boolresponse_kV = myxrsfp.Send_kV[kV];


                                            //float uA;
                                            //string uAs;
                                            if (mtbIOActualuA.InvokeRequired)
                                            {
                                                mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                            }
                                            else
                                            {
                                                actualValueI = mtbIOActualuA.Text;
                                            }
                                            uAs = actualValueI;
                                            uA = Convert.ToSingle(uAs);
                                            boolresponse_uA = myxrsfp.Send_uA[uA];

                                        }
                                        else
                                        {
                                            deadTime = AcquisitionControl.GetDeadTime();
                                        }
                                    }
                                    if (ecLoad == 4)
                                    {
                                        if (Properties.Settings.Default.EC4AC.Contains("ON"))
                                        {
                                            Logger.WriteLogFile("EC4 AutoCurrent = ON", "c:/temp/ManualAcq.txt");
                                            Thread.Sleep(1000);
                                            AcquisitionControl.AutoCurrent((readInputCurrent * 2000.0 / 10.0), (readInputVoltage * 50.0 / 10.0), m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                                            deadTime = AcquisitionControl.GetDeadTime();
                                            //float kV;
                                            //string kVs;



                                            if (mtbIOActualkV.InvokeRequired)
                                            {
                                                mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                            }
                                            else
                                            {
                                                actualValueV = mtbIOActualkV.Text;
                                            }

                                            kVs = actualValueV;
                                            kV = Convert.ToSingle(kVs);
                                            boolresponse_kV = myxrsfp.Send_kV[kV];


                                            //float uA;
                                            //string uAs;
                                            if (mtbIOActualuA.InvokeRequired)
                                            {
                                                mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                            }
                                            else
                                            {
                                                actualValueI = mtbIOActualuA.Text;
                                            }
                                            uAs = actualValueI;
                                            uA = Convert.ToSingle(uAs);
                                            boolresponse_uA = myxrsfp.Send_uA[uA];

                                        }
                                        else
                                        {
                                            deadTime = AcquisitionControl.GetDeadTime();
                                        }
                                    }



                                    ectime = DateTime.Now.AddSeconds(seconds);
                                    TimeSpan time = ectime - DateTime.Now;
                                    Logger.WriteLogFile("Manual Acq start time: " + DateTime.Now.ToString(), "c:/temp/ManualAcq.txt");
                                    UpdateMaintCheckMessage("Manual Acq start time: " + DateTime.Now.ToString());


                                    Logger.WriteLogFile("Dead Time = " + deadTime.ToString("F2"), "c:/temp/ManualAcq.txt");
                                    AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) + (time.Hours * 3600));





                                    AcquisitionControl.SetCounter(1);
                                }
                                //else
                                //{

                                    //var TimeRemaining = ectime - System.DateTime.Now;
                                    var TimeRemainingTemp = ectime - System.DateTime.Now;
                                    TimeSpan span1 = TimeSpan.FromSeconds(2);
                                   var TimeRemaining = TimeRemainingTemp.Add(span1); 

                                UpdateMaintCheckMessage("Time Remaining Manual Acq = " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"));
                                    Logger.WriteLogFile("Time Remaining Manual Acq = " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"), "c:/temp/ManualAcq.txt");
                                    if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
                                    {
                                        UpdateMaintCheckMessage("End Manual Acq");
                                        Logger.WriteLogFile("End Manual Acq", "c:/temp/ManualAcq.txt");
                                        Thread.Sleep(1000);
                                        UpdateMaintCheckMessage("Apply Energy Calibration... ");
                                        //bool result = AcquisitionControl.PerformManualEcal(this);
                                        //saveGainOffset = mtbMaintCheckMessage.Text;
                                        //Logger.WriteLogFile("c:/temp/ManualEcal.txt", "Perform Ecal return value = " + result.ToString());
                                        //UpdateMaintCheckMessage("Saving Manual Acq spectrum");
                                        //Thread.Sleep(250);
                                        //AcquisitionControl.SaveCESSpectrumRaw("c:/Ecal_Data_Raw", "sp_data", 1);
                                        //UpdateMaintCheckMessage("Adjusting Spectrum");
                                        Thread.Sleep(2000);
                                        AcquisitionControl.AdjustSpectrum();

                                        double presentVLocal = readInputVoltage;
                                        presentVLocal = presentVLocal * 50.0 / 10.0;


                                        double presentILocal = readInputCurrent;
                                        presentILocal = presentILocal * 2000.0 / 10.0;
                                        Logger.WriteLogFile("Perform Auto Analyze...", "c:/temp/ManualAcq.txt");



                                    //AcquisitionControl.RampXrays(presentVLocal, presentILocal, 0.0, 0.0, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);

                                    //UpdateMaintCheckMessage("Ramping Xrays down");

                                    //Thread.Sleep(1000);

                                    UpdateMaintCheckMessage("Verify path and filename & press Save Spectra");
                                        //Thread.Sleep(250);
                                        //AcquisitionControl.SaveCESSpectrum("c:/Ecal_Data", "sp_data", 1);

                                        //if (metroTextBox3.InvokeRequired)
                                        //{
                                        //    metroTextBox3.Invoke(new MethodInvoker(delegate { metroTextBox3.Text = "C:/Temp/OutputFile.ces"; }));
                                        //}
                                        SaveButton = 0;
                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(310);


                                    }
                                //}
                            }
                            break;
                        case 310:
                            {


                                try
                                {
                                    if (AcquisitionControl.GetCounter() == 0)
                                    {
                                        if (SaveButton == 0)
                                        {
                                            //wait
                                        }
                                        else if (SaveButton == 1)
                                        {
                                            UpdateMaintCheckMessage("Saving file.... ");
                                            AcquisitionControl.SetCounter(1);
                                        }

                                    }
                                    else if (AcquisitionControl.GetCounter() == 1)
                                    {
                                        //save the spectrum

                                        string pathFilename = String.Empty;
                                        if (metroTextBox3.InvokeRequired)
                                        {
                                            metroTextBox3.Invoke(new MethodInvoker(delegate { pathFilename = metroTextBox3.Text; }));
                                        }

                                        int passFail = AcquisitionControl.SaveCESSpectrumFile(pathFilename);
                                        if (passFail == PASS)
                                        {
                                            UpdateMaintCheckMessage("Saved File at: " + pathFilename);
                                            Thread.Sleep(2000);
                                        }
                                        AcquisitionControl.SetCounter(2);

                                    }
                                    else if(AcquisitionControl.GetCounter()==2)
                                    {

                                        int aARetVal = AcquisitionControl.AutoAnalyze();
                                        UpdateMaintCheckMessage("Auto Analyze returned " + aARetVal.ToString());
                                        Logger.WriteLogFile("Perform Auto Analyze returned: " + aARetVal.ToString(), "c:/temp/ManualAcq.txt");
                                        Thread.Sleep(1500);
                                        AcquisitionControl.SetCounter(3);

                                    }


                                    else if (AcquisitionControl.GetCounter() == 3)
                                    {

                                        double presentVLocal = readInputVoltage;
                                        presentVLocal = presentVLocal * 50.0 / 10.0;

                                        double presentILocal = readInputCurrent;
                                        presentILocal = presentILocal * 2000.0 / 10.0;

                                        AcquisitionControl.RampXrays(presentVLocal, presentILocal, 0.0, 0.0, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);

                                        UpdateMaintCheckMessage("Ramping Xrays down");

                                        int rampCounter = 0;
                                        do
                                        {
                                            Thread.Sleep(1000);
                                            rampCounter++;
                                            Logger.WriteLogFile("Waiting for ramp to zero complete. Counter = " + rampCounter.ToString(), "c:/temp/ManualAcq.txt");


                                        } while (rampActive == 1 && rampCounter < 60);




                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(312);


                                    }



                                }
                                catch (Exception Ex)
                                {
                                    Logger.WriteLogFile("Error (310).  Ex = " + Ex.ToString(), "c:/temp/ManualAcq.txt");

                                }
                            }
                            break;

                        case 312:
                            {
                                try
                                {
                                    Logger.WriteLogFile( "Manual Acq Done.", "c:/temp/ManualAcq.txt");
                                    if (BackgroundManager.m_oWorkerManualAcq.IsBusy)
                                    {
                                        BackgroundManager.m_oWorkerManualAcq.CancelAsync();
                                    }
                                    UpdateMaintCheckMessage("Manual Acquire Done");

                                }
                                catch (Exception Ex)
                                {

                                    Logger.WriteLogFile( "Error:  Ex = " + Ex.ToString(), "c:/temp/ManualAcq.txt");
                                }


                            }
                            break;





                    }

                }

                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Ex in manual acq state machine Ex=" + Ex.ToString());
                    HaltManualAcq("Error in Manual Acq");

                }
                finally
                {
                    Logger.WriteLogFile("Done with Manaul Acq state task.", "c:/temp/ManualAcq.txt" );
                    Monitor.Exit(lockManualAcqObj);
                }
            }
            else
            {
                //lock not obtained for this timer.
                ManualAcqLockCounter++;
                if (ManualAcqLockCounter > 50)
                {
                    Logger.WriteLogFile("lock not obtained for Manual Acq timer....", "c:/temp/ManualAcq.txt");
                }
            }

    }

        // ****** end manual acq




        // *** start leak check state machine

        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <param name="e"></param>
        private void onLeakCheckTimedEvent(object source, ElapsedEventArgs e)
        {


            // only execute the code within this method if we are able to
            // a lock. This will ensure that any Timer firings will be
            // ignored that occur while we're already doing work (OnTimer) 

            // if (!Monitor.TryEnter(obj, 2000))
            // {
            //     throw new Exception("can not lock");
            // }

            if (Monitor.TryEnter(lockLeakCheckObj))
            {
                try
                {
                    // do work here

                    LeakCheckLockCounter = 0;

                    AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                    //fired every one second....
                    //string[] ManualAcqValues = new string[10];

                    //AcquisitionControl.IncTimerCounter();

                    //try
                    //{
                     //   int getState;
                        //private object lockObj;

                    //    getState = AcquisitionControl.GetState();
                    //    ManualAcqValues[0] = getState.ToString();

                    //}
                    //catch
                    //{
                    //    ManualAcqValues[1] = "message empty.";
                    //
                    //}

                    //BackgroundManager.m_oLeakCheck.ReportProgress(AcquisitionControl.GetState(), ManualAcqValues);




                    int curState = AcquisitionControl.GetState();


                    switch (curState)
                    {

                        case 400:
                            {

                                try
                                {

                                    //disable the text box and buttons for saving?
                                    if (AcquisitionControl.GetCounter() == 0)
                                    {
                                        UpdateFlowCalPromptMessage("Start Leak Check.");
                                        if (InvokeRequired)
                                        {
                                            tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Clear(); }));
                                        }
                                        else
                                        {
                                            tbMetroCalEntry.Clear();
                                        }



                                        Logger.WriteInternalLogFile("Starting Leak Check (400)");
                                        Thread.Sleep(1000);
                                        AcquisitionControl.SetCounter(1);
                                    }
                                    if (AcquisitionControl.GetCounter() == 1)
                                    {
                                        UpdateFlowCalPromptMessage("Move Nozzle Up");

                                        Thread.Sleep(1000);
                                        int return1031 = FAIL;
                                        int nzUpCounter = 0;
                                        do
                                        {
                                            return1031 = AcquisitionControl.NozzleUp(SerialManager, this);
                                            nzUpCounter += 1;
                                        } while (return1031 == FAIL && nzUpCounter <= 3);

                                        if (return1031 == PASS)
                                        {
                                            Logger.WriteInternalLogFile("Nozzle up (400)");
                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(401);
                                        }
                                        else
                                        {
                                            UpdateFlowCalPromptMessage("Error: Nozzle Up");
                                        }
                                    }
                                }
                                catch (Exception Ex)
                                {
                                    HaltManualAcq("Error Leak Check, Move Nozzle Up  Ex=" + Ex.ToString());

                                }

                            }
                            break;

                        case 401:
                            {

                                try
                                {
                                    if (AcquisitionControl.GetCounter() == 0)
                                    {
                                        Logger.WriteInternalLogFile("Starting Pump");
                                        AcquisitionControl.SetCounter(1);
                                    }
                                    else if (AcquisitionControl.GetCounter() == 1)
                                    {
                                        UpdateFlowCalPromptMessage("Starting Pump.");
                                        Thread.Sleep(1000);
                                        int return1031 = AcquisitionControl.PumpOn(m_oWorkerPump);
                                        if (return1031 == PASS)
                                        {
                                            Logger.WriteInternalLogFile("Pump On.");
                                            UpdateFlowCalPromptMessage("Pump On.");
                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(402);
                                        }
                                    }
                                }
                                catch (Exception Ex)
                                {
                                    HaltLeakCheck("Error Leak Check, Start Pump.   Ex=" + Ex.ToString());

                                }

                            }
                            break;
                        case 402:
                            {

                                try
                                {
                                    if (AcquisitionControl.GetCounter() == 0)
                                    {
                                        Logger.WriteInternalLogFile("Wait for flow to begin");
                                        AcquisitionControl.SetCounter(1);
                                    }
                                    else if (AcquisitionControl.GetCounter() == 1)
                                    {
                                        UpdateFlowCalPromptMessage("Close ball valve.");
                                        AcquisitionControl.SetCounter(2);
                                    }
                                    else if (AcquisitionControl.GetCounter()<60)
                                    {
                                        AcquisitionControl.SetCounter(AcquisitionControl.GetCounter() + 1);
                                        //if pressure is less than 130 continue....
                                        //check the sample pressure by reading the value displayed in the GUI
                                        UpdateFlowCalPromptMessage("Close Valve.  Waiting for Sample Press to drop.");
                                        //if (InvokeRequired)
                                        //{
                                            //double sampPress = 0.0;
                                            //if (InvokeRequired)
                                            //{
                                            //    mtbMaintCheckMessage.Invoke(new MethodInvoker(delegate { sampPress = Convert.ToDouble(tbMetroSamplePressureCal.Text); }));
                                            //}
                                            //else
                                            //{
                                            //sampPress = readOnlySamplePressureValue;//  Convert.ToDouble(tbMetroSamplePressureCal.Text);
                                            //}
                                            if (readOnlySamplePressureValue <=130.0)  //NOTE mmHg  (might need to accept Bar or Atm)
                                            {
  

                                                AcquisitionControl.SetCounter(0);
                                                AcquisitionControl.SetState(403);
                                            }
                                        //}                                                                                           
                                    }
                                    else
                                    { //time out 

                                        HaltLeakCheck("Pressure drop not less than expected value.");

                                    }
                                }
                                catch (Exception Ex)
                                {
                                    HaltLeakCheck("Error waiting for pressure drop.   Ex=" + Ex.ToString());

                                }

                            }
                            break;

                        case 403:
                            {

                                try
                                {
                                    if (AcquisitionControl.GetCounter() == 0)
                                    {
                                        Logger.WriteInternalLogFile("Turning Pump Off.");
                                    //}
                                    //else if (AcquisitionControl.GetCounter() == 1)
                                    //{

                                        UpdateFlowCalPromptMessage("Pump Off.   Close pump value.");
                                        AcquisitionControl.PumpOff(m_oWorkerPump);
                                        AcquisitionControl.SetCounter(1);
                                    }
                                    else if (AcquisitionControl.GetCounter() ==1)
                                    {
   
                                        //delay one seconds to allow pump to turn off
                                        AcquisitionControl.SetCounter(2);

                                    }
                                    else if (AcquisitionControl.GetCounter()==2)
                                    {
                                        //look for pressure to turn from decreasing to increasing
                                        double delta;
                                        double beforePress;
                                        double afterPress;
                                        int count = 0;

                                        do
                                        {
                                            beforePress = readOnlySamplePressureValue;
                                            Thread.Sleep(1000);
                                            afterPress = readOnlySamplePressureValue;
                                            delta = beforePress - afterPress;
                                            count += 1;
                                            Logger.WriteInternalLogFile("delta = " + delta.ToString("F2"));
                                            Logger.WriteInternalLogFile("before Pressure = " + beforePress.ToString("F2"));
                                            Logger.WriteInternalLogFile("after  Pressure = " + afterPress.ToString("F2"));
                                            Logger.WriteInternalLogFile("count = " + count.ToString("F2"));

                                        } while (delta > 0.0 && count < 15);

                                        samplePressureAtStart = readOnlySamplePressureValue;
                                        Logger.WriteInternalLogFile("sample Pressure = " + readOnlySamplePressureValue.ToString("F2"));
                                        UpdateFlowCalPromptMessage("Time Remaining:");
                                        if (InvokeRequired)
                                        {
                                            tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Text  = "Pressure at Start = "+samplePressureAtStart.ToString("F1"); }));
                                        }
                                        else
                                        {
                                            tbMetroCalEntry.Text = "Pressure at Start = " + samplePressureAtStart.ToString("F1");
                                        }
                                        AcquisitionControl.SetCounter(3);


                                    }






                                    else if (AcquisitionControl.GetCounter() < 90)
                                    {
                                        int timeRem = 90 - AcquisitionControl.GetCounter();
                                        UpdateFlowCalPromptMessage("Time Remaining:  " + timeRem.ToString()+ " seconds");
                                        AcquisitionControl.SetCounter(AcquisitionControl.GetCounter() + 1);
   

                                    }
                                    else if (AcquisitionControl.GetCounter()==90)
                                    {
   
                                        samplePressureAtEnd = readOnlySamplePressureValue;//Convert.ToDouble(tbMetroSamplePressureCal.Text);
     
                                        UpdateFlowCalPromptMessage("Recording Sample Pressure at End of Check.");
                                        Logger.WriteInternalLogFile("Sample Pressure at end = " + samplePressureAtEnd.ToString("F2"));




                                        if (InvokeRequired)
                                        {
                                            tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Text = "Pressure at Start = " + samplePressureAtStart.ToString("F1") + " at End = "+samplePressureAtEnd.ToString("F1"); }));
                                        }
                                        else
                                        {
                                            tbMetroCalEntry.Text = "Pressure at Start = " + samplePressureAtStart.ToString("F1") + " at End = " + samplePressureAtEnd.ToString("F1");                                        }


                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(404);
                                    }


                                }
                                catch (Exception Ex)
                                {
                                    HaltLeakCheck("Error waiting until 90s.   Ex=" + Ex.ToString());

                                }

                            }
                            break;

                        case 404:
                            {

                                try
                                {
                                    if (AcquisitionControl.GetCounter() == 0)
                                    {
                                        Logger.WriteInternalLogFile("Calculating Sample Pressure rate...");
                                        AcquisitionControl.SetCounter(1);
                                    }
                                    else if (AcquisitionControl.GetCounter() == 1)
                                    {
                                        double delta = samplePressureAtEnd - samplePressureAtStart;
                                        double rate = delta / 1.5;
                                        if(rate <=150.0)
                                        {
                                            string msg = "Leak Check:  PASS.  Rate = " + rate.ToString("F2");
                                            Logger.WriteLogFile( msg, "C:/Temp/LeakCheck.txt");
                                            UpdateFlowCalPromptMessage(msg);
                                        }
                                        else
                                        {
                                            string msg = "Leak Check:  FAIL.  Rate = " + rate.ToString("F2");
                                            Logger.WriteLogFile( msg, "C:/Temp/LeakCheck.txt");
                                            UpdateFlowCalPromptMessage(msg);

                                        }


                                        AcquisitionControl.SetCounter(2);
                                    }
                                    else if (AcquisitionControl.GetCounter() == 2)
                                    {

                                        //complete the test
                                        if (BackgroundManager.m_oLeakCheck.IsBusy)
                                        {
                                            BackgroundManager.m_oLeakCheck.CancelAsync();
                                        }

                                    }


                                }
                                catch (Exception Ex)
                                {
                                    HaltLeakCheck("Error completing leak check.   Ex = " + Ex.ToString());

                                }

                            }
                            break;

                    }



                }

                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Ex in Leak Check state machine Ex=" + Ex.ToString());
                    HaltManualAcq("Error in LeakCheck");

                }
                finally
                {
                    Logger.WriteInternalLogFile("Done with Leak Check state task.");
                    Monitor.Exit(lockLeakCheckObj);
                }
            }
            else
            {
                LeakCheckLockCounter++;
                if (LeakCheckLockCounter > 50)
                {
                    //lock not obtained for this timer.
                    Logger.WriteInternalLogFile("lock not obtained for Leak Check timer....");
                }
            }


        }

        // *** end leak check state machine


        // *** start tube seasoning state machine
        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <param name="e"></param>
        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <param name="e"></param>
        private void onTubeSeasoningTimedEvent(object source, ElapsedEventArgs e)
        {



            if (Monitor.TryEnter(lockTubeSeasoningObj))
            {
                try
                {
                    // do work here
                    TubeSeasoningLockCounter = 0;


                    AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                    int curState = AcquisitionControl.GetStateTS();


                    switch (curState)
                    {
                        case 500:
                            {
                                try
                                {
                                    //disable the text box and buttons for saving?
                                    if (AcquisitionControl.GetCounterTS() == 0)
                                    {
                                        //always start tube seasoning from the lowest power value
                                        TubeSeasoningIndex = 0;
                                        //if (TubeSeasoningTime == 15)
                                        //{
                                        //    waitTime = ((15.0) / 8.0) * 60.0;
                                        //}
                                        //else
                                        //{
                                            UpdateMaintCheckMessage("Start Tube Seasoning");
                                            if (manualTubeSeasoning == 1)
                                            {
                                                waitTime = ((40.0) / 8.0) * 60.0;
                                            }
                                            else if (manualWarmUp == 1)
                                            {
                                                waitTime = (ManualWarmUpTime / 8.0) * 60.0;

                                            }
                                            else if (AcquisitionControl.GetSamplePeriod() == 5)
                                            {
                                                waitTime = ((5.0 - 1.0) / 8.0) * 60.0;  //ten min is required, but the 8 steps happen in 4 min
                                            }

                                            else if (AcquisitionControl.GetSamplePeriod() == 15 || AcquisitionControl.GetSamplePeriod()==77)
                                            {
                                                waitTime = ((15.0 - 3.0) / 8.0) * 60.0;
                                            }
                                            else if (AcquisitionControl.GetSamplePeriod() == 30)
                                            {

                                                waitTime = ((30.0 - 3.0) / 8.0) * 60.0;
                                            }
                                            else
                                            {
                                                waitTime = ((40.0 - 3.0) / 8.0) * 60.0;

                                            }
                                        //}


                                            if (manualTubeSeasoning == 1)
                                            {
                                                Logger.WriteInternalLogFile("Start manual tube seasoning, state = 500");
                                                Logger.WriteLogFile("Start manual tube seasoning, state = 500");

                                            }
                                            else
                                            {
                                                Logger.WriteInternalLogFile("Start automatic tube seasoning, state = 500");
                                                Logger.WriteLogFile("Start automatic tube seasoning, state = 500");
                                            }
                                        //}
                                        AcquisitionControl.SetStateTS(501);
                                        AcquisitionControl.SetCounterTS(0);
                                    }

                                }
                                catch (Exception Ex)
                                {
                                    HaltTubeSeasoning("Error Tube Seasoning, Ex = " + Ex.ToString());
                                    Logger.WriteInternalLogFile("Error Tube Seasoning, Ex = " + Ex.ToString());

                                }

                            }
                            break;

                        case 501:
                            {

                                try
                                {

                                    if (AcquisitionControl.GetCounterTS() < 3)
                                    {
                                        int destinationV = TubeSeasoningkVArray[TubeSeasoningIndex];
                                        int destinationI = TubeSeasoninguAArray[TubeSeasoningIndex];
                                        tubeSeasoningStartTime = DateTime.Now;


                                        //
                                        //
                                        tubeSeasoningEndTime = tubeSeasoningStartTime.AddSeconds(Convert.ToInt32(waitTime));
                                        //
                                        //


                                        UpdateMaintCheckMessage("Setting Xrays to (" + destinationV.ToString() + " kV and " + destinationI.ToString() + " uA)");

                                        double presentV = readInputVoltage;
                                        presentV = presentV * 50.0 / 10.0;


                                        double presentI = readInputCurrent;
                                        presentI = presentI * 2000.0 / 10.0;


                                        Logger.WriteInternalLogFile("Tube Seasoning ramp V from: " + presentV.ToString("F2") + " to: " + destinationV.ToString("F2"));
                                        Logger.WriteLogFile("Tube Seasoning ramp V from: " + presentV.ToString("F2") + " to: " + destinationV.ToString("F2"));
                                        Logger.WriteInternalLogFile("Tube Seasoning ramp I from: " + presentI.ToString("F2") + " to: " + destinationI.ToString("F2"));
                                        Logger.WriteLogFile("Tube Seasoning ramp I from: " + presentI.ToString("F2") + " to: " + destinationI.ToString("F2"));
                                        int returnVal = AcquisitionControl.RampXrays(presentV, presentI, destinationV, destinationI, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                                        if (returnVal == PASS)
                                        {
                                            AcquisitionControl.SetCounterTS(0);
                                            AcquisitionControl.SetStateTS(502);


                                        }
                                        else
                                        {
                                            AcquisitionControl.SetCounterTS(AcquisitionControl.GetCounterTS() + 1);
                                        }
                                    }
                                    else
                                    {
                                        HaltTubeSeasoning("Error Tube Seasoning, fail to ramp xrays");
                                        Logger.WriteInternalLogFile("Error Tube Seasoning, fail to ramp xrays");

                                    }
                                }
                                catch (Exception Ex)
                                {
                                    HaltTubeSeasoning("Error Tube Seasoning, Ex = " + Ex.ToString());
                                    Logger.WriteInternalLogFile("Error Tube Seasoning, Ex = " + Ex.ToString());

                                }

                            }
                            break;
                        case 502:
                            {

                                try
                                {
                                    if (AcquisitionControl.GetCounterTS() == 0)
                                    {

                                        //provide countdown
                                        var TimeRemaining = tubeSeasoningEndTime - System.DateTime.Now;
                                        UpdateMaintCheckMessage((TubeSeasoningIndex + 1).ToString() + " of " + TubeSeasoningkVArray.Length.ToString() + " Time Remaining: " + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"));
                                        if (TimeRemaining.Seconds % 10 == 0)
                                        {
                                            Logger.WriteInternalLogFile("TS Time Remaining = " + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"));
                                            Logger.WriteLogFile("TS Time Remaining = " + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"));
                                        }
                                        if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
                                        {
                                            UpdateMaintCheckMessage("Done with " + (TubeSeasoningIndex + 1).ToString() + " of " + TubeSeasoningkVArray.Length.ToString());
                                            Logger.WriteInternalLogFile("Done with " + (TubeSeasoningIndex + 1).ToString() + " of " + TubeSeasoningkVArray.Length.ToString());
                                            Logger.WriteLogFile("Done with " + (TubeSeasoningIndex + 1).ToString() + " of " + TubeSeasoningkVArray.Length.ToString());
                                            AcquisitionControl.SetStateTS(503);
                                            AcquisitionControl.SetCounterTS(0);
                                        }
                                    }
                                }
                                catch (Exception Ex)
                                {
                                    HaltTubeSeasoning("Error in tube seasoning, Ex = " + Ex.ToString());
                                    Logger.WriteInternalLogFile("Error in tube seasoning, Ex = " + Ex.ToString());
                                }

                            }
                            break;

                        case 503:
                            {
                                try
                                {
                                    if (AcquisitionControl.GetCounterTS() == 0)
                                    {
                                        Logger.WriteInternalLogFile("Check for tube seasoning complete.");
                                        TubeSeasoningIndex = TubeSeasoningIndex += 1;
                                        if (TubeSeasoningIndex >= TubeSeasoningkVArray.Length)
                                        {
                                            //UpdateMaintCheckMessage("Tube Seasoning Complete.");
                                            AcquisitionControl.SetStateTS(504);
                                            AcquisitionControl.SetCounterTS(0);
                                        }
                                        else
                                        {
                                            //UpdateMaintCheckMessage("");
                                            AcquisitionControl.SetStateTS(501);
                                            AcquisitionControl.SetCounterTS(0);
                                        }
                                    }
                                }
                                catch (Exception Ex)
                                {
                                    HaltTubeSeasoning("Error Tube Seasoning.  Ex = " + Ex.ToString());
                                    Logger.WriteInternalLogFile("Error Tube Seasoning.  Ex = " + Ex.ToString());

                                }

                            }
                            break;

                        case 504:
                            {

                                try
                                {
                                    if (AcquisitionControl.GetCounterTS() == 0)
                                    {
                                        Logger.WriteInternalLogFile("Tube seasoning completed.");
                                        Logger.WriteLogFile( "Tube seasoning completed.");
                                        UpdateMaintCheckMessage("Tube seasoning completed");
                                        AcquisitionControl.SetCounterTS(1);

                                    }
                                    else if (AcquisitionControl.GetCounterTS() ==1)
                                    {

                                        //UpdateMaintCheckMessage("Tube Seasoning Done. ");
                                        //double presentV = readInputVoltage;
                                        //presentV = presentV * 50.0 / 10.0;

                                        //double presentI = readInputCurrent;
                                        //presentI = presentI * 2000.0 / 10.0;

                                        //Logger.WriteInternalLogFile("Tube Seasoning ramp V from: " + presentV.ToString("F2") + " to: 0.00");
                                        //Logger.WriteInternalLogFile("Tube Seasoning ramp I from: " + presentI.ToString("F2") + " to: 0.00");
                                        //int returnValZero = AcquisitionControl.RampXrays(presentV, presentI, 0, 0, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                                        //if (returnValZero == PASS)
                                        //{
                                        AcquisitionControl.SetCounterTS(2);
                                        if (BackgroundManager.m_oWorkerTubeSeasoning.IsBusy)
                                        {
                                            BackgroundManager.m_oWorkerTubeSeasoning.CancelAsync();
                                        }

                                        if (InvokeRequired)
                                        {
                                            mbTubeSeasoning.Invoke(new MethodInvoker(delegate { mbTubeSeasoning.Text = "Tube Seasoning"; }));
                                        }
                                        else
                                        {
                                            mbTubeSeasoning.Text = "Tube Seasoning";
                                        }
                                        //                                            mbTubeSeasoning.Text = "Tube Seasoning";
                                        //UpdateMaintCheckMessage("Tube Seasoning Done. ");

                                        //}
                                        //else
                                        //{
                                        //    AcquisitionControl.SetCounter(AcquisitionControl.GetCounter() + 1);
                                        //    Thread.Sleep(3000);
                                        //}


                                    }


                                }
                                catch (Exception Ex)
                                {
                                    HaltTubeSeasoning("Ex in shut down X-rays   Ex = " + Ex.ToString());
                                    if (BackgroundManager.m_oWorkerTubeSeasoning.IsBusy)
                                    {
                                        BackgroundManager.m_oWorkerTubeSeasoning.CancelAsync();
                                    }
                                }

                            }
                            break;

                    }



                }

                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Ex in Tube Seasoning state machine Ex = " + Ex.ToString());
                    HaltManualAcq("Error in Tube Seasoning.  Ex = " + Ex.ToString());

                }
                finally
                {
                    //Logger.WriteInternalLogFile("Done with Tube Seasoning state task.");
                    Monitor.Exit(lockTubeSeasoningObj);
                }
            }
            else
            {
                TubeSeasoningLockCounter++;
                if (TubeSeasoningLockCounter > 50)
                {
                    //lock not obtained for this timer.
                    Logger.WriteInternalLogFile("lock not obtained for Tube Seasoning timer....");
                }
            }


        }

        // *** end tube seasoning state machine



        // *** start Five Minute state machine
        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <param name="e"></param>
        private void onFiveMinuteTimedEvent(object source, ElapsedEventArgs e)
        {



            if (Monitor.TryEnter(lockFiveMinuteObj))
            {


                try
                {
                    // do work here
                    FiveMinuteLockCounter = 0;
                    fiveMinuteCounter++;
                    if(fiveMinuteCounter>=180)  //was five minute (300)
                    {

                        Logger.WriteLogFile(   "Signal modbus data addr 700 = 0");

                        AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                        DataStore xactHoldingRegisters = AcquisitionControl.getDataStore();
                        ushort[] oneValue = new ushort[1] { 0 };
                        nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, oneValue, 700); // turn off Modbus registers updated signal 
                        fiveMinuteCounter = 301;
                        

                    }




                    /*                    switch (curState)
                                        {

                                            case 500:
                                                {
                                                    try
                                                    {
                                                        if (AcquisitionControl.GetCounter() == 0)
                                                        {
                                                            UpdateMaintCheckMessage("Start Tube Seasoning.");
                                                            Logger.WriteInternalLogFile("Start tube seasoning, state = 500");
                                                            Thread.Sleep(1000);
                                                            AcquisitionControl.SetState(501);
                                                            AcquisitionControl.SetCounter(0);
                                                        }

                                                    }
                                                    catch (Exception Ex)
                                                    {
                                                        HaltTubeSeasoning("Error Tube Seasoning, Ex = " + Ex.ToString());
                                                        Logger.WriteInternalLogFile("Error Tube Seasoning, Ex = " + Ex.ToString());

                                                    }

                                                }
                                                break;


                                                    }
                                                    catch (Exception Ex)
                                                    {
                                                        HaltTubeSeasoning("Ex in shut down X-rays   Ex = " + Ex.ToString());
                                                        BackgroundManager.m_oWorkerTubeSeasoning.CancelAsync();
                                                    }

                                                }
                                                break;

                                        }
                    */


                }

                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Ex in Five Minute thread Ex = " + Ex.ToString());
                    HaltManualAcq("Error in Tube Seasoning.  Ex = " + Ex.ToString());

                }
                finally
                {
                    //Logger.WriteInternalLogFile("Done with Five Minute task.");
                    Monitor.Exit(lockFiveMinuteObj);
                }
            }
            else
            {
                FiveMinuteLockCounter++;
                if (FiveMinuteLockCounter > 50)
                {
                    //lock not obtained for this timer.
                    Logger.WriteInternalLogFile("lock not obtained for Five Minute timer....");
                }
            }


        }



        // *** end FiveMinute timer








        //****************************************** start ecal state machine


        private void onEcalTimedEvent(object source, ElapsedEventArgs e)
        {


            // only execute the code within this method if we are able to
            // a lock. This will ensure that any Timer firings will be
            // ignored that occur while we're already doing work (OnTimer) 

            // if (!Monitor.TryEnter(obj, 2000))
            // {
            //     throw new Exception("can not lock");
            // }

            if (Monitor.TryEnter(lockEcalObj))
            {
                try
                {
                    // do work here
                    EcalLockCounter = 0;

                    AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                    //fired every one second....
                    string[] EcalValues = new string[10];

                    AcquisitionControl.IncTimerCounter();

                    try
                    {
                        int getState;
                        //private object lockObj;

                        getState = AcquisitionControl.GetState();
                        EcalValues[0] = getState.ToString();

                    }
                    catch
                    {
                        EcalValues[1] = "message empty.";

                    }

                    BackgroundManager.m_oWorkerEcal.ReportProgress(AcquisitionControl.GetState(), EcalValues);




                    int curState = AcquisitionControl.GetState();


                    switch (curState)
                    {
                        case 100:
                            {
                                Logger.WriteLogFile("state = 100.", "c:/temp/ManualEcal.txt" );
                                UpdateMaintCheckMessage("Move Dynamic Rod Home");                       

                                int returnVal = AcquisitionControl.MoveRodHome(SerialManager, this);
                                Logger.WriteLogFile("move DR home returned: " + returnVal.ToString(), "c:/temp/ManualEcal.txt" );
                                if (returnVal == PASS)
                                {
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(101);

                                }
                                else
                                {
                                    AcquisitionControl.SetCounter((AcquisitionControl.GetCounter() + 1));
                                    if (AcquisitionControl.GetCounter() >= 3)
                                    {
                                        HaltManualEcal("Error:  Move DR home failed");
                                    }
                                    else
                                    {  //retry
                                        AcquisitionControl.SetState(100);
                                        //Logger.WriteErrorFile("Error: Manual Ecal (100)  Move Dynamic Rod home.");
                                        Logger.WriteLogFile("Error: Manual Ecal (100)  Move Dynamic Rod home.", "c:/temp/ManualAcq.txt");

                                        UpdateMaintCheckMessage("Error:  Move Dynamic Rod Home");
                                    }
                                }
                                break;

                            }
                        case 101:
                            {
                                Logger.WriteLogFile( "state = 101.", "c:/temp/ManualEcal.txt");
                                UpdateMaintCheckMessage("Move Dynamic Rod to Ecal");

                                int returnVal = AcquisitionControl.MoveRod(SerialManager,Properties.Settings.Default.EcalRodPosition, this);
                                Logger.WriteLogFile( "move DR to Manual Ecal function returned: " + returnVal.ToString(), "c:/temp/ManualEcal.txt");

                                int getRodPositionValue = AcquisitionControl.PollMotorPosition(4, SerialManager);

                                //check for stable position read 
                                //int posOld = 0;
                                //int posNew = 1;
                                //int retv = FAIL;
                                //int counter = 0;
                                //int sameCounter = 0;
                                //int getRodPositionValue = 0;
                                //do
                                //{
                                //    retv = AcquisitionControl.CheckMotorPosition(SerialManager, 4, out getRodPositionValue);
                                //    if (retv == PASS)
                                //    {
                                //        posNew = getRodPositionValue;
                                //    }

                                //    if (posNew == posOld)
                                //    {
                                //        sameCounter++;
                                //        if (sameCounter >= 3)
                                //        {
                                //            break;
                                //        }
                                //    }

                                //    posOld = posNew;
                                //    counter++;
                                //    Thread.Sleep(500);
                                //} while (counter < 60);






                                //int position = 0;
                                //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                                //int returnVal27 = AcquisitionControl.CheckMotorPosit(SerialManager, 4, out position);
                                Logger.WriteLogFile( "Check DR motor position returned:  " + getRodPositionValue.ToString(), "c:/temp/ManualEcal.txt");

                                //Logger.WriteLogFile(   "EC " + "init" + " (destination) motor position, after home = " + position.ToString());
                                UpdateDynamicRodMessage("Dynamic Rod at position:  " + getRodPositionValue.ToString() );


                                if (getRodPositionValue == Properties.Settings.Default.EcalRodPosition) 
                                {
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(102);

                                }
                                else
                                {
                                    AcquisitionControl.SetCounter((AcquisitionControl.GetCounter() + 1));
                                    if (AcquisitionControl.GetCounter() >= 3)
                                    {
                                        HaltManualEcal("Error:  Move DR to Ecal");
                                    }
                                    else
                                    {  //retry
                                        AcquisitionControl.SetState(101);
                                        Logger.WriteErrorFile("Error:  Manual Ecal (101) move Dynamic Rod to Ecal Pos. DR= ("+getRodPositionValue.ToString()+") Expected= ("+Properties.Settings.Default.EcalRodPosition.ToString()+")" );
                                        UpdateMaintCheckMessage("Error:  Move Dynamic Rod Ecal Pos "+getRodPositionValue.ToString());
                                    }
                                }

                                break;
                            }



                        case 102:  //ecal
                                   //set xray variables
                            {
                                int destinationV = Properties.Settings.Default.EcalkV;
                                int destinationI = Properties.Settings.Default.EcaluA;

                                UpdateMaintCheckMessage("Setting Xrays to Ecal (" + destinationV.ToString() + " kV and " + destinationI.ToString() + " uA)");

                                double presentV = readInputVoltage;
                                presentV = presentV * 50.0 / 10.0;


                                double presentI = readInputCurrent;
                                presentI = presentI * 2000.0 / 10.0;


                                Logger.WriteLogFile( "ECAL ramp V from: " + presentV.ToString("F2") + " to: " + destinationV.ToString("F2"), "c:/temp/ManualEcal.txt");
                                Logger.WriteLogFile( "ECAL ramp I from: " + presentI.ToString("F2") + " to: " + destinationI.ToString("F2"), "c:/temp/ManualEcal.txt");
                                int returnVal25 = AcquisitionControl.RampXrays(presentV, presentI, destinationV, destinationI, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                                if (returnVal25==PASS)
                                {
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(103);

                                }
                                else
                                {
                                    HaltManualEcal("Manual Ecal Error:  Ramp Xrays");
                                }


                            }

                            break;

                        case 103:
                            {

                                Logger.WriteLogFile("state = 102. loading master tfr file", "c:/temp/ManualEcal.txt" );

                                //if (AcquisitionControl.GetCounter() == 0)
                                //{
                                    UpdateMaintCheckMessage("Loading Master TFR file");
                                    //AcquisitionControl.SetCounter(1);
                                //}


                                int energyCondition = 1;
                                int returnVal102 = AcquisitionControl.LoadMTFRFile(energyCondition);
                                if (returnVal102 == PASS)
                                {
                                    Logger.WriteLogFile("(102) load MFTRFile + cond code returned: true", "c:/temp/ManualEcal.txt" );
                                    UpdateMaintCheckMessage("load TRF File + cond code returned:  true");
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(104);

                                }
                                else
                                {

                                    Logger.WriteErrorFile("Error: Control state 103 Unable to load master tfr file 1");
                                    Logger.WriteLogFile("Error: Control state 103 Unable to load master tfr file 1");

                                    UpdateMaintCheckMessage("Error:  load master TFR file 1");
                                    HaltManualEcal("Error:  load master TFR file 1");

                                }
                            }
                            break;
                        case 104:
                            {
                                UpdateMaintCheckMessage("Move FW Home");
                                int return1031 = AcquisitionControl.MoveFWHome(SerialManager, this);

                                UpdateMaintCheckMessage("Move FW to EC1");
                                int return1032 = AcquisitionControl.MoveFWEC(SerialManager, 0, 1, this); 
                                if (return1031==PASS && return1032==PASS)
                                {
                                    int position = AcquisitionControl.PollMotorPosition(1, SerialManager);

                                    ////check motor position
                                    //int position = 0;
                                    //int positionold = 0;
                                    //int posCounter = 0;
                                    //do
                                    //{
                                    //    int returnVal27 = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);  //1=FW
                                    //    Logger.WriteLogFile("EC " + fwECend.ToString() + " (destination) motor position, after move = " + position.ToString(), "c:/temp/ManualAcq.txt");
                                    //    Logger.WriteLogFile("Check FW motor postion returned: " + returnVal27.ToString(), "c:/temp/ManualAcq.txt");

                                    //    if ((position > 0) && (positionold > 0) && (position == positionold))
                                    //    {
                                    //        break;
                                    //    }
                                    //    positionold = position;
                                    //    Thread.Sleep(1000);
                                    //    posCounter++;
                                    //} while (posCounter < 30);



                                    if (position.ToString().Contains(Properties.Settings.Default.FWEC1.ToString()))
                                    {
                                        //UpdateOperationMessage("Move FW to EC1 Pass");
                                        UpdateMaintCheckMessage("Move FW to EC1 Pass");
                                        UpdateFilterWheelMessage("FW at EC1 (" + Properties.Settings.Default.FWEC1.ToString() + ")");
                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(105);
                                    }
                                    else
                                    {

                                        HaltManualEcal("Error: Failed to move FW to EC1");

                                    }
                                }
                                else
                                {

                                    HaltManualEcal("Error: Move FW ");
                                }







                            }
                            break;

                        case 105:

                            {
                                    if (AcquisitionControl.GetCounter() == 0)
                                    {

                                    Logger.WriteLogFile("state = 105. Start and Wait for ec time to expire.", "c:/temp/ManualEcal.txt" );
                                    UpdateMaintCheckMessage("Start Acq and wait...");


                                    ec1time = DateTime.Now.AddSeconds(Properties.Settings.Default.EcalTime);
                                        TimeSpan time = ec1time - DateTime.Now;
                                        Logger.WriteLogFile( "EC1 ECAL start time: " + DateTime.Now.ToString(), "c:/temp/ManualEcal.txt");
                                        UpdateMaintCheckMessage("EC1 ECAL start time: " + DateTime.Now.ToString());
                                        
                                        float kV;
                                        string kVs;
                                        if (mtbIOActualkV.InvokeRequired)
                                        {
                                            mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                        }
                                        else
                                        {
                                            actualValueV = mtbIOActualkV.Text;
                                        }

                                        kVs = actualValueV;
                                        kV = Convert.ToSingle(kVs);
                                        bool boolresponse_kV = myxrsfp.Send_kV[kV];
                                        float uA;
                                        string uAs;
                                        if (mtbIOActualuA.InvokeRequired)
                                        {
                                            mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                        }
                                        else
                                        {
                                            actualValueI = mtbIOActualuA.Text;
                                        }
                                        uAs = actualValueI;
                                        uA = Convert.ToSingle(uAs);
                                        bool boolresponse_uA = myxrsfp.Send_uA[uA];


                                     //AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) );
                                    AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) + (time.Hours * 3600));
                                    Thread.Sleep(3000);
                                    float deadTime = 0;
                                    if (Properties.Settings.Default.EC1AC.Contains("ON"))
                                    {

                                        AcquisitionControl.AutoCurrent((readInputCurrent * 2000.0 / 10.0), (readInputVoltage * 50.0 / 10.0), m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                                        //float kV;
                                        //string kVs;
                                        //tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Text = Tnistvalue.ToString(); }));//sets the value
                                        //string actualValue;
                                        if (mtbIOActualkV.InvokeRequired)
                                        {
                                            mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                        }
                                        else
                                        {
                                            actualValueV = mtbIOActualkV.Text;
                                        }

                                        kVs = actualValueV;
                                        kV = Convert.ToSingle(kVs);
                                        boolresponse_kV = myxrsfp.Send_kV[kV];
                                        if (mtbIOActualuA.InvokeRequired)
                                        {
                                            mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                        }
                                        else
                                        {
                                            actualValueI = mtbIOActualuA.Text;
                                        }
                                        uAs = actualValueI;
                                        uA = Convert.ToSingle(uAs);
                                        boolresponse_uA = myxrsfp.Send_uA[uA];
                                    }
                                    else
                                    {
                                        deadTime = AcquisitionControl.GetDeadTime();
                                    }
                                    Logger.WriteLogFile( "Manual ECAL dead time = " + deadTime.ToString("F2"), "c:/temp/ManualEcal.txt");








                                    AcquisitionControl.SetCounter(1);
                                    }

                                    var TimeRemaining = ec1time - System.DateTime.Now;

                                    UpdateMaintCheckMessage( "Time Remaining ECAL EC1 = " + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"));
                                    if (TimeRemaining.Seconds % 10 == 0)
                                    {
                                       Logger.WriteLogFile( "Time Remaining ECAL EC1 = " + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"), "c:/temp/ManualEcal.txt");
                                    }
                                    if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
                                    {
                                        //displayActionQueue.Enqueue("End ECAL EC1.");
                                        UpdateMaintCheckMessage("End Ecal EC1");
                                        Logger.WriteLogFile( "End EC1, save spec Raw and Adj, calling auto analyze.", "c:/temp/ManualEcal.txt");

                                        UpdateMaintCheckMessage("Perform Ecal.");



                                        //bool result = AcquisitionControl.PerformManualEcal(this);


                                    float FGainReturn = 0f;

                                    float FOffsetReturn = 0f;

                                    bool result = AcquisitionControl.PerformEcal(out FGainReturn, out FOffsetReturn, "c:/temp/ManualEcal.txt");

                                    UpdateMaintCheckMessage("Gain = " + FGainReturn.ToString("F2") + " Offset = " + FOffsetReturn.ToString("F2"));
                                        saveGainOffset = mtbMaintCheckMessage.Text;
                                        Logger.WriteLogFile( "Perform Ecal return value = " + result.ToString(), "c:/temp/ManualEcal.txt");

                                        UpdateMaintCheckMessage("Saving Ecal_Data_Raw spectrum");
                                        Thread.Sleep(250); 
                                        AcquisitionControl.SaveCESSpectrumRaw("c:/Ecal_Data_Raw", "sp_data", 1);
                                        UpdateMaintCheckMessage("Adjusting Spectrum");
                                        Thread.Sleep(250);
                                        AcquisitionControl.AdjustSpectrum();

                                        UpdateMaintCheckMessage("Saving Ecal Adjusted spectrum");
                                        Thread.Sleep(250);
                                        AcquisitionControl.SaveCESSpectrum("c:/Ecal_Data", "sp_data", 1);

                                    //dont immediately go on--check results like normal state machine: 
                                    //AcquisitionControl.SetCounter(0);
                                    ///AcquisitionControl.SetState(106);
                                    //
                                    //if (FOffsetReturn > -50.0 && FOffsetReturn < 0 )
                                        if (FOffsetReturn >= -100.0 && FOffsetReturn <= 100)
                                        {
                                            if (FGainReturn > -100.0 && FGainReturn < 100.0)      
                                            {
                                            UpdateMaintCheckMessage("Manual Ecal.  Pass.");
                                            // note this block returns only FWHM for Mn a Cross code change would be necessary for 
                                            // returning the FWHM for Cr and/or Nb
                                            //float fcr = 0.0f;
                                            //float fnb = 0.0f;
                                            //AcquisitionControl.ReadFWHM(out fcr,out fnb);

                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(106);

                                        }
                                        else
                                        {
                                            //UpdateMaintCheckMessage("Ecal Gain out of Range.  Gain = " + FGainReturn.ToString("F2"));
                                            UpdateMaintCheckMessage("Invalid Gain(" + FGainReturn.ToString("F2") + ") Reset to default.");
                                            saveGainOffset = mtbMaintCheckMessage.Text;

                                            Logger.WriteLogFile( "Invalid Ecal Gain.  Out of Range.  Gain = " + FGainReturn.ToString("F2"), "c:/temp/ManualEcal.txt");
                                            Logger.WriteLogFile( "Setting Gain and offset to default values.", "c:/temp/ManualEcal.txt");
                                            //need to set gain and offset to default reasonable value
                                            //write to cross via com interface and to the cross ini file
                                            //this.SetAlarmValue(109);
                                            //this.WriteAlarmToModbus(109);
                                            Logger.WriteLogFile( "Setting Gain and offset to default values.", "c:/temp/ManualEcal.txt");

                                            AcquisitionControl.DefaultGainAndOffset();

                                            HaltManualEcal("Invalid Ecal.  Gain = " + FGainReturn.ToString("F2") + "  Offset = " + FOffsetReturn.ToString("F2"));
                                            //AcquisitionControl.SetCounter(0);
                                            //AcquisitionControl.SetState(106);


                                        }
                                    }
                                    else
                                    {

                                        UpdateMaintCheckMessage("Invalid Offset (" + FOffsetReturn.ToString("F2") + ") Reset to default.");
                                        saveGainOffset = mtbMaintCheckMessage.Text;

                                        Thread.Sleep(2000);
                                        //UpdateMaintCheckMessage("Setting Gain and Offset to default values");

                                        Logger.WriteLogFile( "Ecal Offset out of Range.  Offset = " + FOffsetReturn.ToString("F2"), "c:/temp/ManualEcal.txt");
                                        Logger.WriteLogFile( "Setting Gain and offset to default values.", "c:/temp/ManualEcal.txt");
                                        //need to set gain and offset to default reasonable value
                                        //write to cross via com interface and to the cross ini file
                                        //this.SetAlarmValue(109);
                                        //this.WriteAlarmToModbus(109);
                                        Logger.WriteLogFile( "Setting Gain and Offset to default values.", "c:/temp/ManualEcal.txt");

                                        AcquisitionControl.DefaultGainAndOffset();

                                        HaltManualEcal("Invalid Ecal.  Gain = " + FGainReturn.ToString("F2") + "  Offset = " + FOffsetReturn.ToString("F2"));



                                    }


                                }
                            }
                                break;


                        case 106:
                            {
                                Logger.WriteLogFile( "state = 106.", "c:/temp/ManualEcal.txt");
                                UpdateMaintCheckMessage("Move Dynamic Rod Home");

                                int returnVal = AcquisitionControl.MoveRodHome(SerialManager, this);
                                Logger.WriteLogFile("move DR home returned: " + returnVal.ToString(), "c:/temp/ManualEcal.txt" );
                                if (returnVal == PASS)
                                {
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(107);

                                }
                                else
                                {
                                    AcquisitionControl.SetCounter((AcquisitionControl.GetCounter() + 1));
                                    if (AcquisitionControl.GetCounter() >= 3)
                                    {
                                        HaltManualEcal("Error:  Move DR home failed");
                                    }
                                    else
                                    {  //retry
                                        AcquisitionControl.SetState(106);
                                        Logger.WriteErrorFile("Error:  Manual Ecal (106) Move Dynamic Rod home.");
                                        UpdateMaintCheckMessage("Error:  Move Dynamic Rod Home");
                                    }
                                }





                            }
                            break;

                        case 107:
                            {
                                //Logger.WriteLogFile( "state = 107.", "c:/temp/ManualEcal.txt");
                                //UpdateMaintCheckMessage("Move Dynamic Rod Home");

                                //int returnVal = AcquisitionControl.MoveRodHome(SerialManager, this);
                                //Logger.WriteLogFile("move DR home returned: " + returnVal.ToString(), "c:/temp/ManualEcal.txt" );
                                //if (returnVal == PASS)
                                //{
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(108);

                                //}
                                //else
                                //{
                                 //   AcquisitionControl.SetCounter((AcquisitionControl.GetCounter() + 1));
                                 //   if (AcquisitionControl.GetCounter() >= 3)
                                 //   {
                                //        HaltManualEcal("Error:  Move DR home failed");
                                //    }
                                //    else
                                //    {  //retry
                                //        AcquisitionControl.SetState(107);
                                //        Logger.WriteErrorFile("Error:  Manual Ecal (107) Move Dynamic Rod home.");
                                //        UpdateMaintCheckMessage("Error:  Move Dynamic Rod Home");
                                //    }
                                //}
                                break;

                            }


                        case 108:
                            {


                                UpdateMaintCheckMessage("Manual Ecal Done.");
                                Logger.WriteLogFile("Manual Ecal Done.", "c:/temp/ManualEcal.txt");
                                try
                                {
                                    UpdateMaintCheckMessage(saveGainOffset);
                                    if (BackgroundManager.m_oWorkerEcal.IsBusy)
                                    {
                                        BackgroundManager.m_oWorkerEcal.CancelAsync();
                                    }
                                }
                                catch
                                {

                                }
                                //UpdateMaintCheckMessage(saveGainOffset);
                                
                            }
                            break;
                    }
                }
                catch (Exception Ex)
                {

                    Logger.WriteInternalLogFile("Exception in Manual Ecal state machine logic.  Ex = " + Ex.ToString());
                }
                finally
                {
                    Logger.WriteLogFile("Done with Ecal state task.", "c:/temp/ManualEcal.txt" );
                    Monitor.Exit(lockEcalObj);
                }
            }
            else
            {
                EcalLockCounter++;
                if (EcalLockCounter > 50)
                {
                    //lock not obtained for this timer.
                    Logger.WriteInternalLogFile("Lock not obtained for ManualEcal timer....");
                }
            }
        }


        //****************************************** end ecal state machine



        //*********************************** start upscale state machine *********************************


        private void onUpscaleTimedEvent(object source, ElapsedEventArgs e)
        {



            // only execute the code within this method if we are able to
            // a lock. This will ensure that any Timer firings will be
            // ignored that occur while we're already doing work (OnTimer) 

            // if (!Monitor.TryEnter(obj, 2000))
            // {
            //     throw new Exception("can not lock");
            // }

            if (Monitor.TryEnter(lockUpscaleObj))
            {
                try
                {
                    // do work here
                    UpscaleLockCounter = 0;

                    AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                    //fired every one second....
                    string[] UpscaleValues = new string[10];

                    AcquisitionControl.IncTimerCounter();

                    try
                    {
                        int getState;
                        //private object lockObj;

                        getState = AcquisitionControl.GetState();
                        UpscaleValues[0] = getState.ToString();

                    }
                    catch
                    {
                        UpscaleValues[1] = "message empty.";
                    }

                    BackgroundManager.m_oWorkerUpscale.ReportProgress(AcquisitionControl.GetState(), UpscaleValues);

                    int curState = AcquisitionControl.GetState();

                    switch (curState)
                    {
                        case 200:
                            {
                                UpdateMaintCheckMessage("Preparing to run Manual Upscale");

                                Logger.WriteLogFile("Start Manual Upscale (200)", "c:/temp/ManualUpscale.txt");
                                Thread.Sleep(600);

                                AcquisitionControl.SetEC1Enabled(true);
                                AcquisitionControl.SetEC2Enabled(true);
                                AcquisitionControl.SetEC3Enabled(true);
                                //AcquisitionControl.SetEC4Enabled();





                                UpdateMaintCheckMessage("Set Energy Condition to EC1");
                                Logger.WriteLogFile("Set EC to EC1 (200)", "c:/temp/ManualUpscale.txt");
                                AcquisitionControl.SetEnergyCondition(1);
                                Thread.Sleep(600);




                                Logger.WriteLogFile("Move DR home (200)", "c:/temp/ManualUpscale.txt");
                                UpdateMaintCheckMessage("Move Dynamic Rod Home.");

                                int returnVal = AcquisitionControl.MoveRodHome(SerialManager, this);
                                Logger.WriteLogFile("move DR home returned: " + returnVal.ToString(), "c:/temp/ManualUpscale.txt");
                                if (returnVal == PASS)
                                {
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(202);

                                }
                                else
                                {
                                    AcquisitionControl.SetCounter((AcquisitionControl.GetCounter() + 1));
                                    if (AcquisitionControl.GetCounter() >= 3)
                                    {
                                        HaltUpscale("Error:  Move DR home failed");
                                    }
                                    else
                                    {
                                        //retry
                                        AcquisitionControl.SetState(200);
                                        Logger.WriteErrorFile("Error:  Manual Upscale (200) Move Dynamic Rod home.");
                                        UpdateMaintCheckMessage("Error:  Move Dynamic Rod Home");
                                    }
                                }
                                break;

                            }
                        case 202:
                            {
                                Logger.WriteLogFile("state = 202.", "c:/temp/ManualUpscale.txt");
                                UpdateMaintCheckMessage("Move Dynamic Rod to Upscale");

                                int returnVal = AcquisitionControl.MoveRod(SerialManager, Properties.Settings.Default.UpscaleRodPosition, this);
                                Logger.WriteLogFile("move DR to Upscale returned: " + returnVal.ToString(), "c:/temp/ManualUpscale.txt");

                                int getRodPositionValue = 0;

                                getRodPositionValue = AcquisitionControl.PollMotorPosition(4, SerialManager);

                                //check for stable position read 
                                //int posOld = 0;
                                //int posNew = 1;
                                //int retv = FAIL;
                                //int counter = 0;
                                //do
                                //{
                                //    retv = AcquisitionControl.CheckMotorPosition(SerialManager, 4, out getRodPositionValue);
                                //    if (retv == PASS)
                                //    {
                                //        posNew = getRodPositionValue;
                                //    }

                                //    if (posNew == posOld)
                                //    {
                                //        break;
                                //    }

                                //    posOld = posNew;
                                //    counter++;
                                //    Thread.Sleep(500);
                                //} while (counter < 60);


                                //int getRodPositionValue = 0;

                                //                                AcquisitionControl.CheckMotorPosion(SerialManager, 4, out getRodPositionValue);
                                Logger.WriteLogFile("DR at Manual Upscale returned position = " + getRodPositionValue.ToString(), "c:/temp/ManualUpscale.txt");
                                UpdateDynamicRodMessage("DR at position (" + getRodPositionValue.ToString() + ")");


                                if (returnVal == PASS)
                                {
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(204);

                                }
                                else
                                {
                                    AcquisitionControl.SetCounter((AcquisitionControl.GetCounter() + 1));
                                    if (AcquisitionControl.GetCounter() >= 3)
                                    {
                                        HaltUpscale("Error:  Move DR upscale failed");
                                    }
                                    else
                                    {  //retry
                                        AcquisitionControl.SetState(202);
                                        Logger.WriteErrorFile("Error: Manual Ecal (202) move DR to upscale.");
                                        UpdateMaintCheckMessage("Error:  Move Dynamic Rod Upscale");
                                    }
                                }

                                break;
                            }



                        case 204:
                            {
                                //move filter wheel home

                                if (AcquisitionControl.GetCounter() == 0)
                                {
                                    int returnVal24 = AcquisitionControl.MoveFWHome(SerialManager, this);
                                    AcquisitionControl.SetEnergyConditionPrevious(0);

                                    //confirm position
                                    //int position=-1;

                                    //int returnVal25 = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);
                                    int position = AcquisitionControl.PollMotorPosition(1, SerialManager);


                                    //Logger.WriteLogFile(   "EC " + "init" + " (destination) motor position, after home = " + position.ToString());
                                    UpdateFilterWheelMessage("Filter wheel at position (" + position.ToString() + ")");
                                    UpdateMaintCheckMessage("Filter wheel at position (" + position.ToString() + ")");

                                    //if (returnVal25 == PASS && returnVal24 ==PASS)
                                    if (position == 0)
                                    {
                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(206);

                                    }
                                    else
                                    {
                                        //could add 3x retry logic here
                                        HaltUpscale("Manual Upscale Error:  Move FW home");
                                    }
                                }
                                break;
                            }

                        case 206:
                            {


                                Logger.WriteLogFile("state = 206.  Set flow for analysis=1000", "c:/temp/ManualUpscale.txt");
                                if (AcquisitionControl.GetCounter() == 0)
                                {

                                    Logger.WriteLogFile("state = 206, counter 0", "c:/temp/ManualUpscale.txt");

                                    //set fixed value
                                    AcquisitionControl.SetFlowVolumeForAnalysis(1000);

                                    //set dataset to 1 -- only data set to be used
                                    AcquisitionControl.SetDataSet(1);

                                    AcquisitionControl.ClrOperatingData();  //initialize the new data set; save the old for write in state 31 presentation

                                    //pump off
                                    int returnVal20 = AcquisitionControl.PumpOff(m_oWorkerPump);
                                    if (returnVal20 == PASS)
                                    {

                                        AcquisitionControl.SetCounter(1);

                                    }
                                    else
                                    {
                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(206);
                                        Logger.WriteErrorFile("Error:  Manual Upscale (206)  Turn pump off.");
                                        HaltUpscale("Manual Upscale:  pump off");
                                    }

                                }
                                if (AcquisitionControl.GetCounter() == 1)
                                {
                                    Logger.WriteLogFile("state = 206, counter = 1", "c:/temp/ManualUpscale.txt");
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(208);
                                }

                                break;
                            }
                        case 208:  //21:
                            {

                                Logger.WriteLogFile("state = 208. calculating EC times.   ", "c:/temp/ManualUpscale.txt");
                                UpdateMaintCheckMessage("Calculating EC times");
                                Thread.Sleep(1000);

                                //compute the wait for EC1,2,3, normal 15m mode for Upscale
                                DateTime DTNow = DateTime.Now;

                                UpscaleStart = DTNow;   //.Date.Add(new TimeSpan(DTNow.Hour, 15, 0));
                                Logger.WriteLogFile("Upscale start time = " + UpscaleStart.ToString(), "c:/temp/ManualUpscale.txt");
                                UpdateMaintCheckMessage("Upscale start = " + UpscaleStart.ToString());
                                //}

                                //compute the ec1,2,3 end times:
                                var AcqStartTime = UpscaleStart;

                                double EC1p = 0.20;// AcquisitionControl.GetEC1Percent() / 100;
                                double EC2p = 0.40;// = AcquisitionControl.GetEC2Percent() / 100;
                                double EC3p = 0.40;// = AcquisitionControl.GetEC3Percent() / 100;

                                int SampleTime = 15;

                                AcquisitionControl.SetAcquireStartTimeMinutes(AcqStartTime);
                                //minValue1, minValue2, minValue3;
                                double timeValue1s;
                                timeValue1s = ((SampleTime * EC1p * 60) + 25);   //25 was 80 for older code (25 must match the time for NZ dn+tape mv+NZup)
                                int itimeValue1s = Convert.ToInt32(timeValue1s);

                                AcquisitionControl.SetEC1Time(itimeValue1s);  //send seconds

                                double timeValue2s = ((SampleTime * EC2p * 60) - 12.5);  //12.5 was 40 
                                int itimeValue2 = Convert.ToInt32(timeValue2s);

                                AcquisitionControl.SetEC2Time(itimeValue2);


                                double timeValue3s = ((SampleTime * EC3p * 60) - 12.5); //12.5 was 40



                                if ((timeValue1s + timeValue2s + timeValue3s) > (SampleTime * 60))
                                {
                                    timeValue3s = timeValue3s - ((timeValue1s + timeValue2s + timeValue3s) - SampleTime * 60);
                                }
                                Logger.WriteLogFile("timeValue1s = " + timeValue1s.ToString() + " timeValue2s = " + timeValue2s.ToString() + " timeValue3s = " + timeValue3s.ToString(), "c:/temp/ManualUpscale.txt");

                                int itimeValue3 = Convert.ToInt32(timeValue3s);


                                //bhc only for testing testing...
                                //*************************************************************************
                                //timeValue1s = 120;
                                //timeValue2s = 120;
                                //timeValue3s = 120;
                                //*************************************************************************  



                                //bhc only for testing
                                //************************
                                //AcquisitionControl.SetEC3Time((int)timeValue3s);      //delete after testing complete......
                                //************************

                                DateTime EC1EndTime = AcqStartTime.AddSeconds(timeValue1s);

                                AcquisitionControl.SetEC1EndTime(EC1EndTime);
                                DateTime EC2EndTime = EC1EndTime.AddSeconds(timeValue2s);
                                AcquisitionControl.SetEC2EndTime(EC2EndTime);

                                DateTime EC3EndTime = EC2EndTime.AddSeconds(itimeValue3);  //..............
                                // bhc only for testing ******************************* 

                                //DateTime EC3EndTime = EC2EndTime.AddSeconds(120);
                                // *******************************


                                AcquisitionControl.SetEC3EndTime(EC3EndTime);

                                Logger.WriteLogFile("Upscale start time = " + UpscaleStart.ToString(), "c:/temp/ManualUpscale.txt");

                                Logger.WriteLogFile("(208) UpScale, EC1 End time: " + EC1EndTime.ToString(), "c:/temp/ManualUpscale.txt");
                                Logger.WriteLogFile("(208) UpScale, EC2 End time: " + EC2EndTime.ToString(), "c:/temp/ManualUpscale.txt");
                                Logger.WriteLogFile("(208) UpScale, EC3 End time: " + EC3EndTime.ToString(), "c:/temp/ManualUpscale.txt");


                                AcquisitionControl.SetState(210);
                                AcquisitionControl.SetCounter(0);

                                break;
                            }



                        case 210:  //case 25:
                            {

                                int ecValue = 0;
                                int destinationV = 0;
                                int destinationI = 0;
                                double presentV = 0.0;
                                double presentI = 0.0;

                                if (AcquisitionControl.GetCounter() == 0)
                                {
                                    Logger.WriteLogFile("state = 210. ramp xrays", "c:/temp/ManualUpscale.txt");

                                    AcquisitionControl.SetCounter(1);
                                    UpdateMaintCheckMessage("Ramping Xrays");

                                }
                                //EC1 ramp xrays
                                ecValue = AcquisitionControl.GetEnergyCondition();
                                UpdateMaintCheckMessage("Set Upscale Xray Voltages for EC" + ecValue.ToString());
                                Logger.WriteLogFile("upscale ramp voltage for EC" + ecValue.ToString(), "c:/temp/ManualUpscale.txt");

                                if (ecValue == 1)
                                {
                                    //read from parameter storage    
                                    int EC1kV; //EC1kV
                                               //set:
                                               //Properties.Settings.Default.Tnist= "abc";
                                               //Properties.Settings.Default.Save();



                                    Logger.WriteLogFile("UPSCALE (210)setting EC1 V and I for comm interface.", "c:/temp/ManualUpscale.txt");

                                    // verify data reads here:

                                    EC1kV = Properties.Settings.Default.EC1kV;
                                    float fEC1kV;
                                    fEC1kV = Convert.ToSingle(EC1kV);
                                    //bool setEC1kV = myxrsfp.Send_kV[fEC1kV];

                                    int EC1uA; //EC1kV
                                    EC1uA = Properties.Settings.Default.EC1uA;
                                    float fEC1uA;
                                    fEC1uA = Convert.ToSingle(EC1uA);
                                    //bool setEC1uA = myxrsfp.Send_uA[fEC1uA];

                                    destinationV = Convert.ToInt32(fEC1kV);
                                    destinationI = Convert.ToInt32(fEC1uA);

                                }
                                else if (ecValue == 2)
                                {

                                    Logger.WriteLogFile("UPSCALE (210) setting EC2 V and I for comm interface.", "c:/temp/ManualUpscale.txt");

                                    int EC2kV;
                                    EC2kV = Properties.Settings.Default.EC2kV;
                                    float fEC2kV;
                                    fEC2kV = Convert.ToSingle(EC2kV);

                                    int EC2uA;
                                    EC2uA = Properties.Settings.Default.EC2uA;
                                    float fEC2uA;
                                    fEC2uA = Convert.ToSingle(EC2uA);

                                    destinationV = Convert.ToInt32(fEC2kV);
                                    destinationI = Convert.ToInt32(fEC2uA);

                                }
                                else if (ecValue == 3)
                                {
                                    Logger.WriteLogFile("UPSCALE (210) setting EC3 V and I for comm interface.", "c:/temp/ManualUpscale.txt");

                                    int EC3kV;
                                    EC3kV = Properties.Settings.Default.EC3kV;
                                    float fEC3kV;
                                    fEC3kV = Convert.ToSingle(EC3kV);

                                    int EC3uA;
                                    EC3uA = Properties.Settings.Default.EC3uA;
                                    float fEC3uA;
                                    fEC3uA = Convert.ToSingle(EC3uA);


                                    destinationV = Convert.ToInt32(fEC3kV);
                                    destinationI = Convert.ToInt32(fEC3uA);

                                }

                                presentV = readInputVoltage;
                                presentV = presentV * 50.0 / 10.0;


                                presentI = readInputCurrent;
                                presentI = presentI * 2000.0 / 10.0;


                                Logger.WriteLogFile("UPSCALE ramp V from: " + presentV.ToString("F2") + " to: " + destinationV.ToString("F2"), "c:/temp/ManualUpscale.txt");
                                Logger.WriteLogFile("UPSCALE ramp I from: " + presentI.ToString("F2") + " to: " + destinationI.ToString("F2"), "c:/temp/ManualUpscale.txt");



                                int returnVal25 = AcquisitionControl.RampXrays(presentV, presentI, destinationV, destinationI, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);

                                if (mtbInterlockStatus.InvokeRequired)
                                {
                                    mtbInterlockStatus.Invoke(new MethodInvoker(delegate { mtbInterlockStatus.Text = "Closed"; }));

                                }
                                else
                                {
                                    mtbInterlockStatus.Text = "Closed";
                                }

                                if (returnVal25 == PASS)
                                {
                                    Logger.WriteLogFile("Xray Ramp:  PASS.", "c:/temp/ManualUpscale.txt");


                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(212);


                                }
                                else
                                {

                                    Logger.WriteErrorFile("Error: Manual Upscale (210) Unable to ramp xrays.");
                                    HaltUpscale("Error Unable To Ramp Xrays");
                                }
                                break;
                            }
                        case 212:  //case 26
                            {
                                Logger.WriteLogFile("state = 212. loading master tfr file", "c:/temp/ManualUpscale.txt");

                                if (AcquisitionControl.GetCounter() == 0)
                                {
                                    AcquisitionControl.SetCounter(1);
                                    UpdateMaintCheckMessage("Loading Master TFR File");
                                }


                                int energyCondition = AcquisitionControl.GetEnergyCondition();
                                int returnVal26 = AcquisitionControl.LoadMTFRFile(energyCondition);
                                if (returnVal26 == PASS)
                                {

                                    Logger.WriteLogFile("(212) load MFTRFile + cond code returned: true", "c:/temp/ManualUpscale.txt");
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(214);

                                }
                                else
                                {
                                    Logger.WriteErrorFile("Error: Manual Upscale (212)  Unable to load master tfr file  " + energyCondition.ToString());
                                    HaltUpscale("Control state 212 Unable to load master tfr file " + energyCondition.ToString());
                                }
                                break;
                            }


                        case 214:  //case 27:
                            {
                                int enCond = AcquisitionControl.GetEnergyCondition();
                                Logger.WriteLogFile("state = 214.  Move FW to EC" + enCond.ToString(), "c:/temp/ManualUpscale.txt");
                                //UpdateMaintCheckMessage("Move FW to EC" + enCond.ToString());

                                string status;
                                int ECend;
                                int ECstart;

                                ECend = AcquisitionControl.GetEnergyCondition();
                                ECstart = AcquisitionControl.GetEnergyConditionPrevious();

                                status = "Move Filter Wheel to EC " + ECend.ToString();
                                Logger.WriteLogFile("state = 214. " + status, "c:/temp/ManualUpscale.txt");


                                Logger.WriteLogFile("Moving FW from: " + ECstart.ToString() + " to: " + ECend.ToString(), "c:/temp/ManualUpscale.txt");
                                //displayActionQueue.Enqueue("moving FW from: " + ECstart.ToString() + " to: " + ECend.ToString());
                                UpdateMaintCheckMessage("Moving FW from: EC" + ECstart.ToString() + " to EC" + ECend.ToString());

                                int beforePosition = 0;

                                //int returnVal = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out beforePosition);

                                beforePosition = AcquisitionControl.PollMotorPosition(1, SerialManager);

                                Logger.WriteLogFile("EC " + ECend.ToString() + " (destination) motor position, before move = " + beforePosition.ToString(), "c:/temp/ManualUpscale.txt");
                                //Logger.WriteLogFile("Check before FW postion returned: " + returnVal.ToString(), "c:/temp/ManualUpscale.txt");



                                int returnVal27 = AcquisitionControl.MoveFWEC(SerialManager, ECstart, ECend, this);
                                if (returnVal27 == PASS)
                                {

                                    Logger.WriteLogFile("Move to EC" + ECend.ToString() + " returned PASS.", "C:/temp/ManualUpscale.txt");
                                    int position = 0;

                                    //returnVal27 = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);  //1=FW
                                    position = AcquisitionControl.PollMotorPosition(1, SerialManager);





                                    Logger.WriteLogFile("EC " + ECend.ToString() + " (destination) motor position, after move = " + position.ToString(), "C:/temp/ManualUpscale.txt");
                                    //Logger.WriteLogFile("C:/temp/ManualUpscale.txt", "Check FW motor postion returned: " + returnVal27.ToString());
                                    //UpdateMaintCheckMessage("Check FW motor postion returned: " + returnVal27.ToString());

                                    if (ECend == 1)
                                    {

                                        //bhc -- change to position values
                                        //Logger.WriteLogFile(   "EC (destination) motor position = " + position.ToString());
                                        //int pos = Properties.Settings.Default.FWEC1;

                                        if (position == Properties.Settings.Default.FWEC1)

                                        {
                                            UpdateMaintCheckMessage("FW at EC1 (" + position.ToString() + ")");

                                            AcquisitionControl.SetEnergyConditionPrevious(1);  //
                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(216);
                                        }
                                        else
                                        {
                                            //incorrect position returned
                                            AcquisitionControl.SetCounter(AcquisitionControl.GetCounter() + 1);
                                            if (AcquisitionControl.GetCounter() <= 3)
                                            {

                                                Logger.WriteErrorFile("Error:  Manual Upscale state (214) unable to move Filter Wheel to EC1.");
                                                Logger.WriteLogFile("Incorrect position returned.  Sending FW home", "C:/temp/ManualUpscale.txt");
                                                UpdateMaintCheckMessage("Error:  Position read Filter Wheel EC1");
                                                int retVal = AcquisitionControl.MoveFWHome(SerialManager, this);
                                                if (retVal == PASS)
                                                {
                                                    AcquisitionControl.SetEnergyConditionPrevious(0);
                                                    AcquisitionControl.SetState(214);
                                                }
                                                else
                                                {
                                                    HaltUpscale("Unable to move FW Home");
                                                }
                                            }
                                            else
                                            {
                                                HaltUpscale("Unable to move FW to EC1");
                                            }


                                        }
                                    }
                                    else if (ECend == 2)
                                    {
                                        //Logger.WriteLogFile(   "EC "+ECend.ToString()+ " (destination) motor position, after move = " + position.ToString());
                                        if (position == Properties.Settings.Default.FWEC2)
                                        {
                                            UpdateMaintCheckMessage("FW at EC2 (" + position.ToString() + ")");
                                            AcquisitionControl.SetEnergyConditionPrevious(2);
                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(216);
                                        }
                                        else
                                        {


                                            //incorrect position returned
                                            AcquisitionControl.SetCounter(AcquisitionControl.GetCounter() + 1);
                                            if (AcquisitionControl.GetCounter() <= 3)
                                            {

                                                Logger.WriteErrorFile("Error:  Manual Upscale (214) Unable to move Filter Wheel to EC2.");
                                                Logger.WriteLogFile("Incorrect position returned.  Sending FW home", "C:/temp/ManualUpscale.txt");
                                                UpdateMaintCheckMessage("Error:  Position read Filter Wheel EC2");
                                                int retVal = AcquisitionControl.MoveFWHome(SerialManager, this);

                                                if (retVal == PASS)
                                                {
                                                    AcquisitionControl.SetEnergyConditionPrevious(0);
                                                    AcquisitionControl.SetState(214);
                                                }
                                                else
                                                {
                                                    HaltUpscale("Unable to move FW home");
                                                }
                                            }
                                            else
                                            {
                                                HaltUpscale("Unable to move FW to EC2");
                                            }



                                        }
                                    }
                                    else if (ECend == 3)
                                    {
                                        //Logger.WriteLogFile(   "EC " + ECend.ToString() + " (destination) motor position, after move = " + position.ToString());
                                        if (position == Properties.Settings.Default.FWEC3)
                                        {
                                            UpdateMaintCheckMessage("FW at EC3 (" + position.ToString() + ")");

                                            AcquisitionControl.SetEnergyConditionPrevious(3);
                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(216);
                                        }
                                        else
                                        {
                                            //incorrect position returned
                                            AcquisitionControl.SetCounter(AcquisitionControl.GetCounter() + 1);
                                            if (AcquisitionControl.GetCounter() <= 3)
                                            {

                                                Logger.WriteErrorFile("Error:  Manual Upscale (214) Unable to move Filter Wheel to EC3.");
                                                Logger.WriteLogFile("Incorrect position returned.  Sending FW home", "C:/temp/ManualUpscale.txt");
                                                UpdateMaintCheckMessage("Error:  Position read Filter Wheel EC3");
                                                int retVal = AcquisitionControl.MoveFWHome(SerialManager, this);
                                                if (retVal == PASS)
                                                {

                                                    AcquisitionControl.SetEnergyConditionPrevious(0);
                                                    AcquisitionControl.SetState(214);
                                                }
                                                else
                                                {
                                                    HaltUpscale("Unable to move FW Home");
                                                }
                                            }
                                            else
                                            {
                                                HaltUpscale("Unable to move FW to EC3");
                                            }


                                        }
                                    }

                                }
                                else
                                {

                                    Logger.WriteErrorFile("Error:  Manual Upscale (214) Unable to move Filter Wheel");
                                    HaltUpscale("Error Unable to move FW");

                                }
                            }
                            break;

                        case 216:
                            {
                                Logger.WriteLogFile("state = 216. Start and Wait for EC time to expire.", "c:/temp/ManualUpscale.txt");

                                int CurrentEC = AcquisitionControl.GetEnergyCondition();


                                if (CurrentEC == 1)
                                {
                                    if (AcquisitionControl.GetCounter() == 0)
                                    {
                                        //this needs be the date time used for data writing purposes 
                                        DateTime upscaleStartTime = DateTime.Now;
                                        AcquisitionControl.SetAcquireStartTime(upscaleStartTime);
                                        AcquisitionControl.SetAcquisitionOpStartDateTime();  // sets start time to now

                                        DateTime ec1time = AcquisitionControl.GetEC1EndTime();
                                        TimeSpan time = ec1time - DateTime.Now;

                                        Logger.WriteLogFile("EC1 start time: " + DateTime.Now.ToString(), "c:/temp/ManualUpscale.txt");

                                        float kV;
                                        string kVs;
                                        //tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Text = Tnistvalue.ToString(); }));//sets the value
                                        //string actualValue;
                                        if (mtbIOActualkV.InvokeRequired)
                                        {
                                            mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                        }
                                        else
                                        {
                                            actualValueV = mtbIOActualkV.Text;
                                        }

                                        kVs = actualValueV;
                                        kV = Convert.ToSingle(kVs);
                                        bool boolresponse_kV = myxrsfp.Send_kV[kV];
                                        float uA;
                                        string uAs;
                                        if (mtbIOActualuA.InvokeRequired)
                                        {
                                            mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                        }
                                        else
                                        {
                                            actualValueI = mtbIOActualuA.Text;
                                        }
                                        uAs = actualValueI;
                                        uA = Convert.ToSingle(uAs);

                                        bool boolresponse_uA = myxrsfp.Send_uA[uA];
                                        Logger.WriteInternalLogFile("before EC1 AC kV = " + kV.ToString("F2"));
                                        Logger.WriteInternalLogFile("before EC1 AC uA = " + uA.ToString("F2"));


                                        //AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) - PRESET_END_ADJUST_UPSCALE);
                                        AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) + (time.Hours * 3600) - PRESET_END_ADJUST_UPSCALE);

                                        Thread.Sleep(3000);
                                        float deadTime = 0;
                                        if (Properties.Settings.Default.EC1AC.Contains("ON"))
                                        {

                                            AcquisitionControl.AutoCurrent((readInputCurrent * 2000.0 / 10.0), (readInputVoltage * 50.0 / 10.0), m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);

                                            //float kV;
                                            //string kVs;
                                            //tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Text = Tnistvalue.ToString(); }));//sets the value
                                            //string actualValue;
                                            if (mtbIOActualkV.InvokeRequired)
                                            {
                                                mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                            }
                                            else
                                            {
                                                actualValueV = mtbIOActualkV.Text;
                                            }

                                            kVs = actualValueV;
                                            kV = Convert.ToSingle(kVs);
                                            bool boolresponse_kV2 = myxrsfp.Send_kV[kV];
                                            //float uA;
                                            //string uAs;
                                            if (mtbIOActualuA.InvokeRequired)
                                            {
                                                mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                            }
                                            else
                                            {
                                                actualValueI = mtbIOActualuA.Text;
                                            }
                                            uAs = actualValueI;
                                            uA = Convert.ToSingle(uAs);
                                            bool boolresponse_uA2 = myxrsfp.Send_uA[uA];

                                            Logger.WriteInternalLogFile("after EC1 AC kV = " + kV.ToString("F2"));
                                            Logger.WriteInternalLogFile("after EC1 AC uA = " + uA.ToString("F2"));


                                        }
                                        else
                                        {
                                            deadTime = AcquisitionControl.GetDeadTime();
                                        }
                                        //double outputBeamCurrent = 0;
                                        //AcquisitionControl.CalculateBeamCurrent(deadTime, (readInputCurrent * 2000.0/10.0), out outputBeamCurrent);

                                        Logger.WriteLogFile("EC1 deadTime = " + deadTime.ToString("F2"), "c:/temp/ManualUpscale.txt");

                                        AcquisitionControl.SetCounter(1);



                                    }
                                    //displayActionQueue.Enqueue("Waiting for EC1 to end...");
                                    DateTime AcquisitionStartTime = AcquisitionControl.GetAcquireStartTime();

                                    var TimeRemaining = AcquisitionControl.GetEC1EndTime() - System.DateTime.Now;

                                    //displayActionQueue.Enqueue("Time Remaining EC1 = " + TimeRemaining.Hours.ToString() + ":" + TimeRemaining.Minutes.ToString() + ":" + TimeRemaining.Seconds.ToString());
                                    if (TimeRemaining.Seconds % 10 == 0)
                                    {
                                        Logger.WriteLogFile("Time Remaining EC1 = " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"), "c:/temp/ManualUpscale.txt");
                                    }
                                    UpdateMaintCheckMessage("Time Remaining EC1 = " + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"));


                                    if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
                                    {
                                        //displayActionQueue.Enqueue("End EC1.");
                                        UpdateMaintCheckMessage("End EC1");
                                        Logger.WriteLogFile("End EC1, save spec Raw and Adj, calling auto analyze.", "c:/temp/ManualUpscale.txt");



                                        UpdateMaintCheckMessage("Saving CES spectrum, raw");

                                        AcquisitionControl.SaveCESSpectrumRaw("c:/spectrum_data_raw", "sp_data_UPSCALE", 1);
                                        Thread.Sleep(500);
                                        UpdateMaintCheckMessage("Adjusting spectrum");
                                        Thread.Sleep(500);
                                        AcquisitionControl.AdjustSpectrum();
                                        UpdateMaintCheckMessage("Saving CES spectrum, adjusted");

                                        AcquisitionControl.SaveCESSpectrum("c:/spectrum_data", "sp_data_UPSCALE", 1);
                                        Thread.Sleep(500);
                                        UpdateMaintCheckMessage("Performing auto analyze");
                                        AcquisitionControl.AutoAnalyze();
                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(218);

                                    }

                                }
                                else if (AcquisitionControl.GetEC2Enabled() == true && CurrentEC == 2)
                                {


                                    if (AcquisitionControl.GetCounter() == 0)
                                    {
                                        DateTime ec2time = AcquisitionControl.GetEC2EndTime();
                                        TimeSpan time = ec2time - DateTime.Now;
                                        Logger.WriteLogFile("EC2 start time: " + DateTime.Now.ToString(), "c:/temp/ManualUpscale.txt");

                                        float kV;
                                        string kVs;

                                        if (mtbIOActualkV.InvokeRequired)
                                        {
                                            mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                        }
                                        else
                                        {
                                            actualValueV = mtbIOActualkV.Text;
                                        }

                                        kVs = actualValueV;
                                        kV = Convert.ToSingle(kVs);
                                        bool boolresponse_kV = myxrsfp.Send_kV[kV];
                                        float uA;
                                        string uAs;
                                        if (mtbIOActualuA.InvokeRequired)
                                        {
                                            mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                        }
                                        else
                                        {
                                            actualValueI = mtbIOActualuA.Text;
                                        }

                                        uAs = actualValueI;
                                        uA = Convert.ToSingle(uAs);
                                        bool boolresponse_uA = myxrsfp.Send_uA[uA];
                                        Logger.WriteInternalLogFile("before EC2 AC kV = " + kV.ToString("F2"));
                                        Logger.WriteInternalLogFile("before EC2 AC uA = " + uA.ToString("F2"));

                                        //AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) - PRESET_END_ADJUST_UPSCALE);
                                        AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) + (time.Hours * 3600) - PRESET_END_ADJUST_UPSCALE);

                                        Thread.Sleep(3000);
                                        float deadTime = 0.0F;
                                        if (Properties.Settings.Default.EC2AC.Contains("ON"))
                                        {
                                            AcquisitionControl.AutoCurrent((readInputCurrent * 2000.0 / 10.0), (readInputVoltage * 50.0 / 10.0), m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                                            //float kV;
                                            //string kVs;

                                            if (mtbIOActualkV.InvokeRequired)
                                            {
                                                mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                            }
                                            else
                                            {
                                                actualValueV = mtbIOActualkV.Text;
                                            }

                                            kVs = actualValueV;
                                            kV = Convert.ToSingle(kVs);
                                            bool boolresponse_kV3 = myxrsfp.Send_kV[kV];
                                            //float uA;
                                            //string uAs;
                                            if (mtbIOActualuA.InvokeRequired)
                                            {
                                                mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                            }
                                            else
                                            {
                                                actualValueI = mtbIOActualuA.Text;
                                            }

                                            uAs = actualValueI;
                                            uA = Convert.ToSingle(uAs);
                                            bool boolresponse_uA3 = myxrsfp.Send_uA[uA];
                                            Logger.WriteInternalLogFile("after EC2 AC kV = " + kV.ToString("F2"));
                                            Logger.WriteInternalLogFile("after EC2 AC uA = " + uA.ToString("F2"));


                                        }
                                        else
                                        {
                                            deadTime = AcquisitionControl.GetDeadTime();
                                        }


                                        Logger.WriteLogFile("(216) EC2 deadTime = " + deadTime.ToString("F2"), "c:/temp/ManualUpscale.txt");

                                        AcquisitionControl.SetCounter(1);
                                    }

                                    //time to wait 2
                                    //displayActionQueue.Enqueue("Waiting for EC2 to end...");
                                    DateTime AcquisitionStartTime = AcquisitionControl.GetAcquireStartTime();

                                    var TimeRemaining = AcquisitionControl.GetEC2EndTime() - System.DateTime.Now;

                                    //displayActionQueue.Enqueue("Time Remaining EC2 = " + TimeRemaining.Hours.ToString() + ":" + TimeRemaining.Minutes.ToString() + ":" + TimeRemaining.Seconds.ToString());
                                    //UpdateMaintCheckMessage("Time Remaining EC2 = " + TimeRemaining.Minutes.ToString() + ":" + TimeRemaining.Seconds.ToString());
                                    UpdateMaintCheckMessage("Time Remaining EC2 = " + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"));
                                    if (TimeRemaining.Seconds % 10 == 0)
                                    {

                                        Logger.WriteLogFile("Time Remaining EC2 = " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"), "c:/temp/ManualUpscale.txt");
                                    }

                                    if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
                                    {
                                        UpdateMaintCheckMessage("End EC2");
                                        Logger.WriteLogFile("End EC2, save spec, calling auto analyze.", "c:/temp/ManualUpscale.txt");

                                        AcquisitionControl.SaveCESSpectrumRaw("c:/spectrum_data_raw", "sp_data_UPSCALE", 2);
                                        AcquisitionControl.AdjustSpectrum();

                                        AcquisitionControl.SaveCESSpectrum("c:/spectrum_data", "sp_data_UPSCALE", 2);

                                        AcquisitionControl.AutoAnalyze();
                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(218);
                                    }

                                }

                                else if (AcquisitionControl.GetEC3Enabled() == true && CurrentEC == 3)
                                {

                                    if (AcquisitionControl.GetCounter() == 0)
                                    {
                                        DateTime ec3time = AcquisitionControl.GetEC3EndTime();
                                        TimeSpan time = ec3time - DateTime.Now;
                                        Logger.WriteLogFile("EC3 start time: " + DateTime.Now.ToString(), "c:/temp/ManualUpscale.txt");   //date time format

                                        float kV;
                                        string kVs;
                                        if (mtbIOActualkV.InvokeRequired)
                                        {
                                            mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                        }
                                        else
                                        {
                                            actualValueV = mtbIOActualkV.Text;
                                        }
                                        kVs = actualValueV;
                                        kV = Convert.ToSingle(kVs);
                                        bool boolresponse_kV = myxrsfp.Send_kV[kV];
                                        float uA;
                                        string uAs;

                                        if (mtbIOActualuA.InvokeRequired)
                                        {

                                            mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                        }
                                        else
                                        {
                                            actualValueI = mtbIOActualuA.Text;
                                        }

                                        uAs = actualValueI;
                                        uA = Convert.ToSingle(uAs);
                                        bool boolresponse_uA = myxrsfp.Send_uA[uA];

                                        Logger.WriteInternalLogFile("before EC3 AC kV = " + kV.ToString("F2"));
                                        Logger.WriteInternalLogFile("before EC3 AC uA = " + uA.ToString("F2"));

                                        //AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) - PRESET_END_ADJUST_UPSCALE);
                                        AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) + (time.Hours * 3600) - PRESET_END_ADJUST_UPSCALE);


                                        Thread.Sleep(3000);
                                        float deadTime = 0;
                                        if (Properties.Settings.Default.EC3AC.Contains("ON"))
                                        {

                                            AcquisitionControl.AutoCurrent((readInputCurrent * 2000.0 / 10.0), (readInputVoltage * 50.0 / 10.0), m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);

                                            //float kV;
                                            //string kVs;

                                            if (mtbIOActualkV.InvokeRequired)
                                            {
                                                mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                            }
                                            else
                                            {
                                                actualValueV = mtbIOActualkV.Text;
                                            }

                                            kVs = actualValueV;
                                            kV = Convert.ToSingle(kVs);
                                            bool boolresponse_kV3 = myxrsfp.Send_kV[kV];
                                            //float uA;
                                            //string uAs;
                                            if (mtbIOActualuA.InvokeRequired)
                                            {
                                                mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                            }
                                            else
                                            {
                                                actualValueI = mtbIOActualuA.Text;
                                            }

                                            uAs = actualValueI;
                                            uA = Convert.ToSingle(uAs);
                                            bool boolresponse_uA3 = myxrsfp.Send_uA[uA];

                                            Logger.WriteInternalLogFile("after EC3 AC kV = " + kV.ToString("F2"));
                                            Logger.WriteInternalLogFile("after EC3 AC uA = " + uA.ToString("F2"));


                                        }
                                        else
                                        {
                                            deadTime = AcquisitionControl.GetDeadTime();
                                        }
                                        Logger.WriteLogFile("Manual Upscale EC3 dead time = " + deadTime.ToString("F2"), "c:/temp/ManualUpscale.txt");


                                        //double deadTime = AcquisitionControl.GetDeadTime();
                                        //Logger.WriteLogFile("c:/temp/ManualUpscale.txt", "EC3 deadTime = " + deadTime.ToString("F2"));

                                        AcquisitionControl.SetCounter(1);
                                    }


                                    //time to wait 3
                                    DateTime AcquisitionStartTime = AcquisitionControl.GetAcquireStartTime();

                                    var TimeRemaining = AcquisitionControl.GetEC3EndTime() - System.DateTime.Now;
                                    UpdateMaintCheckMessage("Time Remaining EC3 = " + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"));
                                    if (TimeRemaining.Seconds % 10 == 0)
                                    {

                                        Logger.WriteLogFile("Time Remaining EC3 = " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"), "c:/temp/ManualUpscale.txt");
                                    }
                                    if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
                                    {

                                        UpdateMaintCheckMessage("End EC3");
                                        Logger.WriteLogFile("End EC3, saving spectra, calling auto analyze.", "c:/temp/ManualUpscale.txt");
                                        AcquisitionControl.SaveCESSpectrumRaw("c:/spectrum_data_raw", "sp_data_UPSCALE", 3);
                                        AcquisitionControl.AdjustSpectrum();
                                        AcquisitionControl.SaveCESSpectrum("c:/spectrum_data", "sp_data_UPSCALE", 3);

                                        AcquisitionControl.AutoAnalyze();
                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(218);

                                    }

                                }


                            }

                            break;

                        case 218:
                            {

                                Logger.WriteLogFile("state = 218 (wait for autoanalyze to complete). ", "c:/temp/ManualUpscale.txt");
                                // wait for Auto Analyze to complete
                                int AACounter;
                                if (AcquisitionControl.GetEnergyCondition() == 1) // && AcquisitionControl.GetEC1Done()==false )
                                {
                                    AACounter = AcquisitionControl.GetCounter();
                                    AACounter++;
                                    AcquisitionControl.SetCounter(AACounter);
                                    if (AACounter == 8)  //this is the time to complete auto analyze
                                    {
                                        AcquisitionControl.SetEC1Done(true);
                                        UpdateMaintCheckMessage("EC1 Auto Analyze done");
                                        if (AcquisitionControl.GetEC2Enabled() == true)
                                        {
                                            Logger.WriteLogFile("state = 218 (wait for autoanalyze to complete) ec1 done -- set ec to ec2. ", "c:/temp/ManualUpscale.txt");
                                            UpdateMaintCheckMessage("Set EC to EC2");
                                            AcquisitionControl.SetEnergyCondition(2);
                                            AcquisitionControl.SetState(210);
                                            AcquisitionControl.SetCounter(0);

                                        }
                                        else
                                        {

                                            //done with all EC in acquisition
                                            UpdateMaintCheckMessage("Done with all EC (EC2 disabled)");

                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(220);
                                        }

                                    }
                                }
                                else if (AcquisitionControl.GetEnergyCondition() == 2) // && AcquisitionControl.GetEC2Done() == false )
                                {
                                    AACounter = AcquisitionControl.GetCounter();
                                    AACounter++;
                                    AcquisitionControl.SetCounter(AACounter);
                                    if (AACounter >= 8)
                                    {
                                        AcquisitionControl.SetEC2Done(true);
                                        UpdateMaintCheckMessage("EC2 Auto Analyze done");
                                        if (AcquisitionControl.GetEC3Enabled() == true)
                                        {
                                            Logger.WriteLogFile("EC2 done, EC = EC3.");
                                            UpdateMaintCheckMessage("Set EC to EC3");
                                            AcquisitionControl.SetEnergyCondition(3);
                                            AcquisitionControl.SetState(210);
                                            AcquisitionControl.SetCounter(0);
                                        }
                                        else
                                        {
                                            //done with all EC in acquisition
                                            UpdateMaintCheckMessage("All EC done (EC3 disabled)");
                                            Logger.WriteLogFile("all EC done, state = 30.", "c:/temp/ManualUpscale.txt");
                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(220);
                                        }

                                    }


                                }
                                else if (AcquisitionControl.GetEnergyCondition() == 3) //&& AcquisitionControl.GetEC3Done() == false)
                                {
                                    AACounter = AcquisitionControl.GetCounter();
                                    AACounter++;
                                    AcquisitionControl.SetCounter(AACounter);
                                    if (AACounter == 8)
                                    {
                                        AcquisitionControl.SetEC3Done(true);
                                        UpdateMaintCheckMessage("EC3 Auto Analyze done");

                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(220);

                                    }

                                }

                                break;
                            }
                        case 220: //case 30:
                            {
                                AcquisitionControl.SetCounter(0);
                                AcquisitionControl.SetState(222);

                                break;

                            }

                        case 222:  // 'case 31':
                            {

                                if (AcquisitionControl.GetCounter() == 0)
                                {

                                    try
                                    {
                                        //process normal output
                                        Logger.WriteLogFile("state=222", "C:/temp/ManualUpscale.txt");
                                        UpdateMaintCheckMessage("Calculating Upscale data");
                                        Thread.Sleep(500);
                                        double flowForCalculation;
                                        flowForCalculation = 1000; //removes multiply by 1000 during upscale
                                        Logger.WriteLogFile("(222) flow for calculation:  " + flowForCalculation.ToString("F3"), "C:/temp/ManualUpscale.txt");


                                        string line;
                                        int numberofElements = 0;


                                        List<string> elementDataSorted = new List<string>();
                                        List<string> elementData = new List<string>();
                                        List<string> elementDataSymbol = new List<string>();
                                        List<string> elementDataAtWt = new List<string>();
                                        List<string> elementDataConc = new List<string>();
                                        List<string> elementDataUncer = new List<string>();
                                        List<string> elementDataConV = new List<string>();

                                        string tempString = "";
                                        Logger.WriteLogFile("(222) processing data1 file", "C:/temp/ManualUpscale.txt");
                                        UpdateMaintCheckMessage("Processing file 1");

                                        System.IO.StreamReader file1 = new System.IO.StreamReader("c:/process_data/data1.txt");

                                        while ((line = file1.ReadLine()) != null)
                                        {
                                            if (line.Contains("StartTime"))
                                            {
                                                tempString = line;
                                            }
                                            if (line.Contains("NumElements"))
                                            {
                                                string[] items = line.Split(',');
                                                numberofElements = Convert.ToInt16(items[1]);
                                                line = file1.ReadLine();

                                                for (int i = 0; i < numberofElements; i++)
                                                {
                                                    line = file1.ReadLine();
                                                    if (line.Contains("Xx"))
                                                    {
                                                        continue;
                                                    }
                                                    else
                                                    {
                                                        string[] elementItems = line.Split(',');

                                                        elementDataSymbol.Add(elementItems[0]);
                                                        elementData.Add(elementItems[0]);
                                                        elementDataAtWt.Add(elementItems[1]);
                                                        elementData.Add(elementItems[1]);
                                                        elementDataConc.Add(elementItems[2]);   //actually MASS
                                                        elementData.Add(elementItems[2]);

                                                        elementDataUncer.Add(elementItems[3]);
                                                        elementData.Add(elementItems[3]);

                                                        double conc = Convert.ToDouble(elementDataConc.Last());

                                                        double concentration = (conc * 1000) / flowForCalculation;

                                                        elementDataConV.Add(concentration.ToString());

                                                        elementData.Add(concentration.ToString());
                                                    }
                                                }
                                            }
                                        }

                                        file1.Close();


                                        Logger.WriteLogFile("(222) processing data2 file", "C:/temp/ManualUpscale.txt");

                                        UpdateMaintCheckMessage("processing file 2");

                                        System.IO.StreamReader file2 = new System.IO.StreamReader("c:/process_data/data2.txt");


                                        while ((line = file2.ReadLine()) != null)
                                        {
                                            if (line.Contains("NumElements"))
                                            {
                                                string[] items = line.Split(',');
                                                numberofElements = Convert.ToInt16(items[1]);
                                                line = file2.ReadLine();

                                                int action = 0;

                                                for (int i = 0; i < numberofElements; i++)
                                                {
                                                    line = file2.ReadLine();
                                                    if (line.Contains("Xx"))
                                                    {
                                                        continue;
                                                    }
                                                    else
                                                    {
                                                        string[] elementItems = line.Split(',');
                                                        if (elementItems[0].Contains("Nb"))
                                                        {
                                                            action = 1;  //set to 1 to remove Nb

                                                            //double measuredValue = Convert.ToDouble(elementItems[2]);

                                                            //double upperLimit = (Properties.Settings.Default.Nb * (1.0 + (Properties.Settings.Default.UpscaleAlarmPercent / 100.0)));
                                                            //double lowerLimit = (Properties.Settings.Default.Nb * (1.0 - (Properties.Settings.Default.UpscaleAlarmPercent / 100.0)));

                                                            //if (measuredValue >= upperLimit)
                                                            //{
                                                            //    Warning("Nb value high.  Nb = " + measuredValue.ToString("F2") + " Upper Limit = " +upperLimit.ToString("F2"));
                                                            //    SetAlarmValue(203);
                                                            //    WriteAlarmToModbus(203);
                                                            //}
                                                            //else if (measuredValue <= lowerLimit)
                                                            //{
                                                            //    Warning("Nb  value low.  Nb = " + measuredValue.ToString("F2") + " Lower Limit = " +lowerLimit.ToString("F2"));
                                                            //    SetAlarmValue(203);
                                                            //    WriteAlarmToModbus(203);
                                                            //}




                                                        }
                                                        else
                                                        {
                                                            action = 0;
                                                        }

                                                        //if (action != 1)  
                                                        //{
                                                        elementDataSymbol.Add(elementItems[0]);
                                                        elementData.Add(elementItems[0]);
                                                        elementDataAtWt.Add(elementItems[1]);
                                                        elementData.Add(elementItems[1]);
                                                        elementDataConc.Add(elementItems[2]);
                                                        elementData.Add(elementItems[2]);

                                                        elementDataUncer.Add(elementItems[3]);
                                                        elementData.Add(elementItems[3]);

                                                        double conc = Convert.ToDouble(elementDataConc.Last());
                                                        double concentration = 0.0;


                                                        //double flowForNb = 500.0;
                                                        if (action == 1)
                                                        {
                                                            concentration = conc * 5;

                                                        }
                                                        else
                                                        {
                                                            concentration = (conc * 1000) / flowForCalculation;

                                                        }

                                                        elementDataConV.Add(concentration.ToString());

                                                        elementData.Add(concentration.ToString());
                                                        //}
                                                    }
                                                }
                                            }
                                        }
                                        file2.Close();


                                        Logger.WriteLogFile("(222) processing data3 file", "C:/temp/ManualUpscale.txt");
                                        UpdateMaintCheckMessage("Processing file 3");

                                        System.IO.StreamReader file3 = new System.IO.StreamReader("c:/process_data/data3.txt");
                                        while ((line = file3.ReadLine()) != null)
                                        {
                                            if (line.Contains("NumElements"))
                                            {
                                                string[] items = line.Split(',');
                                                numberofElements = Convert.ToInt16(items[1]);
                                                line = file3.ReadLine();

                                                for (int i = 0; i < numberofElements; i++)
                                                {
                                                    line = file3.ReadLine();
                                                    if (line.Contains("Xx"))
                                                    {
                                                        continue;
                                                    }
                                                    else
                                                    {
                                                        string[] elementItems = line.Split(',');

                                                        elementDataSymbol.Add(elementItems[0]);
                                                        elementData.Add(elementItems[0]);
                                                        elementDataAtWt.Add(elementItems[1]);
                                                        elementData.Add(elementItems[1]);
                                                        elementDataConc.Add(elementItems[2]);
                                                        elementData.Add(elementItems[2]);

                                                        elementDataUncer.Add(elementItems[3]);
                                                        elementData.Add(elementItems[3]);

                                                        double conc = Convert.ToDouble(elementDataConc.Last());
                                                        double concentration = (conc * 1000) / flowForCalculation;
                                                        elementDataConV.Add(concentration.ToString());

                                                        elementData.Add(concentration.ToString());
                                                    }
                                                }
                                            }
                                        }




                                        file3.Close();

                                        //bhc process  the data in the "old" dataset (i.e. make averages)
                                        //
                                        //


                                        Logger.WriteLogFile("(222) processing element data", "C:/temp/ManualUpscale.txt");

                                        UpdateMaintCheckMessage("Processing Element Data");

                                        int tempitems = elementData.Count();

                                        string[] array = new string[tempitems / 5];
                                        string[] tempa = new string[6];
                                        int cnt = 0;
                                        int arraycnt = 0;



                                        try
                                        {
                                            foreach (string thing in elementData)
                                            {

                                                tempa[cnt] = thing; //.Trim();
                                                cnt++;
                                                if (cnt == 5)
                                                {
                                                    array[arraycnt] = tempa[0] + "," + tempa[1] + "," + tempa[2] + "," + tempa[3] + "," + tempa[4];
                                                    arraycnt += 1;
                                                    cnt = 0;
                                                }



                                            }

                                            elementDataSorted = array
                                                .OrderBy(arr => arr[3])
                                                .ThenBy(arr => arr[4])
                                                .ToList();

                                        }
                                        catch (Exception Ex)
                                        {
                                            Logger.WriteInternalLogFile(" Error sorting element data.  Ex = " + Ex.ToString());
                                        }




                                        DateTime now = DateTime.Now;
                                        string upscaleDataDirectory = "C:/Upscale_Data";  //small files
                                        string upscaleDataDirectoryArchive = "C:/Upscale_Data/Archive";

                                        string upscaleDirectory = "C:/Upscale"; //large files
                                        string upscaleDirectoryArchive = "C:/Upscale/Archive";

                                        System.IO.Directory.CreateDirectory(upscaleDirectory);
                                        System.IO.Directory.CreateDirectory(upscaleDirectoryArchive);

                                        System.IO.Directory.CreateDirectory(upscaleDataDirectory);
                                        System.IO.Directory.CreateDirectory(upscaleDataDirectoryArchive);


                                        //TextWriter tw = new StreamWriter("c:/process_data/ManualUpscale_" + now.Month.ToString() + "_" + now.Day.ToString() + "_" + now.Year.ToString() + "__" + now.Hour.ToString() + "_" + now.Minute.ToString() + "_" + now.Second.ToString() + "output.txt");
                                        TextWriter tw = new StreamWriter(upscaleDirectory + "/ManualUpscale_" + now.Month.ToString("D2") + "_" + now.Day.ToString("D2") + "_" + now.Year.ToString("D4") + "__" + now.Hour.ToString("D2") + "_" + now.Minute.ToString("D2") + "_" + now.Second.ToString("D2") + "_output.txt");
                                        TextWriter twData = new StreamWriter(upscaleDataDirectory + "/ManualUpscale_Data_" + now.Month.ToString("D2") + "_" + now.Day.ToString("D2") + "_" + now.Year.ToString("D4") + "__" + now.Hour.ToString("D2") + "_" + now.Minute.ToString("D2") + "_" + now.Second.ToString("D2") + "_output.txt");

                                        //int index = 0;
                                        string outputString = "";
                                        AcquisitionControl.SetFlowVolume(1000);

                                        //set date time in correct format (need leading zeros)
                                        //
                                        DateTime start = AcquisitionControl.GetAcquisitionOpStartDateTime();
                                        outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:mm:ss") + ",";   //add date time formatting string here -- for modbus
                                        tw.WriteLine(outputString);
                                        //outputString = ", Acquisition Start time = ," + start.ToString("MM/dd/yyyy HH:mm:ss") + ",";
                                        //twData.WriteLine(outputString);   //add the dae to the output file

                                        tw.WriteLine("Start of EC1: " + tempString + ",");
                                        tw.WriteLine("At Sym, At No, Mass, Uncertainty, Concentration");
                                        DateTime nowValue;
                                        nowValue = DateTime.Now;
                                        outputString = ", Sample Start time = ," + nowValue.ToString("MM/dd/yyyy HH:mm:ss") + ",";
                                        twData.WriteLine(outputString);   //add the data to the output file


                                        string CrString;
                                        string CdString;
                                        string PbString;
                                        string NbString;
                                        string[] CrStringSplit;
                                        string[] CdStringSplit;
                                        string[] PbStringSplit;
                                        string[] NbStringSplit;
                                        foreach (String s in elementDataSorted)
                                        {

                                            outputString = s + ",";
                                            tw.WriteLine(outputString + ",");

                                            if (outputString.Contains("Cr"))
                                            {
                                                CrString = outputString;
                                                CrStringSplit = CrString.Split(',');
                                                twData.WriteLine(CrStringSplit[0] + "," + CrStringSplit[2]);
                                                AcquisitionControl.CheckUpscale("Cr", CrStringSplit[2], this);



                                            }
                                            else if (outputString.Contains("Cd"))
                                            {
                                                CdString = outputString;
                                                CdStringSplit = CdString.Split(',');
                                                twData.WriteLine(CdStringSplit[0] + "," + CdStringSplit[2]);
                                                AcquisitionControl.CheckUpscale("Cd", CdStringSplit[2], this);
                                            }
                                            else if (outputString.Contains("Pb"))
                                            {
                                                PbString = outputString;
                                                PbStringSplit = PbString.Split(',');
                                                twData.WriteLine(PbStringSplit[0] + "," + PbStringSplit[2]);
                                                AcquisitionControl.CheckUpscale("Pb", PbStringSplit[2], this);
                                            }
                                            else if (outputString.Contains("Nb"))
                                            {
                                                NbString = outputString;
                                                NbStringSplit = NbString.Split(',');
                                                twData.WriteLine(NbStringSplit[0] + "," + NbStringSplit[2]);
                                                AcquisitionControl.CheckUpscale("Nb", NbStringSplit[2], this);

                                            }


                                        }
                                        twData.Close();

                                        outputString = ",*****,";
                                        tw.WriteLine(outputString);
                                        //add the acquisition data from when acquisition time was taken:
                                        //bhcop
                                        //DateTime start1 = AcquisitionControl.GetAcquisitionOpStartDateTime();
                                        //outputString = ", Acquisition Start Time = ," + start.ToString();
                                        //tw.WriteLine(outputString);
                                        outputString = ", Acquisition Operating Parameters ," + start.ToString("MM/dd/yyyy HH:mm:ss") + ",";
                                        tw.WriteLine(outputString);
                                        //double ambientTemp = AcquisitionControl.GetAmbientTemp();
                                        //outputString = ", Ambient Temp (avg) = ," + ambientTemp.ToString("F2") + ",";
                                        //tw.WriteLine(outputString);
                                        //double sampleTemp = AcquisitionControl.GetSampleTemp();
                                        //outputString = ", Sample Temp (avg) = ," + sampleTemp.ToString("F2") + ",";
                                        //tw.WriteLine(outputString);
                                        //double bP = AcquisitionControl.GetAtmPress();
                                        //outputString = ", BP (avg) = ," + bP.ToString("F2") + ",";
                                        //tw.WriteLine(outputString);
                                        //double tapePress = AcquisitionControl.GetTapePress();
                                        //outputString = ", Tape Pressure (avg) = ," + tapePress.ToString("F2") + ",";
                                        //tw.WriteLine(outputString);
                                        //double flow25 = AcquisitionControl.GetFlow25();
                                        //outputString = ", Flow 25 (avg) = ," + flow25.ToString("F2") + ",";
                                        //tw.WriteLine(outputString);
                                        //double flowAct = AcquisitionControl.GetFlowAct();
                                        //outputString = ", Flow Act (avg) = ," + flowAct.ToString("F2") + ",";
                                        //tw.WriteLine(outputString);

                                        //double flowStd = AcquisitionControl.GetFlowStd();
                                        //outputString = ", Flow Std (avg) = ," + flowStd.ToString("F2") + ",";
                                        //tw.WriteLine(outputString);

                                        //double volume = AcquisitionControl.GetVolume();
                                        //outputString = ", Volume = ," + flowValue.ToString("F2") + ",";
                                        //tw.WriteLine(outputString);

                                        //double tubetemp = AcquisitionControl.GetTubeTemp();
                                        //outputString = ", Tube Temp (avg) = ," + tubetemp.ToString("F2") + ",";
                                        //tw.WriteLine(outputString);

                                        //double enclosureTemp = AcquisitionControl.GetEnclosureTemp();
                                        //outputString = ", Enclosure Temp (avg) = ," + enclosureTemp.ToString("F2") + ",";
                                        //tw.WriteLine(outputString);

                                        //double filamentMon = AcquisitionControl.GetFilamentMonitor();
                                        //outputString = ", Filament Monitor (avg) = ," + filamentMon.ToString("F2") + ",";
                                        //tw.WriteLine(outputString);

                                        //double sddTemp = AcquisitionControl.GetSDDTemp();
                                        //outputString = ", SDD Temp (avg) = ," + sddTemp.ToString("F2") + ",";
                                        //tw.WriteLine(outputString);

                                        //double ddpTemp = AcquisitionControl.GetDDPTemp();
                                        //outputString = ", DDP Temp (avg) = ," + ddpTemp.ToString("F2") + ",";
                                        //tw.WriteLine(outputString);

                                        //double relativeHumidity = AcquisitionControl.GetRelativeHumidity();
                                        //outputString = ", Relative Humidity (avg) = ," + relativeHumidity.ToString("F2") + ",";
                                        //tw.WriteLine(outputString);


                                        //double windAvg = 0;
                                        //double dirAvg = 0;
                                        //AcquisitionControl.GetWindSpeedandDirectionAvg(out windAvg, out dirAvg);

                                        //outputString = ", Wind Speed (avg) = ," + windAvg.ToString("F2") + ",";
                                        //tw.WriteLine(outputString);

                                        //outputString = ", Wind Direction (avg) = ," + dirAvg.ToString("F2") + ",";
                                        //tw.WriteLine(outputString);

                                        int sampleTime = Properties.Settings.Default.SampleTime;
                                        outputString = ", Sample Time (min) = ," + sampleTime.ToString() + ",";
                                        tw.WriteLine(outputString);

                                        tw.Close(); // must be closed before modbus can open  
                                        Logger.WriteLogFile("Done writing upscale process data file.", "C:/temp/ManualUpscale.txt");

                                        //update modbus registers/
                                        //string path = @"C:\Process_Data";  //normal process data is in process data
                                        string path = @"C:\Upscale";  //upscale has all the data from upscale time
                                                                      //upscale data has the three values



                                        string processFile = nModbusOperations.findProcessFile(path);

                                        List<string> conc_and_dateTime = new List<string>();
                                        List<string> instrumentData = new List<string>();
                                        List<string> conc_and_dateTime_No_Nb = new List<string>();

                                        nModbusOperations.getRawData(processFile, out conc_and_dateTime, out instrumentData, out conc_and_dateTime_No_Nb);

                                        ushort[] modbusDataArray = nModbusOperations.createModbusArray(conc_and_dateTime);
                                        ushort[] modbusDataArrayNoNb = nModbusOperations.createModbusArray(conc_and_dateTime_No_Nb);


                                        ushort[] dateTime = nModbusOperations.modbusDateTimeArray(modbusDataArray);
                                        ushort[] dateTimeNoNb = nModbusOperations.modbusDateTimeArray(modbusDataArrayNoNb);

                                        ushort[] telemetryData = nModbusOperations.ModbusTelemetryArray(instrumentData);

                                        ushort[] atomicNumbers = nModbusOperations.atomicNumberArray(modbusDataArray);
                                        ushort[] atomicNumbersNoNb = nModbusOperations.atomicNumberArray(modbusDataArrayNoNb);

                                        ushort[] concArray = nModbusOperations.modbusConcArray(modbusDataArray);
                                        ushort[] concArrayNoNb = nModbusOperations.modbusConcArray(modbusDataArrayNoNb);

                                        ushort[] uncArray = nModbusOperations.modbusUncArray(modbusDataArray);
                                        ushort[] uncArrayNoNb = nModbusOperations.modbusUncArray(modbusDataArrayNoNb);

                                        DataStore xactHoldingRegisters = AcquisitionControl.getDataStore();


                                        if (/*Properties.Settings.Default.OutputPin4 == false &&*/ Properties.Settings.Default.OutputPin7 == false)
                                        {
                                            nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, atomicNumbers, 100);
                                            nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, concArray, 200);
                                            nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, uncArray, 200 + concArray.Length);
                                            //nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, uncArray, 400);


                                            nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, dateTime, 701);
                                            nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, telemetryData, 701 + dateTime.Length + 1);

                                            ushort[] oneValue = new ushort[1] { 1 };
                                            Logger.WriteLogFile("Updated Modbus data registers.  Addr 700 = 1.", "C:/temp/ManualUpscale.txt");
                                            nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, oneValue, 700); // signals registers have been updated
                                            BackgroundManager.m_oWorkerFiveMinute.RunWorkerAsync();

                                            AcquisitionControl.setDataStore(xactHoldingRegisters);

                                        }

                                        //  ****************************************
                                        //update adapt database
                                        ///
                                        /// 
                                        //AdaptDB db = new AdaptDB();
                                        //string db_path = "C:\\XactControl\\Adapt\\adapt.db";  //works!
                                        //SQLiteConnection dbConnection;
                                        //db.DBConnection(db_path, out dbConnection);
                                        //db.updateDateTime(dbConnection, conc_and_dateTime, instrumentData);
                                        //db.updateXactData(dbConnection, conc_and_dateTime, instrumentData);
                                        //dbConnection.Close();
                                        //  ****************************************



                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(224);
                                    }
                                    catch (Exception Ex)
                                    {
                                        Logger.WriteInternalLogFile("Exception in state machine (222).  Ex = " + Ex.ToString());
                                        UpdateMaintCheckMessage("Error Manual Upscale data  See ErrorFile.txt");
                                        //stop acquisition thread

                                        //stop pump thread
                                        HaltUpscale("Error in Manual Upscale.  Ex=" + Ex.ToString());

                                        //ramp xrays to zero
                                        //int returnVal;

                                        ////read presentV (actual 'kV') from NI
                                        //double presentV = 0.0;
                                        //presentV = readInputVoltage;
                                        //presentV = presentV * 50.0 / 10.0;

                                        ////ActualV.Text = presentV.ToString();
                                        //presentV = Math.Round(presentV, 2, MidpointRounding.AwayFromZero);


                                        ////read presentI (actual i) from NI
                                        //double presentI = 0.0;
                                        //presentI = readInputCurrent;
                                        //presentI = presentI * 2000.0 / 10.0;
                                        //presentI = Math.Round(presentI, 2, MidpointRounding.AwayFromZero);


                                        //if (presentV > 5 && presentI > 10)
                                        //{
                                        //    Logger.WriteLogFile("c:/temp/ManualUpscale.txt", "Ramp down xrays...");

                                        //    returnVal = AcquisitionControl.RampXrays(presentV, presentI, 0.0, 0.0, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                                        //    Thread.Sleep(6000);
                                        //    //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                                        //    AcquisitionControl.InterlockOpen(this);
                                        //    //InterlockOpen();

                                        //    //if (mtbInterlockStatus.InvokeRequired)
                                        //    //{
                                        //    //    mtbInterlockStatus.Invoke(new MethodInvoker(delegate { mtbInterlockStatus.Text = "O"; }));

                                        //    //}
                                        //    //else
                                        //    //{
                                        //    //    mtbInterlockStatus.Text = "OPEN";
                                        //    //}

                                        //    Thread.Sleep(1000);

                                        //}

                                    }
                                }

                            }
                            break;

                        case 224:
                            {

                                Logger.WriteLogFile("Move DR home (224)", "c:/temp/ManualUpscale.txt");
                                UpdateMaintCheckMessage("Move Dynamic Rod Home.");

                                int returnVal = AcquisitionControl.MoveRodHome(SerialManager, this);
                                Logger.WriteLogFile("Move DR home (224) returned : " + returnVal.ToString(), "c:/temp/ManualUpscale.txt");
                                if (returnVal == PASS)
                                {
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(226);

                                }
                                else
                                {
                                    AcquisitionControl.SetCounter((AcquisitionControl.GetCounter() + 1));
                                    if (AcquisitionControl.GetCounter() >= 3)
                                    {
                                        HaltUpscale("Error:  Move DR home failed");
                                    }
                                    else
                                    {  //retry
                                        AcquisitionControl.SetState(224);
                                        Logger.WriteErrorFile("Error:  Manual Upscale (224) Move Dynamic Rod home.");
                                        UpdateMaintCheckMessage("Error:  Move Dynamic Rod Home");
                                    }
                                }
                                break;

                            }


                        case 226:  //case 32:
                            {
                                int retVal = ProcessUpscaleFiles();
                                if (retVal == PASS)
                                {
                                    UpdateMaintCheckMessage("Upscale Done  See System Tab");
                                    //see QA for display data

                                    Logger.WriteLogFile("Manual Upscale Done.", "c:/temp/ManualUpscale.txt");
                                    try
                                    {
                                        if (BackgroundManager.m_oWorkerUpscale.IsBusy)
                                        {
                                            BackgroundManager.m_oWorkerUpscale.CancelAsync();
                                        }
                                    }
                                    catch
                                    {

                                    }
                                    //UpdateMaintCheckMessage();
                                }
                                else
                                {
                                    UpdateMaintCheckMessage("Upscale Done  Error displaying values");
                                    Logger.WriteLogFile("Manual Upscale Done  Error displaying data.", "c:/temp/ManualUpscale.txt");
                                    if (BackgroundManager.m_oWorkerUpscale.IsBusy)
                                    {
                                        BackgroundManager.m_oWorkerUpscale.CancelAsync();
                                    }
                                }
                            }
                            break;
                    }

                }
                catch (Exception Ex)
                {
                    AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                    Logger.WriteInternalLogFile("Error in Manual Upscale state machine logic.  (" + AcquisitionControl.GetState().ToString() + ")  + Ex = " + Ex.ToString());
                }
                finally
                {
                    AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                    Logger.WriteLogFile("Done with Upscale state task. (" + AcquisitionControl.GetState().ToString() + ")", "c:/temp/ManualUpscale.txt");
                    Monitor.Exit(lockUpscaleObj);
                }
            }
            else
            {
                UpscaleLockCounter++;
                //lock not obtained for this timer.

                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                if (UpscaleLockCounter > 50)
                {

                    Logger.WriteLogFile("lock not obtained for Upscale timer (" + AcquisitionControl.GetState().ToString() + ")", "c:/temp/ManualUpscale.txt");
                }
            }

        }






        //private void onUpscaleTimedEvent(object source, ElapsedEventArgs e)
        //{



        //                // only execute the code within this method if we are able to
        //                // a lock. This will ensure that any Timer firings will be
        //                // ignored that occur while we're already doing work (OnTimer) 

        //                // if (!Monitor.TryEnter(obj, 2000))
        //                // {
        //                //     throw new Exception("can not lock");
        //                // }

        //                if (Monitor.TryEnter(lockUpscaleObj))
        //                {
        //                    try
        //                    {
        //            // do work here
        //            UpscaleLockCounter = 0;    

        //                        AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
        //                        //fired every one second....
        //                        string[] UpscaleValues = new string[10];

        //                        AcquisitionControl.IncTimerCounter();

        //                        try
        //                        {
        //                            int getState;
        //                            //private object lockObj;

        //                            getState = AcquisitionControl.GetState();
        //                            UpscaleValues[0] = getState.ToString();

        //                        }
        //                        catch
        //                        {
        //                            UpscaleValues[1] = "message empty.";
        //                        }

        //                        BackgroundManager.m_oWorkerUpscale.ReportProgress(AcquisitionControl.GetState(), UpscaleValues);

        //                        int curState = AcquisitionControl.GetState();

        //            switch (curState)
        //            {
        //                case 200:
        //                    {
        //                        UpdateMaintCheckMessage("Preparing to run Manual Upscale");

        //                        Logger.WriteLogFile( "Start Manual Upscale (200)", "c:/temp/ManualUpscale.txt");
        //                        Thread.Sleep(600);

        //                        UpdateMaintCheckMessage("Set Energy Condition to EC1");
        //                        Logger.WriteLogFile( "Set EC to EC1 (200)", "c:/temp/ManualUpscale.txt");
        //                        AcquisitionControl.SetEnergyCondition(1);
        //                        Thread.Sleep(600);


        //                        Logger.WriteLogFile("Move DR home (200)", "c:/temp/ManualUpscale.txt");
        //                        UpdateMaintCheckMessage("Move Dynamic Rod Home.");

        //                        int returnVal = AcquisitionControl.MoveRodHome(SerialManager, this);
        //                        Logger.WriteLogFile( "move DR home returned: " + returnVal.ToString(), "c:/temp/ManualUpscale.txt");
        //                        if (returnVal == PASS)
        //                        {
        //                            AcquisitionControl.SetCounter(0);
        //                            AcquisitionControl.SetState(202);

        //                        }
        //                        else
        //                        {
        //                            AcquisitionControl.SetCounter((AcquisitionControl.GetCounter() + 1));
        //                            if (AcquisitionControl.GetCounter() >= 3)
        //                            {
        //                                HaltUpscale("Error:  Move DR home failed");
        //                            }
        //                            else
        //                            {  
        //                                //retry
        //                                AcquisitionControl.SetState(200);
        //                                Logger.WriteErrorFile("Error:  Manual Upscale (200) Move Dynamic Rod home.");
        //                                UpdateMaintCheckMessage("Error:  Move Dynamic Rod Home");
        //                            }
        //                        }
        //                        break;

        //                    }
        //                case 202:
        //                    {
        //                        Logger.WriteLogFile( "state = 202.", "c:/temp/ManualUpscale.txt");
        //                        UpdateMaintCheckMessage("Move Dynamic Rod to Upscale");

        //                        int returnVal = AcquisitionControl.MoveRod(SerialManager, Properties.Settings.Default.UpscaleRodPosition, this);
        //                        Logger.WriteLogFile("move DR to Upscale returned: " + returnVal.ToString(), "c:/temp/ManualUpscale.txt");

        //                        int getRodPositionValue = 0;

        //                        getRodPositionValue = AcquisitionControl.PollMotorPosition(4, SerialManager);

        //                        Logger.WriteLogFile("DR at Manual Upscale returned position = " + getRodPositionValue.ToString(), "c:/temp/ManualUpscale.txt");
        //                        UpdateDynamicRodMessage("DR at position (" + getRodPositionValue.ToString() + ")");


        //                        if (returnVal == PASS)
        //                        {
        //                            AcquisitionControl.SetCounter(0);
        //                            AcquisitionControl.SetState(204);

        //                        }
        //                        else
        //                        {
        //                            AcquisitionControl.SetCounter((AcquisitionControl.GetCounter() + 1));
        //                            if (AcquisitionControl.GetCounter() >= 3)
        //                            {
        //                                HaltUpscale("Error:  Move DR upscale failed");
        //                            }
        //                            else
        //                            {  //retry
        //                                AcquisitionControl.SetState(202);
        //                                Logger.WriteErrorFile("Error: Manual Ecal (202) move DR to upscale.");
        //                                UpdateMaintCheckMessage("Error:  Move Dynamic Rod Upscale");
        //                            }
        //                        }

        //                        break;
        //                    }



        //                case 204:
        //                    {
        //                        //move filter wheel home

        //                        if (AcquisitionControl.GetCounter() == 0)
        //                        {
        //                            int returnVal24 =AcquisitionControl.MoveFWHome(SerialManager, this);
        //                            AcquisitionControl.SetEnergyConditionPrevious(0);

        //                            //confirm position
        //                            //int position=-1;

        //                            //int returnVal25 = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);
        //                            int position = AcquisitionControl.PollMotorPosition(1, SerialManager);


        //                            //Logger.WriteLogFile(   "EC " + "init" + " (destination) motor position, after home = " + position.ToString());
        //                            UpdateFilterWheelMessage("Filter wheel at position (" + position.ToString() + ")");
        //                            UpdateMaintCheckMessage("Filter wheel at position (" + position.ToString() + ")");

        //                            //if (returnVal25 == PASS && returnVal24 ==PASS)
        //                            if(position==0)
        //                            {
        //                                AcquisitionControl.SetCounter(0);
        //                                AcquisitionControl.SetState(206);

        //                            }
        //                            else
        //                            {
        //                                //could add 3x retry logic here
        //                                HaltUpscale("Manual Upscale Error:  Move FW home");
        //                            }
        //                        }
        //                        break;
        //                    }

        //                case 206:
        //                    {


        //                        Logger.WriteLogFile("state = 206.  Set flow for analysis=1000", "c:/temp/ManualUpscale.txt" );
        //                        if (AcquisitionControl.GetCounter() == 0)
        //                        {

        //                            Logger.WriteLogFile("state = 206, counter 0", "c:/temp/ManualUpscale.txt" );

        //                            //set fixed value
        //                            AcquisitionControl.SetFlowVolumeForAnalysis(1000);

        //                            //set dataset to 1 -- only data set to be used
        //                            AcquisitionControl.SetDataSet(1);

        //                            AcquisitionControl.ClrOperatingData();  //initialize the new data set; save the old for write in state 31 presentation

        //                            //pump off
        //                            int returnVal20 = AcquisitionControl.PumpOff(m_oWorkerPump);
        //                            if (returnVal20 == PASS)
        //                            {

        //                                AcquisitionControl.SetCounter(1);

        //                            }
        //                            else
        //                            {
        //                                AcquisitionControl.SetCounter(0);
        //                                AcquisitionControl.SetState(206);
        //                                Logger.WriteErrorFile("Error:  Manual Upscale (206)  Turn pump off.");
        //                                HaltUpscale("Manual Upscale:  pump off");
        //                            }

        //                        }
        //                        if (AcquisitionControl.GetCounter() == 1)
        //                        {
        //                            Logger.WriteLogFile("state = 206, counter = 1", "c:/temp/ManualUpscale.txt") ;
        //                            AcquisitionControl.SetCounter(0);
        //                            AcquisitionControl.SetState(208);
        //                        }

        //                        break;
        //                    }
        //                case 208:  //21:
        //                    {

        //                        Logger.WriteLogFile("state = 208. calculating EC times.   ", "c:/temp/ManualUpscale.txt" );
        //                        UpdateMaintCheckMessage("Calculating EC times");
        //                        Thread.Sleep(1000);

        //                                //compute the wait for EC1,2,3, normal 15m mode for Upscale
        //                                DateTime DTNow = DateTime.Now;

        //                            UpscaleStart = DTNow;   //.Date.Add(new TimeSpan(DTNow.Hour, 15, 0));
        //                                    Logger.WriteLogFile( "Upscale start time = " + UpscaleStart.ToString(), "c:/temp/ManualUpscale.txt");
        //                            UpdateMaintCheckMessage("Upscale start = " + UpscaleStart.ToString());
        //                                //}

        //                                //compute the ec1,2,3 end times:
        //                                var AcqStartTime = UpscaleStart;

        //                        double EC1p = 0.20;// AcquisitionControl.GetEC1Percent() / 100;
        //                        double EC2p = 0.40;// = AcquisitionControl.GetEC2Percent() / 100;
        //                        double EC3p = 0.40;// = AcquisitionControl.GetEC3Percent() / 100;

        //                                int SampleTime = 15;

        //                                AcquisitionControl.SetAcquireStartTimeMinutes(AcqStartTime);
        //                                //minValue1, minValue2, minValue3;
        //                                double timeValue1s;
        //                                timeValue1s = ((SampleTime * EC1p * 60) + 25);   //25 was 80 for older code (25 must match the time for NZ dn+tape mv+NZup)
        //                                int itimeValue1s = Convert.ToInt32(timeValue1s);

        //                                AcquisitionControl.SetEC1Time(itimeValue1s);  //send seconds

        //                                double timeValue2s = ((SampleTime * EC2p * 60) - 12.5);  //12.5 was 40 
        //                                int itimeValue2 = Convert.ToInt32(timeValue2s);

        //                                AcquisitionControl.SetEC2Time(itimeValue2);


        //                                double timeValue3s = ((SampleTime * EC3p * 60) - 12.5); //12.5 was 40



        //                                if ((timeValue1s + timeValue2s + timeValue3s) > (SampleTime * 60))
        //                                {
        //                                    timeValue3s = timeValue3s - ((timeValue1s + timeValue2s + timeValue3s) - SampleTime * 60);
        //                                }
        //                                Logger.WriteLogFile( "timeValue1s = " + timeValue1s.ToString() + " timeValue2s = " + timeValue2s.ToString() + " timeValue3s = " + timeValue3s.ToString(), "c:/temp/ManualUpscale.txt");

        //                                int itimeValue3 = Convert.ToInt32(timeValue3s);


        //                        //bhc only for testing testing...
        //                        //*************************************************************************
        //                        timeValue1s = 60;
        //                        timeValue2s = 60;
        //                        timeValue3s = 60;
        //                        //*************************************************************************  


        //                        AcquisitionControl.SetEC3Time(itimeValue3);

        //                        //bhc only for testing
        //                        //************************
        //                        AcquisitionControl.SetEC3Time((int)timeValue3s);      //delete after testing complete......
        //                        //************************



        //                        DateTime EC1EndTime = AcqStartTime.AddSeconds(timeValue1s);

        //                        AcquisitionControl.SetEC1EndTime(EC1EndTime);
        //                        DateTime EC2EndTime = EC1EndTime.AddSeconds(timeValue2s);
        //                        AcquisitionControl.SetEC2EndTime(EC2EndTime);

        //                        DateTime EC3EndTime = EC2EndTime.AddSeconds(itimeValue3);  //..............
        //                        // bhc only for testing ******************************* 

        //                        //DateTime EC3EndTime = EC2EndTime.AddSeconds(120);
        //                        // *******************************


        //                        AcquisitionControl.SetEC3EndTime(EC3EndTime);

        //                        Logger.WriteLogFile( "Upscale start time = " + UpscaleStart.ToString(), "c:/temp/ManualUpscale.txt");

        //                        Logger.WriteLogFile("(208) UpScale, EC1 End time: " + EC1EndTime.ToString(), "c:/temp/ManualUpscale.txt");
        //                        Logger.WriteLogFile( "(208) UpScale, EC2 End time: " + EC2EndTime.ToString(), "c:/temp/ManualUpscale.txt");
        //                        Logger.WriteLogFile( "(208) UpScale, EC3 End time: " + EC3EndTime.ToString(), "c:/temp/ManualUpscale.txt");


        //                                AcquisitionControl.SetState(210);
        //                                AcquisitionControl.SetCounter(0);

        //                        break;
        //                    }



        //                            case 210:  //case 25:
        //                                {

        //                                    int ecValue = 0;
        //                                    int destinationV = 0;
        //                                    int destinationI = 0;
        //                                    double presentV = 0.0;
        //                                    double presentI = 0.0;

        //                                    if (AcquisitionControl.GetCounter() == 0)
        //                                    {
        //                                        Logger.WriteLogFile( "state = 210. ramp xrays", "c:/temp/ManualUpscale.txt");

        //                                        AcquisitionControl.SetCounter(1);
        //                                        UpdateMaintCheckMessage("Ramping Xrays");

        //                                    }
        //                                    //EC1 ramp xrays
        //                                    ecValue = AcquisitionControl.GetEnergyCondition();
        //                                    UpdateMaintCheckMessage("Set Upscale Xray Voltages for EC"+ecValue.ToString());
        //                                    Logger.WriteLogFile( "upscale ramp voltage for EC"+ecValue.ToString(), "c:/temp/ManualUpscale.txt");

        //                                    if (ecValue == 1)
        //                                        {
        //                                            //read from parameter storage    
        //                                            int EC1kV; //EC1kV
        //                                                       //set:
        //                                                       //Properties.Settings.Default.Tnist= "abc";
        //                                                       //Properties.Settings.Default.Save();



        //                                            Logger.WriteLogFile( "UPSCALE (210)setting EC1 V and I for comm interface.", "c:/temp/ManualUpscale.txt");

        //                                            //bhc verify data reads here:

        //                                            EC1kV = Properties.Settings.Default.EC1kV;
        //                                            float fEC1kV;
        //                                            fEC1kV = Convert.ToSingle(EC1kV);
        //                                            //bool setEC1kV = myxrsfp.Send_kV[fEC1kV];

        //                                            int EC1uA; //EC1kV
        //                                            EC1uA = Properties.Settings.Default.EC1uA;
        //                                            float fEC1uA;
        //                                            fEC1uA = Convert.ToSingle(EC1uA);
        //                                            //bool setEC1uA = myxrsfp.Send_uA[fEC1uA];

        //                                            destinationV = Convert.ToInt32(fEC1kV);
        //                                            destinationI = Convert.ToInt32(fEC1uA);

        //                        }
        //                                        else if (ecValue == 2)
        //                                        {

        //                                            Logger.WriteLogFile("UPSCALE (210) setting EC2 V and I for comm interface.", "c:/temp/ManualUpscale.txt");

        //                                            int EC2kV;
        //                                            EC2kV = Properties.Settings.Default.EC2kV;
        //                                            float fEC2kV;
        //                                            fEC2kV = Convert.ToSingle(EC2kV);

        //                                            int EC2uA;
        //                                            EC2uA = Properties.Settings.Default.EC2uA;
        //                                            float fEC2uA;
        //                                            fEC2uA = Convert.ToSingle(EC2uA);

        //                                            destinationV = Convert.ToInt32(fEC2kV);
        //                                            destinationI = Convert.ToInt32(fEC2uA);

        //                                        }
        //                                        else if (ecValue == 3)
        //                                        {
        //                                            Logger.WriteLogFile( "UPSCALE (210) setting EC3 V and I for comm interface.","c:/temp/ManualUpscale.txt" );

        //                                            int EC3kV;
        //                                            EC3kV = Properties.Settings.Default.EC3kV;
        //                                            float fEC3kV;
        //                                            fEC3kV = Convert.ToSingle(EC3kV);

        //                                            int EC3uA;
        //                                            EC3uA = Properties.Settings.Default.EC3uA;
        //                                            float fEC3uA;
        //                                            fEC3uA = Convert.ToSingle(EC3uA);


        //                                            destinationV = Convert.ToInt32(fEC3kV);
        //                                            destinationI = Convert.ToInt32(fEC3uA);

        //                                        }

        //                                        presentV = readInputVoltage;
        //                                        presentV = presentV * 50.0 / 10.0;


        //                                        presentI = readInputCurrent;
        //                                        presentI = presentI * 2000.0 / 10.0;


        //                                        Logger.WriteLogFile( "UPSCALE ramp V from: " + presentV.ToString("F2") + " to: " + destinationV.ToString("F2"), "c:/temp/ManualUpscale.txt");
        //                                        Logger.WriteLogFile( "UPSCALE ramp I from: " + presentI.ToString("F2") + " to: " + destinationI.ToString("F2"), "c:/temp/ManualUpscale.txt");



        //                                    int returnVal25 = AcquisitionControl.RampXrays(presentV, presentI, destinationV, destinationI, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);

        //                                    if (mtbInterlockStatus.InvokeRequired)
        //                                    {
        //                                        mtbInterlockStatus.Invoke(new MethodInvoker(delegate { mtbInterlockStatus.Text = "Closed"; }));

        //                                    }
        //                                    else
        //                                    {
        //                                        mtbInterlockStatus.Text = "Closed";
        //                                    }

        //                                    if (returnVal25 == PASS)
        //                                    {
        //                                        Logger.WriteLogFile("Xray Ramp:  PASS.", "c:/temp/ManualUpscale.txt");


        //                                        AcquisitionControl.SetCounter(0);
        //                                        AcquisitionControl.SetState(212);


        //                                    }
        //                                    else
        //                                    {

        //                                        Logger.WriteErrorFile("Error: Manual Upscale (210) Unable to ramp xrays.");
        //                                        HaltUpscale("Error Unable To Ramp Xrays");
        //                                    }
        //                                    break; 
        //                                }
        //                            case 212:  //case 26
        //                                {
        //                                    Logger.WriteLogFile( "state = 212. loading master tfr file", "c:/temp/ManualUpscale.txt");

        //                                    if (AcquisitionControl.GetCounter() == 0)
        //                                    {
        //                                        AcquisitionControl.SetCounter(1);
        //                                        UpdateMaintCheckMessage("Loading Master TFR File");
        //                                    }


        //                                    int energyCondition = AcquisitionControl.GetEnergyCondition();
        //                                    int returnVal26 = AcquisitionControl.LoadMTFRFile(energyCondition);
        //                                    if (returnVal26 == PASS)
        //                                    {

        //                                        Logger.WriteLogFile("(212) load MFTRFile + cond code returned: true", "c:/temp/ManualUpscale.txt");
        //                                        AcquisitionControl.SetCounter(0);
        //                                        AcquisitionControl.SetState(214);

        //                                    }
        //                                    else
        //                                    {
        //                                        Logger.WriteErrorFile("Error: Manual Upscale (212)  Unable to load master tfr file  " + energyCondition.ToString());
        //                                        HaltUpscale("Control state 212 Unable to load master tfr file " + energyCondition.ToString());
        //                                    }
        //                                    break;
        //                                }


        //                            case 214:  //case 27:
        //                                {
        //                                    int enCond = AcquisitionControl.GetEnergyCondition();
        //                                    Logger.WriteLogFile( "state = 214.  Move FW to EC"+enCond.ToString(), "c:/temp/ManualUpscale.txt");
        //                                    //UpdateMaintCheckMessage("Move FW to EC" + enCond.ToString());

        //                                    string status;
        //                                    int ECend;
        //                                    int ECstart;

        //                                    ECend = AcquisitionControl.GetEnergyCondition();
        //                                    ECstart = AcquisitionControl.GetEnergyConditionPrevious();

        //                                    status = "Move Filter Wheel to EC " + ECend.ToString();
        //                                    Logger.WriteLogFile( "state = 214. " + status, "c:/temp/ManualUpscale.txt");


        //                                    Logger.WriteLogFile( "Moving FW from: " + ECstart.ToString() + " to: " + ECend.ToString(), "c:/temp/ManualUpscale.txt");
        //                                    //displayActionQueue.Enqueue("moving FW from: " + ECstart.ToString() + " to: " + ECend.ToString());
        //                                    UpdateMaintCheckMessage("Moving FW from: EC" + ECstart.ToString() + " to EC" + ECend.ToString());

        //                                    int beforePosition = 0;

        //                        //int returnVal = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out beforePosition);

        //                                    beforePosition = AcquisitionControl.PollMotorPosition(1, SerialManager);

        //                                    Logger.WriteLogFile( "EC " + ECend.ToString() + " (destination) motor position, before move = " + beforePosition.ToString(), "c:/temp/ManualUpscale.txt");
        //                                    //Logger.WriteLogFile("Check before FW postion returned: " + returnVal.ToString(), "c:/temp/ManualUpscale.txt");



        //                                    int returnVal27 = AcquisitionControl.MoveFWEC(SerialManager, ECstart, ECend, this);
        //                                    if (returnVal27 == PASS)
        //                                    {

        //                                        Logger.WriteLogFile("Move to EC" + ECend.ToString() + " returned PASS.", "C:/temp/ManualUpscale.txt" );
        //                                        int position = 0;

        //                                        //returnVal27 = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);  //1=FW
        //                                        position = AcquisitionControl.PollMotorPosition(1, SerialManager);





        //                                        Logger.WriteLogFile( "EC " + ECend.ToString() + " (destination) motor position, after move = " + position.ToString(), "C:/temp/ManualUpscale.txt");
        //                                        //Logger.WriteLogFile("C:/temp/ManualUpscale.txt", "Check FW motor postion returned: " + returnVal27.ToString());
        //                                        //UpdateMaintCheckMessage("Check FW motor postion returned: " + returnVal27.ToString());

        //                                        if (ECend == 1)
        //                                        {

        //                                            //bhc -- change to position values
        //                                            //Logger.WriteLogFile(   "EC (destination) motor position = " + position.ToString());
        //                                            //int pos = Properties.Settings.Default.FWEC1;

        //                                            if (position == Properties.Settings.Default.FWEC1)

        //                                            {
        //                                                UpdateMaintCheckMessage("FW at EC1 ("+position.ToString()+")");

        //                                                AcquisitionControl.SetEnergyConditionPrevious(1);  //
        //                                                AcquisitionControl.SetCounter(0);
        //                                                AcquisitionControl.SetState(216);
        //                                            }
        //                                            else
        //                                            {
        //                                                //incorrect position returned
        //                                                AcquisitionControl.SetCounter(AcquisitionControl.GetCounter()+1);
        //                                                if (AcquisitionControl.GetCounter() <= 3)
        //                                                {

        //                                                    Logger.WriteErrorFile("Error:  Manual Upscale state (214) unable to move Filter Wheel to EC1.");
        //                                                    Logger.WriteLogFile( "Incorrect position returned.  Sending FW home", "C:/temp/ManualUpscale.txt");
        //                                                    UpdateMaintCheckMessage("Error:  Position read Filter Wheel EC1");
        //                                                    int retVal=AcquisitionControl.MoveFWHome(SerialManager, this);
        //                                                    if (retVal == PASS)
        //                                                    {
        //                                                        AcquisitionControl.SetEnergyConditionPrevious(0);
        //                                                        AcquisitionControl.SetState(214);
        //                                                    }
        //                                                    else
        //                                                    {
        //                                                        HaltUpscale("Unable to move FW Home");
        //                                                    }
        //                                                }
        //                                                else
        //                                                {
        //                                                    HaltUpscale("Unable to move FW to EC1");
        //                                                }


        //                                            }
        //                                        }
        //                                        else if (ECend == 2)
        //                                        {
        //                                            //Logger.WriteLogFile(   "EC "+ECend.ToString()+ " (destination) motor position, after move = " + position.ToString());
        //                                            if (position == Properties.Settings.Default.FWEC2)
        //                                            {
        //                                                UpdateMaintCheckMessage("FW at EC2 (" + position.ToString() + ")");
        //                                                AcquisitionControl.SetEnergyConditionPrevious(2);
        //                                                AcquisitionControl.SetCounter(0);
        //                                                AcquisitionControl.SetState(216);
        //                                            }
        //                                            else
        //                                            {


        //                                                //incorrect position returned
        //                                                AcquisitionControl.SetCounter(AcquisitionControl.GetCounter() + 1);
        //                                                if (AcquisitionControl.GetCounter() <= 3)
        //                                                {

        //                                                    Logger.WriteErrorFile("Error:  Manual Upscale (214) Unable to move Filter Wheel to EC2.");
        //                                                    Logger.WriteLogFile( "Incorrect position returned.  Sending FW home", "C:/temp/ManualUpscale.txt");
        //                                                    UpdateMaintCheckMessage("Error:  Position read Filter Wheel EC2");
        //                                                    int retVal = AcquisitionControl.MoveFWHome(SerialManager, this);

        //                                                    if (retVal == PASS)
        //                                                    {
        //                                                        AcquisitionControl.SetEnergyConditionPrevious(0);
        //                                                        AcquisitionControl.SetState(214);
        //                                                    }
        //                                                    else
        //                                                    {
        //                                                        HaltUpscale("Unable to move FW home");
        //                                                    }    
        //                                                }
        //                                                else
        //                                                {
        //                                                    HaltUpscale("Unable to move FW to EC2");
        //                                                }



        //                                            }
        //                                        }
        //                                        else if (ECend == 3)
        //                                        {
        //                                            //Logger.WriteLogFile(   "EC " + ECend.ToString() + " (destination) motor position, after move = " + position.ToString());
        //                                            if (position == Properties.Settings.Default.FWEC3)
        //                                            {
        //                                                UpdateMaintCheckMessage("FW at EC3 (" + position.ToString() + ")");

        //                                                AcquisitionControl.SetEnergyConditionPrevious(3);
        //                                                AcquisitionControl.SetCounter(0);
        //                                                AcquisitionControl.SetState(216);
        //                                            }
        //                                            else
        //                                            {
        //                                                //incorrect position returned
        //                                                AcquisitionControl.SetCounter(AcquisitionControl.GetCounter() + 1);
        //                                                if (AcquisitionControl.GetCounter() <= 3)
        //                                                {

        //                                                    Logger.WriteErrorFile("Error:  Manual Upscale (214) Unable to move Filter Wheel to EC3.");
        //                                                    Logger.WriteLogFile("Incorrect position returned.  Sending FW home", "C:/temp/ManualUpscale.txt" );
        //                                                    UpdateMaintCheckMessage("Error:  Position read Filter Wheel EC3");
        //                                                    int retVal = AcquisitionControl.MoveFWHome(SerialManager, this);
        //                                                    if (retVal == PASS)
        //                                                    {

        //                                                        AcquisitionControl.SetEnergyConditionPrevious(0);
        //                                                        AcquisitionControl.SetState(214);
        //                                                    }
        //                                                    else
        //                                                    {
        //                                                        HaltUpscale("Unable to move FW Home");
        //                                                    }
        //                                                }
        //                                                else
        //                                                {
        //                                                    HaltUpscale("Unable to move FW to EC3");
        //                                                }


        //                                            }
        //                                        }

        //                                    }
        //                                    else
        //                                    {

        //                                        Logger.WriteErrorFile("Error:  Manual Upscale (214) Unable to move Filter Wheel");
        //                                        HaltUpscale("Error Unable to move FW");

        //                                    }
        //                                }
        //                                break;

        //                            case 216:
        //                                {
        //                                    Logger.WriteLogFile("state = 216. Start and Wait for EC time to expire.", "c:/temp/ManualUpscale.txt" );

        //                                    int CurrentEC = AcquisitionControl.GetEnergyCondition();


        //                                        if (/*AcquisitionControl.GetEC1Enabled()==true && */ CurrentEC == 1)
        //                                        {
        //                                            if (AcquisitionControl.GetCounter() == 0)
        //                                            {
        //                                                //this needs be the date time used for data writing purposes 
        //                                                DateTime upscaleStartTime = DateTime.Now;
        //                                                AcquisitionControl.SetAcquireStartTime(upscaleStartTime);
        //                                                AcquisitionControl.SetAcquisitionOpStartDateTime();  // sets start time to now

        //                                                DateTime ec1time = AcquisitionControl.GetEC1EndTime();
        //                                                TimeSpan time = ec1time - DateTime.Now;

        //                                                Logger.WriteLogFile( "EC1 start time: " + DateTime.Now.ToString(), "c:/temp/ManualUpscale.txt");

        //                                                float kV;
        //                                                string kVs;
        //                                                //tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Text = Tnistvalue.ToString(); }));//sets the value
        //                                                //string actualValue;
        //                                                if (mtbIOActualkV.InvokeRequired)
        //                                                {
        //                                                    mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
        //                                                }
        //                                                else
        //                                                {
        //                                                    actualValueV = mtbIOActualkV.Text;
        //                                                }

        //                                                kVs = actualValueV;
        //                                                kV = Convert.ToSingle(kVs);
        //                                                bool boolresponse_kV = myxrsfp.Send_kV[kV];
        //                                                float uA;
        //                                                string uAs;
        //                                                if (mtbIOActualuA.InvokeRequired)
        //                                                {
        //                                                    mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
        //                                                }
        //                                                else
        //                                                {
        //                                                    actualValueI = mtbIOActualuA.Text;
        //                                                }
        //                                                uAs = actualValueI;
        //                                                uA = Convert.ToSingle(uAs);

        //                                                bool boolresponse_uA = myxrsfp.Send_uA[uA];
        //                                                Logger.WriteInternalLogFile("before EC1 AC kV = " + kV.ToString("F2"));
        //                                                Logger.WriteInternalLogFile("before EC1 AC uA = " + uA.ToString("F2"));

        //                                                AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) - PRESET_END_ADJUST_UPSCALE);

        //                                                Thread.Sleep(3000);
        //                                                float deadTime=0;
        //                                                if (Properties.Settings.Default.EC1AC.Contains("ON"))
        //                                                {

        //                                                    AcquisitionControl.AutoCurrent((readInputCurrent * 2000.0 / 10.0), (readInputVoltage*50.0/10.0),m_oWorkerRamp, LinearRampValuesVoltage,LinearRampValuesCurrent,this);

        //                                                    if (mtbIOActualkV.InvokeRequired)
        //                                                    {
        //                                                        mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
        //                                                    }
        //                                                    else
        //                                                    {
        //                                                        actualValueV = mtbIOActualkV.Text;
        //                                                    }

        //                                                    kVs = actualValueV;
        //                                                    kV = Convert.ToSingle(kVs);
        //                                                    bool boolresponse_kV2 = myxrsfp.Send_kV[kV];
        //                                                    //float uA;
        //                                                    //string uAs;
        //                                                    if (mtbIOActualuA.InvokeRequired)
        //                                                    {
        //                                                        mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
        //                                                    }
        //                                                    else
        //                                                    {
        //                                                        actualValueI = mtbIOActualuA.Text;
        //                                                    }
        //                                                    uAs = actualValueI;
        //                                                    uA = Convert.ToSingle(uAs);
        //                                                    bool boolresponse_uA2 = myxrsfp.Send_uA[uA];

        //                                                    Logger.WriteInternalLogFile("after EC1 AC kV = " + kV.ToString("F2"));
        //                                                    Logger.WriteInternalLogFile("after EC1 AC uA = " + uA.ToString("F2"));


        //                                                }
        //                                                else
        //                                                {
        //                                                    deadTime = AcquisitionControl.GetDeadTime();
        //                                                }

        //                                                Logger.WriteLogFile("EC1 deadTime = " + deadTime.ToString("F2"), "c:/temp/ManualUpscale.txt");

        //                                                AcquisitionControl.SetCounter(1);

        //                                            }
        //                                            DateTime AcquisitionStartTime = AcquisitionControl.GetAcquireStartTime();

        //                                            var TimeRemaining = AcquisitionControl.GetEC1EndTime() - System.DateTime.Now;

        //                                            if (TimeRemaining.Seconds % 10==0)
        //                                            {
        //                                                Logger.WriteLogFile("Time Remaining EC1 = " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"), "c:/temp/ManualUpscale.txt" );
        //                                            }
        //                                            UpdateMaintCheckMessage("Time Remaining EC1 = " + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"));


        //                                            if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
        //                                            {
        //                                                UpdateMaintCheckMessage("End EC1");
        //                                                Logger.WriteLogFile("End EC1, save spec Raw and Adj, calling auto analyze.", "c:/temp/ManualUpscale.txt" );



        //                                                UpdateMaintCheckMessage("Saving CES spectrum, raw");

        //                                                AcquisitionControl.SaveCESSpectrumRaw("c:/spectrum_data_raw", "sp_data_UPSCALE", 1);
        //                                                Thread.Sleep(500);
        //                                                UpdateMaintCheckMessage("Adjusting spectrum");
        //                                                Thread.Sleep(500);
        //                                                AcquisitionControl.AdjustSpectrum();
        //                                                UpdateMaintCheckMessage("Saving CES spectrum, adjusted");

        //                                                AcquisitionControl.SaveCESSpectrum("c:/spectrum_data", "sp_data_UPSCALE", 1);
        //                                                Thread.Sleep(500);
        //                                                UpdateMaintCheckMessage("Performing auto analyze");
        //                                                AcquisitionControl.AutoAnalyze();
        //                                                AcquisitionControl.SetCounter(0);
        //                                                AcquisitionControl.SetState(218);

        //                                            }

        //                                        }
        //                                        else if (/*AcquisitionControl.GetEC2Enabled() == true && */ CurrentEC == 2)
        //                                        {


        //                                            if (AcquisitionControl.GetCounter() == 0)
        //                                            {
        //                                                DateTime ec2time = AcquisitionControl.GetEC2EndTime();
        //                                                TimeSpan time = ec2time - DateTime.Now;
        //                                                Logger.WriteLogFile( "EC2 start time: " + DateTime.Now.ToString(), "c:/temp/ManualUpscale.txt");

        //                                                float kV;
        //                                                string kVs;

        //                                                if (mtbIOActualkV.InvokeRequired)
        //                                                {
        //                                                    mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
        //                                                }
        //                                                else
        //                                                {
        //                                                    actualValueV = mtbIOActualkV.Text;
        //                                                }

        //                                                kVs = actualValueV;
        //                                                kV = Convert.ToSingle(kVs);
        //                                                bool boolresponse_kV = myxrsfp.Send_kV[kV];
        //                                                float uA;
        //                                                string uAs;
        //                                                if (mtbIOActualuA.InvokeRequired)
        //                                                {
        //                                                    mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
        //                                                }
        //                                                else
        //                                                {
        //                                                    actualValueI = mtbIOActualuA.Text;
        //                                                }

        //                                                uAs = actualValueI;
        //                                                uA = Convert.ToSingle(uAs);
        //                                                bool boolresponse_uA = myxrsfp.Send_uA[uA];
        //                                                Logger.WriteInternalLogFile("before EC2 AC kV = " + kV.ToString("F2"));
        //                                                Logger.WriteInternalLogFile("before EC2 AC uA = " + uA.ToString("F2"));

        //                                                AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) - PRESET_END_ADJUST_UPSCALE);
        //                                                Thread.Sleep(3000);
        //                                                float deadTime = 0.0F;
        //                                                if (Properties.Settings.Default.EC2AC.Contains("ON"))
        //                                                {                 
        //                                                    AcquisitionControl.AutoCurrent((readInputCurrent * 2000.0 / 10.0), (readInputVoltage * 50.0 / 10.0), m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
        //                                                    //float kV;
        //                                                    //string kVs;

        //                                                    if (mtbIOActualkV.InvokeRequired)
        //                                                    {
        //                                                        mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
        //                                                    }
        //                                                    else
        //                                                    {
        //                                                        actualValueV = mtbIOActualkV.Text;
        //                                                    }

        //                                                    kVs = actualValueV;
        //                                                    kV = Convert.ToSingle(kVs);
        //                                                    bool boolresponse_kV3 = myxrsfp.Send_kV[kV];
        //                                                    //float uA;
        //                                                    //string uAs;
        //                                                    if (mtbIOActualuA.InvokeRequired)
        //                                                    {
        //                                                        mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
        //                                                    }
        //                                                    else
        //                                                    {
        //                                                        actualValueI = mtbIOActualuA.Text;
        //                                                    }

        //                                                    uAs = actualValueI;
        //                                                    uA = Convert.ToSingle(uAs);
        //                                                    bool boolresponse_uA3 = myxrsfp.Send_uA[uA];
        //                                                    Logger.WriteInternalLogFile("after EC2 AC kV = " + kV.ToString("F2"));
        //                                                    Logger.WriteInternalLogFile("after EC2 AC uA = " + uA.ToString("F2"));


        //                                                }
        //                                                else
        //                                                {
        //                                                    deadTime = AcquisitionControl.GetDeadTime();
        //                                                }


        //                                                Logger.WriteLogFile( "(216) EC2 deadTime = " + deadTime.ToString("F2"), "c:/temp/ManualUpscale.txt");

        //                                                AcquisitionControl.SetCounter(1);
        //                                            }

        //                                            DateTime AcquisitionStartTime = AcquisitionControl.GetAcquireStartTime();

        //                                            var TimeRemaining = AcquisitionControl.GetEC2EndTime() - System.DateTime.Now;

        //                                            UpdateMaintCheckMessage("Time Remaining EC2 = " + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"));
        //                                            if (TimeRemaining.Seconds % 10 == 0)
        //                                            {

        //                                                Logger.WriteLogFile("Time Remaining EC2 = " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"), "c:/temp/ManualUpscale.txt" );
        //                                            }

        //                                            if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
        //                                            {
        //                                                UpdateMaintCheckMessage("End EC2");
        //                                                Logger.WriteLogFile( "End EC2, save spec, calling auto analyze.", "c:/temp/ManualUpscale.txt");

        //                                                AcquisitionControl.SaveCESSpectrumRaw("c:/spectrum_data_raw", "sp_data_UPSCALE", 2);
        //                                                AcquisitionControl.AdjustSpectrum();

        //                                                AcquisitionControl.SaveCESSpectrum("c:/spectrum_data", "sp_data_UPSCALE", 2);

        //                                                AcquisitionControl.AutoAnalyze();
        //                                                AcquisitionControl.SetCounter(0);
        //                                                AcquisitionControl.SetState(218);
        //                                            }

        //                                        }

        //                                        else if (/*AcquisitionControl.GetEC3Enabled() == true && */ CurrentEC == 3)
        //                                        {

        //                                            if (AcquisitionControl.GetCounter() == 0)
        //                                            {
        //                                                DateTime ec3time = AcquisitionControl.GetEC3EndTime();
        //                                                TimeSpan time = ec3time - DateTime.Now;
        //                                                Logger.WriteLogFile( "EC3 start time: " + DateTime.Now.ToString(), "c:/temp/ManualUpscale.txt");   //date time format

        //                                                float kV;
        //                                                string kVs;
        //                                                if (mtbIOActualkV.InvokeRequired)
        //                                                {
        //                                                    mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
        //                                                }
        //                                                else
        //                                                {
        //                                                    actualValueV = mtbIOActualkV.Text;
        //                                                }
        //                                                kVs = actualValueV;
        //                                                kV = Convert.ToSingle(kVs);
        //                                                bool boolresponse_kV = myxrsfp.Send_kV[kV];
        //                                                float uA;
        //                                                string uAs;

        //                                                if (mtbIOActualuA.InvokeRequired)
        //                                                {

        //                                                    mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
        //                                                }
        //                                                else
        //                                                {
        //                                                    actualValueI = mtbIOActualuA.Text;
        //                                                }

        //                                                uAs = actualValueI;
        //                                                uA = Convert.ToSingle(uAs);
        //                                                bool boolresponse_uA = myxrsfp.Send_uA[uA];

        //                                Logger.WriteInternalLogFile("before EC3 AC kV = " + kV.ToString("F2"));
        //                                Logger.WriteInternalLogFile("before EC3 AC uA = " + uA.ToString("F2"));

        //                                AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) - PRESET_END_ADJUST_UPSCALE);


        //                                Thread.Sleep(3000);
        //                                float deadTime = 0;
        //                                if (Properties.Settings.Default.EC3AC.Contains("ON"))
        //                                {

        //                                    AcquisitionControl.AutoCurrent((readInputCurrent * 2000.0 / 10.0), (readInputVoltage * 50.0 / 10.0), m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);

        //                                    //float kV;
        //                                    //string kVs;

        //                                    if (mtbIOActualkV.InvokeRequired)
        //                                    {
        //                                        mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
        //                                    }
        //                                    else
        //                                    {
        //                                        actualValueV = mtbIOActualkV.Text;
        //                                    }

        //                                    kVs = actualValueV;
        //                                    kV = Convert.ToSingle(kVs);
        //                                    bool boolresponse_kV3 = myxrsfp.Send_kV[kV];
        //                                    //float uA;
        //                                    //string uAs;
        //                                    if (mtbIOActualuA.InvokeRequired)
        //                                    {
        //                                        mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
        //                                    }
        //                                    else
        //                                    {
        //                                        actualValueI = mtbIOActualuA.Text;
        //                                    }

        //                                    uAs = actualValueI;
        //                                    uA = Convert.ToSingle(uAs);
        //                                    bool boolresponse_uA3 = myxrsfp.Send_uA[uA];

        //                                    Logger.WriteInternalLogFile("after EC3 AC kV = " + kV.ToString("F2"));
        //                                    Logger.WriteInternalLogFile("after EC3 AC uA = " + uA.ToString("F2"));


        //                                }
        //                                else
        //                                {
        //                                    deadTime = AcquisitionControl.GetDeadTime();
        //                                }
        //                                Logger.WriteLogFile("Manual Upscale EC3 dead time = " + deadTime.ToString("F2"), "c:/temp/ManualUpscale.txt");


        //                                //double deadTime = AcquisitionControl.GetDeadTime();
        //                                //Logger.WriteLogFile("c:/temp/ManualUpscale.txt", "EC3 deadTime = " + deadTime.ToString("F2"));

        //                                                AcquisitionControl.SetCounter(1);
        //                                            }


        //                                            //time to wait 3
        //                                            DateTime AcquisitionStartTime = AcquisitionControl.GetAcquireStartTime();

        //                                            var TimeRemaining = AcquisitionControl.GetEC3EndTime() - System.DateTime.Now;
        //                                            UpdateMaintCheckMessage("Time Remaining EC3 = " + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"));
        //                                            if (TimeRemaining.Seconds % 10 == 0)
        //                                            {

        //                                                Logger.WriteLogFile("Time Remaining EC3 = " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"), "c:/temp/ManualUpscale.txt" );
        //                                            }
        //                                            if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
        //                                            {

        //                                                UpdateMaintCheckMessage("End EC3");                
        //                                                Logger.WriteLogFile("End EC3, saving spectra, calling auto analyze.", "c:/temp/ManualUpscale.txt");
        //                                                AcquisitionControl.SaveCESSpectrumRaw("c:/spectrum_data_raw", "sp_data_UPSCALE", 3);
        //                                                AcquisitionControl.AdjustSpectrum();
        //                                                AcquisitionControl.SaveCESSpectrum("c:/spectrum_data", "sp_data_UPSCALE", 3);

        //                                                AcquisitionControl.AutoAnalyze();
        //                                                AcquisitionControl.SetCounter(0);
        //                                                AcquisitionControl.SetState(218);

        //                                            }

        //                                        }
        //                                        //no ec4 -- in upscale -- 


        //                                    }

        //                                break;

        //                            case 218:
        //                                {

        //                                    Logger.WriteLogFile( "state = 218 (wait for autoanalyze to complete). ", "c:/temp/ManualUpscale.txt");
        //                                    // wait for Auto Analyze to complete
        //                                    int AACounter;
        //                                    if (AcquisitionControl.GetEnergyCondition() == 1 ) // && AcquisitionControl.GetEC1Done()==false )
        //                                    {
        //                                        AACounter = AcquisitionControl.GetCounter();
        //                                        AACounter++;
        //                                        AcquisitionControl.SetCounter(AACounter);
        //                                        if (AACounter == 8)  //this is the time to complete auto analyze
        //                                        {
        //                                            AcquisitionControl.SetEC1Done(true);
        //                                            UpdateMaintCheckMessage("EC1 Auto Analyze done");
        //                                            if (AcquisitionControl.GetEC2Enabled() == true)
        //                                            {
        //                                                    Logger.WriteLogFile( "state = 218 (wait for autoanalyze to complete) ec1 done -- set ec to ec2. ", "c:/temp/ManualUpscale.txt");
        //                                                    UpdateMaintCheckMessage("Set EC to EC2");
        //                                                    AcquisitionControl.SetEnergyCondition(2);
        //                                                    AcquisitionControl.SetState(210);           
        //                                                    AcquisitionControl.SetCounter(0);

        //                                             }
        //                                             else
        //                                             {

        //                                                    //done with all EC in acquisition
        //                                                    UpdateMaintCheckMessage("Done with all EC (EC2 disabled)");

        //                                                    AcquisitionControl.SetCounter(0);
        //                                                    AcquisitionControl.SetState(220);
        //                                             }

        //                                         }
        //                                     }
        //                                     else if (AcquisitionControl.GetEnergyCondition() == 2 ) // && AcquisitionControl.GetEC2Done() == false )
        //                                     {
        //                                            AACounter = AcquisitionControl.GetCounter();
        //                                            AACounter++;
        //                                            AcquisitionControl.SetCounter(AACounter);
        //                                            if (AACounter >= 8)
        //                                            {
        //                                                AcquisitionControl.SetEC2Done(true);
        //                                                UpdateMaintCheckMessage("EC2 Auto Analyze done");
        //                                                if (AcquisitionControl.GetEC3Enabled() == true)
        //                                                {
        //                                                    Logger.WriteLogFile(   "EC2 done, EC = EC3.");
        //                                                    UpdateMaintCheckMessage("Set EC to EC3");
        //                                                    AcquisitionControl.SetEnergyCondition(3);
        //                                                    AcquisitionControl.SetState(210);
        //                                                    AcquisitionControl.SetCounter(0);
        //                                                }
        //                                                else
        //                                                {
        //                                                    //done with all EC in acquisition
        //                                                    UpdateMaintCheckMessage("All EC done (EC3 disabled)");
        //                                                    Logger.WriteLogFile( "all EC done, state = 30.", "c:/temp/ManualUpscale.txt");
        //                                                    AcquisitionControl.SetCounter(0);
        //                                                    AcquisitionControl.SetState(220);
        //                                                }

        //                                            }


        //                                        }
        //                                        else if (AcquisitionControl.GetEnergyCondition() == 3 ) //&& AcquisitionControl.GetEC3Done() == false)
        //                                        {
        //                                            AACounter = AcquisitionControl.GetCounter();
        //                                            AACounter++;
        //                                            AcquisitionControl.SetCounter(AACounter);
        //                                            if (AACounter == 8)
        //                                            {
        //                                                AcquisitionControl.SetEC3Done(true);
        //                                                UpdateMaintCheckMessage("EC3 Auto Analyze done");

        //                                                AcquisitionControl.SetCounter(0);
        //                                                AcquisitionControl.SetState(220);

        //                                            }

        //                                        }

        //                                    break;
        //                                }
        //                            case 220: //case 30:
        //                                {
        //                                    AcquisitionControl.SetCounter(0);
        //                                    AcquisitionControl.SetState(222);

        //                                    break;

        //                                }

        //                            case 222:  // 'case 31':
        //                                {

        //                        if (AcquisitionControl.GetCounter() == 0)
        //                        {

        //                            try
        //                            {
        //                                //process normal output
        //                                Logger.WriteLogFile("state=222", "C:/temp/ManualUpscale.txt" );
        //                                UpdateMaintCheckMessage("Calculating Upscale data");
        //                                Thread.Sleep(500);
        //                                double flowForCalculation;
        //                                flowForCalculation = 1000; //removes multiply by 1000 during upscale
        //                                Logger.WriteLogFile( "(222) flow for calculation:  " + flowForCalculation.ToString("F3"), "C:/temp/ManualUpscale.txt");


        //                                string line;
        //                                int numberofElements = 0;


        //                                List<string> elementDataSorted = new List<string>();
        //                                List<string> elementData = new List<string>();
        //                                List<string> elementDataSymbol = new List<string>();
        //                                List<string> elementDataAtWt = new List<string>();
        //                                List<string> elementDataConc = new List<string>();
        //                                List<string> elementDataUncer = new List<string>();
        //                                List<string> elementDataConV = new List<string>();

        //                                string tempString = "";
        //                                Logger.WriteLogFile( "(222) processing data1 file", "C:/temp/ManualUpscale.txt");
        //                                UpdateMaintCheckMessage("Processing file 1");

        //                                System.IO.StreamReader file1 = new System.IO.StreamReader("c:/process_data/data1.txt");

        //                                while ((line = file1.ReadLine()) != null)
        //                                {
        //                                    if (line.Contains("StartTime"))
        //                                    {
        //                                        tempString = line;
        //                                    }
        //                                    if (line.Contains("NumElements"))
        //                                    {
        //                                        string[] items = line.Split(',');
        //                                        numberofElements = Convert.ToInt16(items[1]);
        //                                        line = file1.ReadLine();

        //                                        for (int i = 0; i < numberofElements; i++)
        //                                        {
        //                                            line = file1.ReadLine();
        //                                            if (line.Contains("Xx"))
        //                                            {
        //                                                continue;
        //                                            }
        //                                            else
        //                                            {
        //                                                string[] elementItems = line.Split(',');

        //                                                elementDataSymbol.Add(elementItems[0]);
        //                                                elementData.Add(elementItems[0]);
        //                                                elementDataAtWt.Add(elementItems[1]);
        //                                                elementData.Add(elementItems[1]);
        //                                                elementDataConc.Add(elementItems[2]);   //actually MASS
        //                                                elementData.Add(elementItems[2]);

        //                                                elementDataUncer.Add(elementItems[3]);
        //                                                elementData.Add(elementItems[3]);

        //                                                double conc = Convert.ToDouble(elementDataConc.Last());

        //                                                double concentration = (conc * 1000) / flowForCalculation;

        //                                                elementDataConV.Add(concentration.ToString());

        //                                                elementData.Add(concentration.ToString());
        //                                            }
        //                                        }
        //                                    }
        //                                }

        //                                file1.Close();


        //                                Logger.WriteLogFile("(222) processing data2 file", "C:/temp/ManualUpscale.txt");

        //                                UpdateMaintCheckMessage("processing file 2");

        //                                System.IO.StreamReader file2 = new System.IO.StreamReader("c:/process_data/data2.txt");


        //                                while ((line = file2.ReadLine()) != null)
        //                                {
        //                                    if (line.Contains("NumElements"))
        //                                    {
        //                                        string[] items = line.Split(',');
        //                                        numberofElements = Convert.ToInt16(items[1]);
        //                                        line = file2.ReadLine();

        //                                        int action = 0;

        //                                        for (int i = 0; i < numberofElements; i++)
        //                                        {
        //                                            line = file2.ReadLine();
        //                                            if (line.Contains("Xx"))
        //                                            {
        //                                                continue;
        //                                            }
        //                                            else
        //                                            {
        //                                                string[] elementItems = line.Split(',');
        //                                                if (elementItems[0].Contains("Nb"))
        //                                                {
        //                                                    action = 1;  //set to 1 to remove Nb

        //                                                    //double measuredValue = Convert.ToDouble(elementItems[2]);

        //                                                    //double upperLimit = (Properties.Settings.Default.Nb * (1.0 + (Properties.Settings.Default.UpscaleAlarmPercent / 100.0)));
        //                                                    //double lowerLimit = (Properties.Settings.Default.Nb * (1.0 - (Properties.Settings.Default.UpscaleAlarmPercent / 100.0)));

        //                                                    //if (measuredValue >= upperLimit)
        //                                                    //{
        //                                                    //    Warning("Nb value high.  Nb = " + measuredValue.ToString("F2") + " Upper Limit = " +upperLimit.ToString("F2"));
        //                                                    //    SetAlarmValue(203);
        //                                                    //    WriteAlarmToModbus(203);
        //                                                    //}
        //                                                    //else if (measuredValue <= lowerLimit)
        //                                                    //{
        //                                                    //    Warning("Nb  value low.  Nb = " + measuredValue.ToString("F2") + " Lower Limit = " +lowerLimit.ToString("F2"));
        //                                                    //    SetAlarmValue(203);
        //                                                    //    WriteAlarmToModbus(203);
        //                                                    //}




        //                                                }
        //                                                else
        //                                                {
        //                                                    action = 0;
        //                                                   }

        //                                                //if (action != 1)  
        //                                                //{
        //                                                    elementDataSymbol.Add(elementItems[0]);
        //                                                    elementData.Add(elementItems[0]);
        //                                                    elementDataAtWt.Add(elementItems[1]);
        //                                                    elementData.Add(elementItems[1]);
        //                                                    elementDataConc.Add(elementItems[2]);
        //                                                    elementData.Add(elementItems[2]);

        //                                                    elementDataUncer.Add(elementItems[3]);
        //                                                    elementData.Add(elementItems[3]);

        //                                                    double conc = Convert.ToDouble(elementDataConc.Last());
        //                                                    double concentration = 0.0;


        //                                                    //double flowForNb = 500.0;
        //                                                    if (action == 1)
        //                                                    {
        //                                                        concentration = conc * 5;

        //                                                    }
        //                                                    else
        //                                                    {
        //                                                        concentration = (conc * 1000) / flowForCalculation;

        //                                                    }

        //                                                    elementDataConV.Add(concentration.ToString());

        //                                                    elementData.Add(concentration.ToString());
        //                                                //}
        //                                            }
        //                                        }
        //                                    }
        //                                }
        //                                file2.Close();


        //                                Logger.WriteLogFile("(222) processing data3 file", "C:/temp/ManualUpscale.txt");
        //                                UpdateMaintCheckMessage("Processing file 3");

        //                                System.IO.StreamReader file3 = new System.IO.StreamReader("c:/process_data/data3.txt");
        //                                while ((line = file3.ReadLine()) != null)
        //                                {
        //                                    if (line.Contains("NumElements"))
        //                                    {
        //                                        string[] items = line.Split(',');
        //                                        numberofElements = Convert.ToInt16(items[1]);
        //                                        line = file3.ReadLine();

        //                                        for (int i = 0; i < numberofElements; i++)
        //                                        {
        //                                            line = file3.ReadLine();
        //                                            if (line.Contains("Xx"))
        //                                            {
        //                                                continue;
        //                                            }
        //                                            else
        //                                            {
        //                                                string[] elementItems = line.Split(',');

        //                                                elementDataSymbol.Add(elementItems[0]);
        //                                                elementData.Add(elementItems[0]);
        //                                                elementDataAtWt.Add(elementItems[1]);
        //                                                elementData.Add(elementItems[1]);
        //                                                elementDataConc.Add(elementItems[2]);
        //                                                elementData.Add(elementItems[2]);

        //                                                elementDataUncer.Add(elementItems[3]);
        //                                                elementData.Add(elementItems[3]);

        //                                                double conc = Convert.ToDouble(elementDataConc.Last());
        //                                                double concentration = (conc * 1000) / flowForCalculation;
        //                                                elementDataConV.Add(concentration.ToString());

        //                                                elementData.Add(concentration.ToString());
        //                                            }
        //                                        }
        //                                    }
        //                                }




        //                                file3.Close();

        //                                //bhc process  the data in the "old" dataset (i.e. make averages)
        //                                //
        //                                //


        //                                Logger.WriteLogFile( "(222) processing element data", "C:/temp/ManualUpscale.txt");

        //                                    UpdateMaintCheckMessage("Processing Element Data");

        //                                    int tempitems = elementData.Count();

        //                                    string[] array = new string[tempitems / 5];
        //                                    string[] tempa = new string[6];
        //                                    int cnt = 0;
        //                                    int arraycnt = 0;



        //                                    try
        //                                    {
        //                                        foreach (string thing in elementData)
        //                                        {

        //                                            tempa[cnt] = thing; //.Trim();
        //                                            cnt++;
        //                                            if (cnt == 5)
        //                                            {
        //                                                array[arraycnt] = tempa[0] + "," + tempa[1] + "," + tempa[2] + "," + tempa[3] + "," + tempa[4];
        //                                                arraycnt += 1;
        //                                                cnt = 0;
        //                                            }



        //                                        }

        //                                        elementDataSorted = array
        //                                            .OrderBy(arr => arr[3])
        //                                            .ThenBy(arr => arr[4])
        //                                            .ToList();

        //                                    }
        //                                    catch (Exception Ex)
        //                                    {
        //                                        Logger.WriteInternalLogFile(" Error sorting element data.  Ex = " + Ex.ToString());
        //                                    }




        //                                    DateTime now = DateTime.Now;
        //                                    string upscaleDataDirectory = "C:/Upscale_Data";  //small files
        //                                    string upscaleDataDirectoryArchive = "C:/Upscale_Data/Archive";

        //                                    string upscaleDirectory = "C:/Upscale"; //large files
        //                                    string upscaleDirectoryArchive = "C:/Upscale/Archive";

        //                                    System.IO.Directory.CreateDirectory(upscaleDirectory);
        //                                    System.IO.Directory.CreateDirectory(upscaleDirectoryArchive);

        //                                    System.IO.Directory.CreateDirectory(upscaleDataDirectory);
        //                                    System.IO.Directory.CreateDirectory(upscaleDataDirectoryArchive);


        //                                    //TextWriter tw = new StreamWriter("c:/process_data/ManualUpscale_" + now.Month.ToString() + "_" + now.Day.ToString() + "_" + now.Year.ToString() + "__" + now.Hour.ToString() + "_" + now.Minute.ToString() + "_" + now.Second.ToString() + "output.txt");
        //                                    TextWriter tw = new StreamWriter(upscaleDirectory + "/ManualUpscale_" + now.Month.ToString("D2") + "_" + now.Day.ToString("D2") + "_" + now.Year.ToString("D4") + "__" + now.Hour.ToString("D2") + "_" + now.Minute.ToString("D2") + "_" + now.Second.ToString("D2") + "_output.txt");
        //                                    TextWriter twData = new StreamWriter(upscaleDataDirectory + "/ManualUpscale_Data_" + now.Month.ToString("D2") + "_" + now.Day.ToString("D2") + "_" + now.Year.ToString("D4") + "__" + now.Hour.ToString("D2") + "_" + now.Minute.ToString("D2") + "_" + now.Second.ToString("D2") + "_output.txt");

        //                                    //int index = 0;
        //                                    string outputString = "";
        //                                    AcquisitionControl.SetFlowVolume(1000);

        //                                    //set date time in correct format (need leading zeros)
        //                                    //
        //                                    DateTime start = AcquisitionControl.GetAcquisitionOpStartDateTime();
        //                                    outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:mm:ss") + ",";   //add date time formatting string here -- for modbus
        //                                    tw.WriteLine(outputString);
        //                                    //outputString = ", Acquisition Start time = ," + start.ToString("MM/dd/yyyy HH:mm:ss") + ",";
        //                                    //twData.WriteLine(outputString);   //add the dae to the output file

        //                                    tw.WriteLine("Start of EC1: " + tempString + ",");
        //                                    tw.WriteLine("At Sym, At No, Mass, Uncertainty, Concentration");
        //                                    DateTime nowValue;
        //                                nowValue = DateTime.Now;
        //                                    outputString = ", Sample Start time = ," + nowValue.ToString("MM/dd/yyyy HH:mm:ss") + ",";
        //                                     twData.WriteLine(outputString);   //add the data to the output file


        //                                    string CrString;
        //                                    string CdString;
        //                                    string PbString;
        //                                    string NbString;
        //                                    string[] CrStringSplit;
        //                                    string[] CdStringSplit;
        //                                    string[] PbStringSplit;
        //                                    string[] NbStringSplit;
        //                                    foreach (String s in elementDataSorted)
        //                                    {

        //                                        outputString = s + ",";
        //                                        tw.WriteLine(outputString + ",");

        //                                        if (outputString.Contains("Cr"))
        //                                        {
        //                                            CrString = outputString;
        //                                            CrStringSplit = CrString.Split(',');
        //                                            twData.WriteLine(CrStringSplit[0] + "," + CrStringSplit[2]);
        //                                             AcquisitionControl.CheckUpscale("Cr", CrStringSplit[2], this);



        //                                    }
        //                                    else if (outputString.Contains("Cd"))
        //                                        {
        //                                            CdString = outputString;
        //                                            CdStringSplit = CdString.Split(',');
        //                                            twData.WriteLine(CdStringSplit[0] + "," + CdStringSplit[2]);
        //                                          AcquisitionControl.CheckUpscale("Cd", CdStringSplit[2], this);
        //                                    }
        //                                    else if (outputString.Contains("Pb"))
        //                                        {
        //                                            PbString = outputString;
        //                                            PbStringSplit = PbString.Split(',');
        //                                            twData.WriteLine(PbStringSplit[0] + "," + PbStringSplit[2]);
        //                                        AcquisitionControl.CheckUpscale("Pb", PbStringSplit[2], this);
        //                                    }
        //                                    else if( outputString.Contains("Nb"))
        //                                        {
        //                                            NbString = outputString;
        //                                            NbStringSplit = NbString.Split(',');
        //                                            twData.WriteLine(NbStringSplit[0] + "," + NbStringSplit[2]);
        //                                        AcquisitionControl.CheckUpscale("Nb", NbStringSplit[2], this);

        //                                    }


        //                                }
        //                                    twData.Close();

        //                                    outputString = ",*****,";
        //                                    tw.WriteLine(outputString);
        //                                    //add the acquisition data from when acquisition time was taken:
        //                                    //bhcop
        //                                    //DateTime start1 = AcquisitionControl.GetAcquisitionOpStartDateTime();
        //                                    //outputString = ", Acquisition Start Time = ," + start.ToString();
        //                                    //tw.WriteLine(outputString);
        //                                    outputString = ", Acquisition Operating Parameters ," + start.ToString("MM/dd/yyyy HH:mm:ss") + ",";
        //                                    tw.WriteLine(outputString);
        //                                    //double ambientTemp = AcquisitionControl.GetAmbientTemp();
        //                                    //outputString = ", Ambient Temp (avg) = ," + ambientTemp.ToString("F2") + ",";
        //                                    //tw.WriteLine(outputString);
        //                                    //double sampleTemp = AcquisitionControl.GetSampleTemp();
        //                                    //outputString = ", Sample Temp (avg) = ," + sampleTemp.ToString("F2") + ",";
        //                                    //tw.WriteLine(outputString);
        //                                    //double bP = AcquisitionControl.GetAtmPress();
        //                                    //outputString = ", BP (avg) = ," + bP.ToString("F2") + ",";
        //                                    //tw.WriteLine(outputString);
        //                                    //double tapePress = AcquisitionControl.GetTapePress();
        //                                    //outputString = ", Tape Pressure (avg) = ," + tapePress.ToString("F2") + ",";
        //                                    //tw.WriteLine(outputString);
        //                                    //double flow25 = AcquisitionControl.GetFlow25();
        //                                    //outputString = ", Flow 25 (avg) = ," + flow25.ToString("F2") + ",";
        //                                    //tw.WriteLine(outputString);
        //                                    //double flowAct = AcquisitionControl.GetFlowAct();
        //                                    //outputString = ", Flow Act (avg) = ," + flowAct.ToString("F2") + ",";
        //                                    //tw.WriteLine(outputString);

        //                                    //double flowStd = AcquisitionControl.GetFlowStd();
        //                                    //outputString = ", Flow Std (avg) = ," + flowStd.ToString("F2") + ",";
        //                                    //tw.WriteLine(outputString);

        //                                    //double volume = AcquisitionControl.GetVolume();
        //                                    //outputString = ", Volume = ," + flowValue.ToString("F2") + ",";
        //                                    //tw.WriteLine(outputString);

        //                                    //double tubetemp = AcquisitionControl.GetTubeTemp();
        //                                    //outputString = ", Tube Temp (avg) = ," + tubetemp.ToString("F2") + ",";
        //                                    //tw.WriteLine(outputString);

        //                                    //double enclosureTemp = AcquisitionControl.GetEnclosureTemp();
        //                                    //outputString = ", Enclosure Temp (avg) = ," + enclosureTemp.ToString("F2") + ",";
        //                                    //tw.WriteLine(outputString);

        //                                    //double filamentMon = AcquisitionControl.GetFilamentMonitor();
        //                                    //outputString = ", Filament Monitor (avg) = ," + filamentMon.ToString("F2") + ",";
        //                                    //tw.WriteLine(outputString);

        //                                    //double sddTemp = AcquisitionControl.GetSDDTemp();
        //                                    //outputString = ", SDD Temp (avg) = ," + sddTemp.ToString("F2") + ",";
        //                                    //tw.WriteLine(outputString);

        //                                    //double ddpTemp = AcquisitionControl.GetDDPTemp();
        //                                    //outputString = ", DDP Temp (avg) = ," + ddpTemp.ToString("F2") + ",";
        //                                    //tw.WriteLine(outputString);

        //                                    //double relativeHumidity = AcquisitionControl.GetRelativeHumidity();
        //                                    //outputString = ", Relative Humidity (avg) = ," + relativeHumidity.ToString("F2") + ",";
        //                                    //tw.WriteLine(outputString);


        //                                    //double windAvg = 0;
        //                                    //double dirAvg = 0;
        //                                    //AcquisitionControl.GetWindSpeedandDirectionAvg(out windAvg, out dirAvg);

        //                                    //outputString = ", Wind Speed (avg) = ," + windAvg.ToString("F2") + ",";
        //                                    //tw.WriteLine(outputString);

        //                                    //outputString = ", Wind Direction (avg) = ," + dirAvg.ToString("F2") + ",";
        //                                    //tw.WriteLine(outputString);

        //                                    int sampleTime = Properties.Settings.Default.SampleTime;
        //                                    outputString = ", Sample Time (min) = ," + sampleTime.ToString() + ",";
        //                                    tw.WriteLine(outputString);

        //                                    tw.Close(); // must be closed before modbus can open  
        //                                    Logger.WriteLogFile("Done writing upscale process data file.", "C:/temp/ManualUpscale.txt");

        //                                    //update modbus registers/
        //                                    //string path = @"C:\Process_Data";  //normal process data is in process data
        //                                    string path = @"C:\Upscale";  //upscale has all the data from upscale time
        //                                                                  //upscale data has the three values



        //                                    string processFile = nModbusOperations.findProcessFile(path);

        //                                    List<string> conc_and_dateTime = new List<string>();
        //                                    List<string> instrumentData = new List<string>();
        //                                    List<string> conc_and_dateTime_No_Nb = new List<string>();

        //                                    nModbusOperations.getRawData(processFile, out conc_and_dateTime, out instrumentData, out conc_and_dateTime_No_Nb);

        //                                    ushort[] modbusDataArray = nModbusOperations.createModbusArray(conc_and_dateTime);
        //                                    ushort[] modbusDataArrayNoNb = nModbusOperations.createModbusArray(conc_and_dateTime_No_Nb);


        //                                    ushort[] dateTime = nModbusOperations.modbusDateTimeArray(modbusDataArray);
        //                                    ushort[] dateTimeNoNb = nModbusOperations.modbusDateTimeArray(modbusDataArrayNoNb);

        //                                    ushort[] telemetryData = nModbusOperations.ModbusTelemetryArray(instrumentData);

        //                                    ushort[] atomicNumbers = nModbusOperations.atomicNumberArray(modbusDataArray);
        //                                    ushort[] atomicNumbersNoNb = nModbusOperations.atomicNumberArray(modbusDataArrayNoNb);

        //                                    ushort[] concArray = nModbusOperations.modbusConcArray(modbusDataArray);
        //                                    ushort[] concArrayNoNb = nModbusOperations.modbusConcArray(modbusDataArrayNoNb);

        //                                    ushort[] uncArray = nModbusOperations.modbusUncArray(modbusDataArray);
        //                                    ushort[] uncArrayNoNb = nModbusOperations.modbusUncArray(modbusDataArrayNoNb);

        //                                DataStore xactHoldingRegisters = AcquisitionControl.getDataStore();


        //                                if (/*Properties.Settings.Default.OutputPin4 == false &&*/ Properties.Settings.Default.OutputPin7 == false)
        //                                {
        //                                    nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, atomicNumbers, 100);
        //                                    nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, concArray, 200);
        //                                    nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, uncArray, 200 + concArray.Length);
        //                                    //nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, uncArray, 400);


        //                                    nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, dateTime, 701);
        //                                    nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, telemetryData, 701 + dateTime.Length + 1);

        //                                    ushort[] oneValue = new ushort[1] { 1 };
        //                                    Logger.WriteLogFile( "Updated Modbus data registers.  Addr 700 = 1.", "C:/temp/ManualUpscale.txt");
        //                                    nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, oneValue, 700); // signals registers have been updated
        //                                    BackgroundManager.m_oWorkerFiveMinute.RunWorkerAsync();

        //                                    AcquisitionControl.setDataStore(xactHoldingRegisters);

        //                                }

        //                                    //  ****************************************
        //                                    //update adapt database
        //                                    ///
        //                                    /// 
        //                                    //AdaptDB db = new AdaptDB();
        //                                    //string db_path = "C:\\XactControl\\Adapt\\adapt.db";  //works!
        //                                    //SQLiteConnection dbConnection;
        //                                    //db.DBConnection(db_path, out dbConnection);
        //                                    //db.updateDateTime(dbConnection, conc_and_dateTime, instrumentData);
        //                                    //db.updateXactData(dbConnection, conc_and_dateTime, instrumentData);
        //                                    //dbConnection.Close();
        //                                    //  ****************************************



        //                                    AcquisitionControl.SetCounter(0);
        //                                    AcquisitionControl.SetState(224);
        //                                }
        //                                        catch (Exception Ex)
        //                                        {
        //                                            Logger.WriteInternalLogFile("Exception in state machine (222).  Ex = " + Ex.ToString());
        //                                            UpdateMaintCheckMessage("Error Manual Upscale data  See ErrorFile.txt");
        //                                            //stop acquisition thread

        //                                             //stop pump thread
        //                                            HaltUpscale("Error in Manual Upscale.  Ex=" + Ex.ToString());   

        //                                            //ramp xrays to zero
        //                                            //int returnVal;

        //                                            ////read presentV (actual 'kV') from NI
        //                                            //double presentV = 0.0;
        //                                            //presentV = readInputVoltage;
        //                                            //presentV = presentV * 50.0 / 10.0;

        //                                            ////ActualV.Text = presentV.ToString();
        //                                            //presentV = Math.Round(presentV, 2, MidpointRounding.AwayFromZero);


        //                                            ////read presentI (actual i) from NI
        //                                            //double presentI = 0.0;
        //                                            //presentI = readInputCurrent;
        //                                            //presentI = presentI * 2000.0 / 10.0;
        //                                            //presentI = Math.Round(presentI, 2, MidpointRounding.AwayFromZero);


        //                                            //if (presentV > 5 && presentI > 10)
        //                                            //{
        //                                            //    Logger.WriteLogFile("c:/temp/ManualUpscale.txt", "Ramp down xrays...");

        //                                            //    returnVal = AcquisitionControl.RampXrays(presentV, presentI, 0.0, 0.0, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
        //                                            //    Thread.Sleep(6000);
        //                                            //    //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

        //                                            //    AcquisitionControl.InterlockOpen(this);
        //                                            //    //InterlockOpen();

        //                                            //    //if (mtbInterlockStatus.InvokeRequired)
        //                                            //    //{
        //                                            //    //    mtbInterlockStatus.Invoke(new MethodInvoker(delegate { mtbInterlockStatus.Text = "O"; }));

        //                                            //    //}
        //                                            //    //else
        //                                            //    //{
        //                                            //    //    mtbInterlockStatus.Text = "OPEN";
        //                                            //    //}

        //                                            //    Thread.Sleep(1000);

        //                                            //}

        //                                        }
        //                                    }

        //                                }
        //                                break;

        //                case 224:  
        //                    {

        //                        Logger.WriteLogFile( "Move DR home (224)", "c:/temp/ManualUpscale.txt");
        //                        UpdateMaintCheckMessage("Move Dynamic Rod Home.");

        //                        int returnVal = AcquisitionControl.MoveRodHome(SerialManager, this);
        //                        Logger.WriteLogFile( "Move DR home (224) returned : " + returnVal.ToString(),"c:/temp/ManualUpscale.txt");
        //                        if (returnVal == PASS)
        //                        {
        //                            AcquisitionControl.SetCounter(0);
        //                            AcquisitionControl.SetState(226);

        //                        }
        //                        else
        //                        {
        //                            AcquisitionControl.SetCounter((AcquisitionControl.GetCounter() + 1));
        //                            if (AcquisitionControl.GetCounter() >= 3)
        //                            {
        //                                HaltUpscale("Error:  Move DR home failed");
        //                            }
        //                            else
        //                            {  //retry
        //                                AcquisitionControl.SetState(224);
        //                                Logger.WriteErrorFile("Error:  Manual Upscale (224) Move Dynamic Rod home.");
        //                                UpdateMaintCheckMessage("Error:  Move Dynamic Rod Home");
        //                            }
        //                        }
        //                        break;

        //                }


        //                case 226:  //case 32:
        //                {
        //                        int retVal = ProcessUpscaleFiles();
        //                        if (retVal == PASS)
        //                        {
        //                            UpdateMaintCheckMessage("Upscale Done  See System Tab");
        //                            //see QA for display data

        //                            Logger.WriteLogFile("Manual Upscale Done.", "c:/temp/ManualUpscale.txt");
        //                            try
        //                            {
        //                                if (BackgroundManager.m_oWorkerUpscale.IsBusy)
        //                                {
        //                                    BackgroundManager.m_oWorkerUpscale.CancelAsync();
        //                                }
        //                            }
        //                            catch
        //                            {

        //                            }
        //                            //UpdateMaintCheckMessage();
        //                        }
        //                        else
        //                        {
        //                            UpdateMaintCheckMessage("Upscale Done  Error displaying values");
        //                            Logger.WriteLogFile("Manual Upscale Done  Error displaying data.", "c:/temp/ManualUpscale.txt" );
        //                            if (BackgroundManager.m_oWorkerUpscale.IsBusy)
        //                            {
        //                                BackgroundManager.m_oWorkerUpscale.CancelAsync();
        //                            }
        //                        }
        //                }
        //                break;
        //                }

        //                    }
        //                    catch (Exception Ex)
        //                    {
        //                        AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

        //                        Logger.WriteInternalLogFile("Error in Manual Upscale state machine logic.  ("+AcquisitionControl.GetState().ToString()+")  + Ex = " + Ex.ToString());
        //                    }
        //                    finally
        //                    {
        //                        AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

        //                        Logger.WriteLogFile("Done with Upscale state task. ("+AcquisitionControl.GetState().ToString()+")", "c:/temp/ManualUpscale.txt"  );
        //                        Monitor.Exit(lockUpscaleObj);
        //                    }
        //                }
        //                else
        //                {
        //        UpscaleLockCounter++;
        //        //lock not obtained for this timer.

        //        AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
        //        if (UpscaleLockCounter > 50)
        //        {

        //            Logger.WriteLogFile("lock not obtained for Upscale timer (" + AcquisitionControl.GetState().ToString() + ")", "c:/temp/ManualUpscale.txt");
        //        }
        //                }

        //}







        //********************************** end upscale state machine ************************************


        /// <summary>
        /// Prepare most recent five files for display on QA page
        /// </summary>
        private int ProcessUpscaleFiles()  
        {
            try
            {
                System.Linq.IOrderedEnumerable<string> fileItems = Directory.GetFiles(@"C:\Upscale_Data", "*.txt").OrderByDescending(d => new FileInfo(d).CreationTime);
                int count = 0;
                int lineCounter = 0;
                //int ix;
                foreach (string item in fileItems)
                {
                    count++;
                    //ix = 0;
                    if (count > fileItems.Count()  || count >4)  //only fill arrays to the 4 most recent upscale files
                    {
                        break;
  
                    }


                    //open item
                    //read the data
                    //present it
                    string line;
                    string dateLine;
                    string NbLine;
                    string CrLine;
                    string CdLine;
                    string PbLine;
                    string Nb = "";
                    string date="";
                    string Cr="";
                    string Cd="";
                    string Pb="";

                    System.IO.StreamReader file = new System.IO.StreamReader(item);

                    while ((line = file.ReadLine()) != null)
                    {
                        lineCounter++;
                        if (lineCounter == 1)
                        {
                            dateLine = line;
                            string[] parts = dateLine.Split(',');
                            //some files do not contain the date on the top line:
                            if (parts.Count()>=3)
                            {
                                date = parts[2];
                            }
                            else
                            {
                                date = "";
                                continue;
                            }

                        }

                        //else
                        //{
                            if (line.Contains("Nb"))
                            {
                                NbLine = line;
                                string[] parts = NbLine.Split(',');
                                Nb = parts[1];
                            }

                            else if(line.Contains("Cr" ))
                            {
                                CrLine = line;
                                string[] parts = CrLine.Split(',');
                                Cr = parts[1];
                            }
                            else if (line.Contains("Cd"))
                            {
                                CdLine = line;
                                string[] parts = CdLine.Split(',');
                                Cd = parts[1];
                            }
                            else if (line.Contains("Pb"))
                            {
                                PbLine = line;
                                string[] parts = PbLine.Split(',');
                                Pb = parts[1];
                            }
                        //}
                    }
                    //UpdateUpscaleMessage()
                    UpdateUpscaleMessage(date, Cr, Cd, Pb, Nb,count);  //displays 4
                    lineCounter = 0;
                    file.Close();




                }
                if (count >= fileItems.Count() || count>4)  
                {
                    return PASS;
                }
                else
                {
                    return FAIL;
                }
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error in Display Manual Upscale Data   Ex = "+Ex.ToString());
                return FAIL;
            }
        }






        /// <summary>
        /// Acquisition logic controller 
        /// 
        /// Some acq tasks take longer than 1 second to complete
        /// So a locking mechanism is employed to prevent the timer from launching 
        /// another duplicate task on another thread
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <param name="e"></param>
        private void onAcqTimedEvent(object source, ElapsedEventArgs e)
        {


            // only execute the code within this method if we are able to
            // a lock. This will ensure that any Timer firings will be
            // ignored that occur while we're already doing work (OnTimer) 


            if (Monitor.TryEnter(lockObj))
            {

                try
                {
                    AcquisitionLockCounter = 0;    
                    AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                    // do work here

                    //fired every one second....
                    string[] acqValues = new string[10];

                    AcquisitionControl.IncTimerCounter();

                    BackgroundManager.m_oWorkerAcq.ReportProgress(AcquisitionControl.GetState(), acqValues);

                    //       public static DateTime AcquireStarted;
                    //DateTime calculateElapsed;
                    //= DateTime.Now;   //start now if less than 15min

                    int curState = AcquisitionControl.GetState();
                    double vol;

                    switch (curState)
                    {
                        case 8:
                            {


                                /*
 // start
                                
                                string path = @"C:\Process_Data";
                                string processFile = nModbusOperations.findProcessFile(path);

                                List<string> conc_and_dateTime = new List<string>();
                                List<string> instrumentData = new List<string>();
                                List<string> conc_and_dateTime_No_Nb = new List<string>();

                                nModbusOperations.getRawData(processFile, out conc_and_dateTime, out instrumentData, out conc_and_dateTime_No_Nb);

                                ushort[] modbusDataArray = nModbusOperations.createModbusArray(conc_and_dateTime);
                                ushort[] modbusDataArrayNoNb = nModbusOperations.createModbusArray(conc_and_dateTime_No_Nb);

                                ushort[] dateTime = nModbusOperations.modbusDateTimeArray(modbusDataArray);
                                ushort[] dateTimeNoNb = nModbusOperations.modbusDateTimeArray(modbusDataArrayNoNb);
                                ushort[] telemetryData = nModbusOperations.ModbusTelemetryArray(instrumentData);
                                ushort[] atomicNumbers = nModbusOperations.atomicNumberArray(modbusDataArray);
                                ushort[] atomicNumbersNoNb = nModbusOperations.atomicNumberArray(modbusDataArrayNoNb);
                                ushort[] concArray = nModbusOperations.modbusConcArray(modbusDataArray);
                                ushort[] concArrayNoNb = nModbusOperations.modbusConcArray(modbusDataArrayNoNb);
                                ushort[] uncArray = nModbusOperations.modbusUncArray(modbusDataArray);
                                ushort[] uncArrayNoNb = nModbusOperations.modbusUncArray(modbusDataArrayNoNb);

                                DataStore xactHoldingRegisters = AcquisitionControl.getDataStore();
                                //upate modbus registers//

                                if ( Properties.Settings.Default.OutputPin7 == false)
                                {
                                    try
                                    {
                                        nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, atomicNumbers, 100);
                                        nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, concArray, 200);
                                        nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, uncArray, 200 + concArray.Length);
                                        //nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, uncArray, 400);

                                        nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, dateTime, 701);
                                        nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, telemetryData, 701 + dateTime.Length + 1);

                                        ushort[] oneValue = new ushort[1] { 1 };
                                        Logger.WriteLogFile("Signal modbus data. Addr 700 = 1");
                                        nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, oneValue, 700); // signals registers have been updated
                                        AcquisitionControl.setDataStore(xactHoldingRegisters);
                                        BackgroundManager.m_oWorkerFiveMinute.RunWorkerAsync();  //will clear addr 700 in 5 min

                                    }
                                    catch (Exception Ex)
                                    {
                                        Logger.WriteErrorFile("Error writing Modbus data.  Ex = " + Ex.ToString());
                                    }
                                }
                                //
                                //update adapt database
                                //
                                // do NOT do this for upscale or ecal:  add check for runState 1.0.0.41
                                if (AcquisitionControl.GetUpscale() == 0 && AcquisitionControl.GetECAL() == 0 && runState == 1)  //AcquisitionControl.SetUpscale
                                {
                                    try
                                    {
                                        //if (sampleTime != 5)  //an update to the adapt web app is necessary for adapt data in 5 min mode
                                        //{
                                        AdaptDB db = new AdaptDB();
                                        //string db_path = @"‪C:\XactControl\Adapt\adapt.db";  //throws exception at attempt to open the db`
                                        string db_path = "C:\\XactControl\\Adapt\\adapt.db";  //works!

                                        //C:\XactControl\Adapt
                                        SQLiteConnection dbConnection;
                                        db.DBConnection(db_path, out dbConnection);
                                        db.updateDateTime(dbConnection, conc_and_dateTime_No_Nb, instrumentData);
                                        db.updateXactData(dbConnection, conc_and_dateTime_No_Nb, instrumentData);
                                        db.updateInstrumentStatusData(dbConnection, conc_and_dateTime_No_Nb, instrumentData);
                                        db.updateWindData(dbConnection, conc_and_dateTime_No_Nb, instrumentData);
                                        dbConnection.Close();
                                        //}
                                        //else
                                        //{
                                        //    Logger.WriteInternalLogFile("Five minute data not logged to adapt db.");
                                        //
                                        //}
                                    }
                                    catch (Exception Ex)
                                    {
                                        Logger.WriteInternalLogFile("Error writing adapt db.  Ex = " + Ex.ToString());
                                    }
                                }

                                


                                */
                                // end



                                if (AcquisitionControl.GetCounter() == 0)
                                {
                                    int returnV = FAIL;
                                    returnV = CleanProcessData();
                                    if (returnV == FAIL)
                                    {
                                        Logger.WriteInternalLogFile("Unable to clean output files.");
                                    }
                                    else
                                    {
                                        Logger.WriteLogFile("state = 8.  Cleaned process data1,2,3,4 files.");
                                    }

                                    Logger.WriteLogFile("state = 08.  Intialize System.");
                                    UpdateOperationMessage("Initializing system");
                                    Thread.Sleep(1000);

                                    //init active energy condition
                                    bool ec1 = false;
                                    bool ec2 = false;
                                    bool ec3 = false;
                                    bool ec4 = false;

                                    SetActiveNormalECs();

                                    GetActiveNormalECs(out ec1, out ec2, out ec3, out ec4);

                                    if (ec1 == true)
                                    {
                                        AcquisitionControl.SetEnergyCondition(1);
                                        UpdateOperationMessage("Initial Energy Condition = 1");
                                    }
                                    else if (ec2 == true)
                                    {
                                        AcquisitionControl.SetEnergyCondition(2);
                                        UpdateOperationMessage("Initial Energy Condition = 2");
                                    }
                                    else if (ec3 == true)
                                    {
                                        AcquisitionControl.SetEnergyCondition(3);
                                        UpdateOperationMessage("Initial Energy Condition = 3");
                                    }
                                    else if (ec4 == true)
                                    {
                                        AcquisitionControl.SetEnergyCondition(4);
                                        UpdateOperationMessage("Initial Energy Condition = 4");
                                    }

                                }







                                Logger.WriteLogFile("state = 08.  Intialize System, check detector connection.");
                                UpdateOperationMessage("Checking detector connection");

                                int retVal = FAIL;
                                int count = 0;
                                do
                                {
                                    retVal = AcquisitionControl.CheckDetectorConnection();
                                    count += 1;
                                } while (count < 3 && retVal == FAIL);
                                if (retVal == FAIL)
                                {
                                    Halt("Unable to connect to detector.");
                                    AcquisitionControl.SetAlarmValue(110);
                                    WriteAlarmToModbus(110);

                                }


                                ///*------------------------------------------------------*/
                                // normal two lines
                                AcquisitionControl.SetCounter(0);
                                AcquisitionControl.SetState(9);

                                //AcquisitionControl.SetCounter(0);
                                //AcquisitionControl.SetState(31);



                            }

                            break;

                        case 9:

                            { 
                                Logger.WriteLogFile("state = 09.  Stop Sample Pump.");          // new way
                                                                                                //Logger.WriteLogFile("c:/temp/acquisition.txt", "state = 09.");   // old way

                                //tube seasoning here

                                //bhc debug comment out for test, or build with TURNOFF_TUBESEASONING defined
#if TURNON_TUBESEASONING
                                Logger.WriteLogFile("state = 9. Start Tube Seasoning.");
                                UpdateOperationMessage("Running tube seasoning");
                                BackgroundManager.m_oWorkerTubeSeasoning.RunWorkerAsync();
#endif

                                //bhc debug


                                UpdateOperationMessage("Stopping sample pump");
                                Logger.WriteLogFile("state = 09.  Stop pump. Set flow volume to zero.");

                                Logger.WriteLogFile("Clearing operating data 1 and 2.");
                                AcquisitionControl.SetFlowVolume(0);

                                AcquisitionControl.SetDataSet(2);
                                AcquisitionControl.ClrOperatingData();


                                AcquisitionControl.SetDataSet(1);
                                AcquisitionControl.ClrOperatingData();  //data1 will now load with the timer and the pump



                                if (/*Properties.Settings.Default.OutputPin4==true ||*/ Properties.Settings.Default.OutputPin7 == true)
                                {
                                    Logger.WriteLogFile("Clearing pin 7.");
                                    //if activated default the written value and the value in the data output section


                                    AcquisitionControl.SetDataSet(2);
                                    AcquisitionControl.SetPin7OutputStateDataset(false);
                                    AcquisitionControl.SetDataSet(1);
                                    AcquisitionControl.SetPin7OutputStateDataset(true);
                                    AcquisitionControl.SetControlLines(SerialIOControlLinesManager, true, false);
                                }

                                vol = 0.0;// AcquisitionControl.GetVolume();



                                int returnVal09 = AcquisitionControl.PumpOff(m_oWorkerPump);
                                if (returnVal09 == PASS)
                                {
                                    SetModbusPumpActive(0);
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(10);
                                }
                                else
                                {
                                    AcquisitionControl.SetCounter(AcquisitionControl.GetCounter() + 1);
                                    if (AcquisitionControl.GetCounter() >= 3)
                                    {
                                        AcquisitionControl.SetAlarmValue(105);
                                        this.WriteAlarmToModbus(105);
                                        Halt("(9) Unable to Stop Pump.");

                                    }
                                    else
                                    {
                                        UpdateOperationMessage("Error:  Unable to stop pump. Retry = " + AcquisitionControl.GetCounter().ToString());
                                        //AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(9);
                                        Logger.WriteErrorFile("Error: (9) Unable to stop pump.  Retry = " + AcquisitionControl.GetCounter().ToString());
                                    }

                                }
                            }
                            break;

                   
                        case 10:  //normal run
                            {

                                Logger.WriteLogFile(   "state = 10.  Move DR Home.");

                                UpdateOperationMessage("Move Dynamic Rod Home");


                                int returnVal10 = AcquisitionControl.MoveRodHome(SerialManager, this);
                                Logger.WriteLogFile(   "move DR home returned: " + returnVal10.ToString());
                                if (returnVal10 == PASS)
                                {
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(11);

                                }
                                else
                                {
                                    AcquisitionControl.SetCounter((AcquisitionControl.GetCounter() + 1));
                                    if (AcquisitionControl.GetCounter() >= 3)
                                    {
                                        AcquisitionControl.SetAlarmValue(107);
                                        this.WriteAlarmToModbus(107);
                                        Halt("Error:  Move DR home failed");
                                    }
                                    else
                                    {  //retry
                                        AcquisitionControl.SetState(10);
                                        Logger.WriteErrorFile("Error:  (10) unable to move Dynamic Rod home.");
                                        Logger.WriteLogFile("Error:  (10) unable to move Dynamic Rod home.");
                                        UpdateOperationMessage("Error:  Move Dynamic Rod Home");

                                    }
                                }
                                break;

                            }
                        case 11:
                            {
                                //#TODO FEC get active ec's... here

                                UpdateOperationMessage("Move Filter Wheel Home");
                                Logger.WriteLogFile(   "start state = 11.  Move FW home.");

                                returnVal11 = AcquisitionControl.MoveFWHome(SerialManager, this);
                                if (returnVal11 == PASS)
                                {

                                    Logger.WriteLogFile(   "state = 11.  Move FW home:  PASS.");

                                    //check for a position of zero
                                    int position = 33;

                                    //int returnVal27 = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);
                                    position = AcquisitionControl.PollMotorPosition(1, SerialManager);

                                    Logger.WriteLogFile(   "EC " + "init" + " (destination) motor position, after home = " + position.ToString());

                                    if (position == 0)
                                    {
                                        Logger.WriteLogFile(   "EC " + "init" + " (destination) motor position, after home:  PASS");
                                        UpdateOperationMessage("Filter Wheel Home.  Position = 0");


                                        AcquisitionControl.SetEnergyConditionPrevious(0);
                                        //AcquisitionControl.SetEnergyCondition(1);
                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(12);
                                    }
                                    else
                                    {
                                        AcquisitionControl.SetCounter((AcquisitionControl.GetCounter() + 1));
                                        if (AcquisitionControl.GetCounter() >= 3)
                                        {
                                            AcquisitionControl.SetAlarmValue(106);
                                            this.WriteAlarmToModbus(106);

                                            Halt("Error moving FW home  (pos=" + position.ToString() + ")");
                                        }
                                        else
                                        {
                                            AcquisitionControl.SetState(11);
                                            UpdateOperationMessage("Error:  Move Filter Wheel Home (" + position.ToString() + ")");
                                            Logger.WriteErrorFile("Error:  (11)  Move Filter Wheel Home.  Position = " + position.ToString());
                                            Logger.WriteLogFile("Error:  (11)  Move Filter Wheel Home.  Position = " + position.ToString());
                                        }
                                    }




                                }
                                else
                                {
                                    AcquisitionControl.SetCounter((AcquisitionControl.GetCounter() + 1));
                                    if (AcquisitionControl.GetCounter() >= 3)
                                    {
                                        AcquisitionControl.SetAlarmValue(106);
                                        this.WriteAlarmToModbus(106);

                                        Halt("Unable to move FW Home.  System Stop.");

                                    }
                                    else
                                    {
                                        AcquisitionControl.SetState(11);
                                        UpdateOperationMessage("Unable to move FW Home.  Retrying");
                                        Logger.WriteErrorFile("Error:  (11) Unable to move Filter Wheel home.");
                                        Logger.WriteLogFile("Error:  (11) Unable to move Filter Wheel home.");
                                    }
                                }
                                break;

                            }
                        case 12:
                            {

                                Logger.WriteLogFile(   "state = 12.  Move Nozzle Down.");

                                UpdateOperationMessage("Moving Nozzle Down");

                                int returnVal12 = AcquisitionControl.NozzleDown(SerialManager, this);
                                if (returnVal12 == PASS)
                                {
                                    AcquisitionControl.SetState(13);
                                    AcquisitionControl.SetCounter(0);
                                }
                                else
                                {
                                    AcquisitionControl.SetCounter(AcquisitionControl.GetCounter() + 1);
                                    if (AcquisitionControl.GetCounter() >= 3)
                                    {
                                        AcquisitionControl.SetAlarmValue(108);
                                        this.WriteAlarmToModbus(108);

                                        Halt("Error:  Move Nozzle Down");
                                        UpdateNozzleMessage("Unable to move nozzle down.");
                                    }
                                    else
                                    {
                                        UpdateNozzleMessage("Unable to move Nozzle Down. Retry.");
                                        UpdateOperationMessage("Unable to move Nozzle down.  Retrying");
                                        Logger.WriteErrorFile("Error: Unable to move Nozzle down.  Retry.");
                                        Logger.WriteLogFile("Error: Unable to move Nozzle down.  Retry.");
                                    }
                                }


                                break;
                            }
                        case 13:
                            {
                                Logger.WriteLogFile(   "state = 13.  Move Tape Full.");

                                UpdateOperationMessage("Moving Tape (Full)");


                                int returnVal13 = AcquisitionControl.MoveTapeFull(SerialManager, this);
                                if (returnVal13 == PASS)
                                {
                                    UpdateOperationMessage("Moving Tape (Pass)");

                                    AcquisitionControl.SetState(14);
                                    AcquisitionControl.SetCounter(0);
                                }
                                else
                                {

                                    AcquisitionControl.SetCounter(AcquisitionControl.GetCounter() + 1);
                                    if (AcquisitionControl.GetCounter() >= 2)
                                    {

                                        if (returnVal13 == FAIL_NOZZLE)
                                        {
                                            AcquisitionControl.SetAlarmValue(108);
                                            this.WriteAlarmToModbus(108);

                                            Halt("Error: Nozzle Limits. In function: Move Tape Full");

                                        }
                                        else
                                        {
                                            AcquisitionControl.SetAlarmValue(104);
                                            this.WriteAlarmToModbus(104);

                                            Halt("Error:  Move Tape Full");
                                        }
                                    }
                                    else
                                    {
                                        UpdateOperationMessage("Unable to move Tape Full. Retrying");
                                        Logger.WriteErrorFile("Error move tape full. Retry.");
                                        Logger.WriteLogFile("Error move tape full. Retry.");
                                    }



                                }

                                //todo: get tape move counts
                                //}
                                break;
                            }
                        case 14:
                            {

                                Logger.WriteLogFile(   "state = 14. Move Nozzle Up.");
                                UpdateOperationMessage("Moving Nozzle Up");


                                int returnVal14 = AcquisitionControl.NozzleUp(SerialManager, this);
                                if (returnVal14 == PASS)
                                {

                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(15);
                                }
                                else
                                {
                                    AcquisitionControl.SetCounter(AcquisitionControl.GetCounter() + 1);
                                    if (AcquisitionControl.GetCounter() >= 3)
                                    {
                                        AcquisitionControl.SetAlarmValue(108);
                                        this.WriteAlarmToModbus(108);

                                        Halt("Error:  Move Nozzle Up");
                                    }
                                    else
                                    {
                                        UpdateOperationMessage("Unable to move Nozzle Up. Retrying");
                                        UpdateNozzleMessage("Unable to move Nozzle Up.  Retrying");

                                        Logger.WriteErrorFile("Error: Unable to move Nozzle Up. Retry.");
                                        Logger.WriteLogFile("Error: Unable to move Nozzle Up. Retry.");
                                    }

                                }

                                break;
                            }

                        case 15:
                            {
                                Logger.WriteLogFile(   "state = 15. Prepare to Start.");
                                // other initialization logic here

                                AcquisitionControl.SetCounter(0);
                                AcquisitionControl.SetState(16);
                            }

                            break;

                        case 16:
                            {


                                if (AcquisitionControl.GetUpscale() == 2)
                                {
                                    AcquisitionControl.SetUpscale(0);
                                    UpdateOperationMessage("Upscale completed.  Move DR Home");

                                    Logger.WriteLogFile(   "state = 16.  Upscale completed.  Move RD Home.");

                                    int retVal;
                                    int drHomeCount = 0;

                                    do
                                    {
                                        retVal = AcquisitionControl.MoveRodHome(SerialManager, this);
                                        drHomeCount += 1;
                                    } while (retVal == FAIL && drHomeCount < 3);
                                    if (retVal == FAIL)
                                    {
                                        AcquisitionControl.SetAlarmValue(107);
                                        this.WriteAlarmToModbus(107);

                                        Halt("Error: Move DR Home.");
                                    }

                                    var AcqStartTime = DateTime.Now;


                                    TimeCalc(16, AcqStartTime, 30);

                                }
                                else
                                {

                                    DateTime AcquisitionStartTime = AcquisitionControl.GetAcquireStartTime();  //assumes you end at sampletime :00:00
                                    var TimeRemaining = AcquisitionStartTime - System.DateTime.Now;

                                    string msg = "Waiting to Start. Time remaining: " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2");
                                    UpdateOperationMessage(msg);

                                    if (TimeRemaining.Seconds % 10 == 0)
                                    {
                                        Logger.WriteLogFile(msg);
                                    }


                                    if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
                                    {
                                        UpdateOperationMessage("Starting sample");
                                        Thread.Sleep(1000);

                                        Logger.WriteLogFile(   "state = 16.  Starting Sample");


                                        Logger.WriteLogFile(   "state = 16.  setting acq start time " + AcquisitionStartTime.ToString());

                                        AcquisitionControl.SetAcquireStartTime(DateTime.Now);  //this removes any stray seconds from the acquisition start time.

                                        TimeCalc(16, AcquisitionStartTime);

                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(17);

                                    }
                                }

                                break;
                            }
                        case 17:
                            {
                                //perform other sample init here:
                                Logger.WriteLogFile("state = 17.  Sample initialization.");
                                AcquisitionControl.SetDataSet(1);   //bhcop default the dataset to 1
                                AcquisitionControl.SetState(18);
                            }
                            break;

                        case 18:
                            {

                                Logger.WriteLogFile(   "state = 18. Sample flow volume set to zero.");
                                AcquisitionControl.SetFlowVolume(0);
                                UpdateOperationMessage("Start Pump");

                                Logger.WriteLogFile(   "state = 18.  START PUMP");
                                Logger.WriteLogFile(   "@18 clear data set = " + AcquisitionControl.GetDataSet().ToString());
                                AcquisitionControl.ClrOperatingData(); //clear at the start of acquisition

                                AcquisitionControl.SetAcquisitionOpStartDateTime();

                                if (AcquisitionControl.GetCounter() == 0)
                                {
                                    UpdateOperationMessage("Starting pump");
                                }

                                int returnVal18 = AcquisitionControl.PumpOn(m_oWorkerPump);  //this will begin summing.
                                if (returnVal18 == PASS)
                                {
                                    //pump is on
                                    SetModbusPumpActive(1);
                                    SetModbusPumpActiveTime();

                                    //bhcop -- save the start time here;

                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(19);

                                }
                                else
                                {
                                    int tries = AcquisitionControl.GetCounter();
                                    tries += 1;
                                    if (tries >= 3)
                                    {
                                        AcquisitionControl.SetAlarmValue(105);
                                        this.WriteAlarmToModbus(105);

                                        Halt("Error:  Unable to start pump.");
                                    }
                                    else
                                    {
                                        AcquisitionControl.SetCounter(tries);
                                        AcquisitionControl.SetState(18);
                                        Logger.WriteErrorFile("Error (18) Unable start pump.");
                                        UpdateOperationMessage("Starting Pump. Tries = " + tries.ToString());
                                    }
                                }
                                break;
                            }
                        case 19:
                            {


                                //bhc op set parameters dataset=1 here.

                                //DateTime now = DateTime.Now;
                                if (AcquisitionControl.GetCounter() == 0)
                                {
                                    Logger.WriteLogFile(   "state = 19.  Start sampling.");
                                    UpdateOperationMessage("Start Sampling");
                                    AcquisitionControl.SetCounter(1);


                                    EndTime = DateTime.Now; //default
                                    EndTime = AcquisitionControl.CalculateTimeToSample();  //return the next HH:mm:00 time that's less than a sample time

                                    var TimeRemainingLog = EndTime - DateTime.Now;
                                    if (TimeRemainingLog.Minutes <= 0)
                                    {
                                        Logger.WriteInternalLogFile("State = 19.  Time Remaining:  " + TimeRemainingLog.Hours.ToString("D2") + ":" + TimeRemainingLog.Minutes.ToString("D2") + ":" + TimeRemainingLog.Seconds.ToString("D2"));

                                    }
                                    else
                                    {
                                        // log the time remaining after 19
                                        Logger.WriteInternalLogFile("State = 19.  Time Remaining:  " + TimeRemainingLog.Hours.ToString("D2") + ":" + TimeRemainingLog.Minutes.ToString("D2") + ":" + TimeRemainingLog.Seconds.ToString("D2"));
                                    }
                                }


                                var TimeRemaining = EndTime - DateTime.Now;

                                if (TimeRemaining.Seconds % 10 == 0)
                                {
                                    Logger.WriteLogFile(   "State = 19.  Time Remaining:  " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"));
                                }
                                UpdateOperationMessage("Sampling.  Time Remaining:  " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2"));

                                if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
                                {

                                    AcquisitionControl.SetState(20);
                                    AcquisitionControl.SetCounter(0);

                                    //Record the outputpin 7 value here:


                                    //reset for next calculated time:
                                    var AcqEndTime = AcquisitionControl.GetAcquireEndTime(DateTime.Now);

                                    //AcquisitionControl.SetAcquireStartTime(DateTime.Now);
                                    var AcqStartTime = DateTime.Now;

                                    TimeCalc(19, AcqStartTime);

                                    //double EC1p = AcquisitionControl.GetEC1Percent() / 100;
                                    //double EC2p = AcquisitionControl.GetEC2Percent() / 100;
                                    //double EC3p = AcquisitionControl.GetEC3Percent() / 100;

                                    //int SampleTime = AcquisitionControl.GetSamplePeriod();
                                    //if (SampleTime == 15 || SampleTime==77)
                                    //{

                                    //    int iSampleTime = 15;

                                    //    AcquisitionControl.SetAcquireStartTimeMinutes(AcqStartTime);
                                    //    double timeValue1s;
                                    //    timeValue1s = ((iSampleTime * EC1p * 60) + 80);
                                    //    int itimeValue1s = Convert.ToInt32(timeValue1s);

                                    //    AcquisitionControl.SetEC1Time(itimeValue1s);  //send seconds

                                    //    double timeValue2s = ((iSampleTime * EC2p * 60) - 40);
                                    //    int itimeValue2 = Convert.ToInt32(timeValue2s);

                                    //    AcquisitionControl.SetEC2Time(itimeValue2);


                                    //    double timeValue3s = ( (iSampleTime * EC3p * 60) - 40);



                                    //    if ((timeValue1s + timeValue2s + timeValue3s) > (iSampleTime * 60))
                                    //    {
                                    //        timeValue3s = timeValue3s - ((timeValue1s + timeValue2s + timeValue3s) - iSampleTime * 60);
                                    //    }
                                    //    Logger.WriteLogFile(   "timeValue1s = " + timeValue1s.ToString() + " timeValue2s = " + timeValue2s.ToString() + " timeValue3s = " + timeValue3s.ToString());

                                    //    int itimeValue3 = Convert.ToInt32(timeValue3s);

                                    //    DateTime EC1EndTime = AcqStartTime.AddSeconds(timeValue1s);

                                    //    AcquisitionControl.SetEC1EndTime(EC1EndTime);
                                    //    DateTime EC2EndTime = EC1EndTime.AddSeconds(timeValue2s);
                                    //    AcquisitionControl.SetEC2EndTime(EC2EndTime);

                                    //    DateTime EC3EndTime = EC2EndTime.AddSeconds(itimeValue3);

                                    //    DateTime MinuteAdjustment = AcquisitionControl.AddMin(EC3EndTime, iSampleTime);  //needs to be isampletime here 

                                    //    DateTime EC3EndResult;
                                    //    if (MinuteAdjustment.Second != 0   /* and the minutes must be greater or equal to the end time minutes */)
                                    //    {
                                    //        EC3EndResult = MinuteAdjustment.AddSeconds((-1 * MinuteAdjustment.Second));
                                    //    }
                                    //    else
                                    //    {
                                    //        EC3EndResult = MinuteAdjustment;
                                    //    }


                                    //    AcquisitionControl.SetEC3EndTime(EC3EndResult);

                                    //    Logger.WriteLogFile(   "(19) 15, EC1 End time: " + EC1EndTime.ToString());
                                    //    Logger.WriteLogFile(   "(19) 15, EC2 End time: " + EC2EndTime.ToString());
                                    //    Logger.WriteLogFile(   "(19) 15, EC3 End time: " + EC3EndResult.ToString());



                                    //}
                                    //if (SampleTime == 30)
                                    //{

                                    //    AcquisitionControl.SetAcquireStartTimeMinutes(AcqStartTime);
                                    //    double timeValue1s;
                                    //    timeValue1s = ((SampleTime * EC1p * 60) + 80);
                                    //    int itimeValue1s = Convert.ToInt32(timeValue1s);

                                    //    AcquisitionControl.SetEC1Time(itimeValue1s);  //send seconds

                                    //    double timeValue2s = ((SampleTime * EC2p * 60) - 40);
                                    //    int itimeValue2 = Convert.ToInt32(timeValue2s);

                                    //    AcquisitionControl.SetEC2Time(itimeValue2);


                                    //    double timeValue3s = ((SampleTime * EC3p * 60) - 40);

                                    //    if ((timeValue1s + timeValue2s + timeValue3s) > (SampleTime * 60))
                                    //    {
                                    //        timeValue3s = timeValue3s - ((timeValue1s + timeValue2s + timeValue3s) - SampleTime * 60);
                                    //    }

                                    //    int itimeValue3 = Convert.ToInt32(timeValue3s);

                                    //    DateTime EC1EndTime = AcqStartTime.AddSeconds(timeValue1s);

                                    //    AcquisitionControl.SetEC1EndTime(EC1EndTime);
                                    //    DateTime EC2EndTime = EC1EndTime.AddSeconds(timeValue2s);
                                    //    AcquisitionControl.SetEC2EndTime(EC2EndTime);


                                    //    DateTime EC3EndTime = EC2EndTime.AddSeconds(itimeValue3);

                                    //    DateTime EC3EndResult;


                                    //    DateTime MinuteAdjustment = AcquisitionControl.AddMin(EC3EndTime, SampleTime);


                                    //    if (MinuteAdjustment.Second != 0   /* and the minutes must be greater or equal to the end time minutes */)
                                    //    {
                                    //        EC3EndResult = MinuteAdjustment.AddSeconds((-1 * MinuteAdjustment.Second));
                                    //    }
                                    //    else
                                    //    {
                                    //        EC3EndResult = MinuteAdjustment;
                                    //    }


                                    //    AcquisitionControl.SetEC3EndTime(EC3EndResult);

                                    //    Logger.WriteLogFile(   "(19) 30, EC1 End time: " + EC1EndTime.ToString());
                                    //    Logger.WriteLogFile(   "(19) 30, EC2 End time: " + EC2EndTime.ToString());
                                    //    Logger.WriteLogFile(   "(19) 30, EC3 End time: " + EC3EndResult.ToString());


                                    //}
                                    //if (SampleTime == 60 /*|| SampleTime == 120 || SampleTime == 180 || SampleTime == 240*/)
                                    //{



                                    //    AcquisitionControl.SetAcquireStartTimeMinutes(AcqStartTime);
                                    //    double timeValue1s;
                                    //    timeValue1s = ((SampleTime * EC1p * 60) + 80);
                                    //    int itimeValue1s = Convert.ToInt32(timeValue1s);

                                    //    AcquisitionControl.SetEC1Time(itimeValue1s);  //send seconds

                                    //    double timeValue2s = ((SampleTime * EC2p * 60) - 40);
                                    //    int itimeValue2 = Convert.ToInt32(timeValue2s);

                                    //    AcquisitionControl.SetEC2Time(itimeValue2);


                                    //    double timeValue3s = ((SampleTime * EC3p * 60) - 40);



                                    //    if ((timeValue1s + timeValue2s + timeValue3s) > (SampleTime * 60))
                                    //    {
                                    //        timeValue3s = timeValue3s - ((timeValue1s + timeValue2s + timeValue3s) - SampleTime * 60);
                                    //    }

                                    //    int itimeValue3 = Convert.ToInt32(timeValue3s);


                                    //    DateTime EC1EndTime = AcqStartTime.AddSeconds(timeValue1s);

                                    //    AcquisitionControl.SetEC1EndTime(EC1EndTime);
                                    //    DateTime EC2EndTime = EC1EndTime.AddSeconds(timeValue2s);
                                    //    AcquisitionControl.SetEC2EndTime(EC2EndTime);


                                    //    DateTime EC3EndTime = EC2EndTime.AddSeconds(itimeValue3);

                                    //    DateTime EC3EndResult;


                                    //    DateTime MinuteAdjustment = AcquisitionControl.AddMin(EC3EndTime, SampleTime);


                                    //    if (MinuteAdjustment.Second != 0   /* and the minutes must be greater or equal to the end time minutes */)
                                    //    {
                                    //        EC3EndResult = MinuteAdjustment.AddSeconds((-1 * MinuteAdjustment.Second));
                                    //    }
                                    //    else
                                    //    {
                                    //        EC3EndResult = MinuteAdjustment;
                                    //    }



                                    //    AcquisitionControl.SetEC3EndTime(EC3EndResult);

                                    //    Logger.WriteLogFile(   "(19) , EC1 End time: " + EC1EndTime.ToString());
                                    //    Logger.WriteLogFile(   "(19) , EC2 End time: " + EC2EndTime.ToString());
                                    //    Logger.WriteLogFile(   "(19) , EC3 End time: " + EC3EndResult.ToString());



                                    //}
                                    //if (SampleTime == 120 || SampleTime == 180 || SampleTime == 240)
                                    //{



                                    //    AcquisitionControl.SetAcquireStartTimeMinutes(AcqStartTime);
                                    //    double timeValue1s;
                                    //    timeValue1s = ((SampleTime * EC1p * 60) + 80);
                                    //    int itimeValue1s = Convert.ToInt32(timeValue1s);

                                    //    AcquisitionControl.SetEC1Time(itimeValue1s);  //send seconds

                                    //    double timeValue2s = ((SampleTime * EC2p * 60) - 40);
                                    //    int itimeValue2 = Convert.ToInt32(timeValue2s);

                                    //    AcquisitionControl.SetEC2Time(itimeValue2);


                                    //    double timeValue3s = ((SampleTime * EC3p * 60) - 40);



                                    //    if ((timeValue1s + timeValue2s + timeValue3s) > (SampleTime * 60))
                                    //    {
                                    //        timeValue3s = timeValue3s - ((timeValue1s + timeValue2s + timeValue3s) - SampleTime * 60);
                                    //    }

                                    //    int itimeValue3 = Convert.ToInt32(timeValue3s);


                                    //    DateTime EC1EndTime = AcqStartTime.AddSeconds(timeValue1s);

                                    //    AcquisitionControl.SetEC1EndTime(EC1EndTime);
                                    //    DateTime EC2EndTime = EC1EndTime.AddSeconds(timeValue2s);
                                    //    AcquisitionControl.SetEC2EndTime(EC2EndTime);


                                    //    DateTime EC3EndTime = EC2EndTime.AddSeconds(itimeValue3);

                                    //    DateTime EC3EndResult;


                                    //    //DateTime EC3EndResult;

                                    //    if (EC3EndTime.Minute != 0)
                                    //    {
                                    //        if (EC3EndTime.Minute >= 59)
                                    //        {
                                    //            EC3EndResult = EC3EndTime.AddSeconds(60 - EC3EndTime.Second);
                                    //        }
                                    //        else
                                    //        {
                                    //            EC3EndResult = EC3EndTime.AddSeconds(EC3EndTime.Second - 60);
                                    //        }
                                    //    }
                                    //    else
                                    //    {
                                    //        if (EC3EndTime.Second != 0)
                                    //        {
                                    //            EC3EndResult = EC3EndTime.AddSeconds(-1 * EC3EndTime.Second);
                                    //        }
                                    //        else
                                    //        {
                                    //            EC3EndResult = EC3EndTime;
                                    //        }
                                    //    }




                                    //    AcquisitionControl.SetEC3EndTime(EC3EndResult);

                                    //    Logger.WriteLogFile(   "(19) , EC1 End time: " + EC1EndTime.ToString());
                                    //    Logger.WriteLogFile(   "(19) , EC2 End time: " + EC2EndTime.ToString());
                                    //    Logger.WriteLogFile(   "(19) , EC3 End time: " + EC3EndResult.ToString());



                                    //}



                                }

                                break;


                            }
                        case 20:
                            {

                                Logger.WriteLogFile(   "state = 20.  Get sample flow volume.");
                                if (AcquisitionControl.GetCounter() == 0)
                                {

                                    Logger.WriteLogFile(   "state = 20, counter 0, Get flow volume.");

                                    //sampling has ended, save this for the analysis after ec3.....

                                    double flowVolume = 0.0;
                                    flowVolume = AcquisitionControl.GetFlowVolume();
                                    AcquisitionControl.SetVolume(flowVolume);  //op param
                                    Logger.WriteLogFile(   "state = 20, counter 0, flow volume = " + flowVolume.ToString("F3"));
                                    Logger.WriteLogFile(   "state = 20, counter 0, save flow volume in SetFlowVolumeForAnalysis");

                                    AcquisitionControl.SetFlowVolumeForAnalysis(flowVolume);
                                    double fvfa = AcquisitionControl.GetFlowVolumeForAnalysis();
                                    Logger.WriteLogFile(   "state = 20, counter 0, readback: fl fa= " + fvfa.ToString("F3"));




                                    int datas;
                                    datas = AcquisitionControl.GetDataSet();
                                    Logger.WriteLogFile(   " state 20, dataset (BEFORE) = " + datas.ToString());
                                    vol = AcquisitionControl.GetVolume();
                                    Logger.WriteLogFile("@20 BEFORE:  Dataset = " + AcquisitionControl.GetDataSet().ToString() + " Volume = " + vol.ToString("F2"));


                                    if (datas == 1)
                                    {
                                        AcquisitionControl.SetDataSet(2);
                                        Logger.WriteLogFile(" state 20, dataset was 1, set to 2.");
                                    }
                                    else
                                    {
                                        AcquisitionControl.SetDataSet(1);
                                        Logger.WriteLogFile(" state 20, dataset was 2, set to 1.");
                                    }
                                    Logger.WriteLogFile(" Clearing Operating Data:  "+AcquisitionControl.GetDataSet().ToString());

                                    AcquisitionControl.ClrOperatingData();  //initialize the new data set; save the old for write in state 31 presentation
                                    Logger.WriteLogFile(   "@20 clear data set = " + AcquisitionControl.GetDataSet().ToString());

                                    Logger.WriteLogFile(   " Dataset CLEARED. state 20, dataset (AFTER) = " + AcquisitionControl.GetDataSet().ToString());
                                    vol = AcquisitionControl.GetVolume();
                                    Logger.WriteLogFile(   "@20 AFTER:  Dataset = " + AcquisitionControl.GetDataSet().ToString() + " Volume = " + vol.ToString("F2"));

                                    UpdateOperationMessage("Stop Pump");

                                    Logger.WriteLogFile(   "state = 20, counter 0, perform stop pump thread");

                                    Logger.WriteLogFile(   "state = 20.  setting pump off, set flow volume to zero.");

                                    AcquisitionControl.SetFlowVolume(0);


                                    int returnVal20 = AcquisitionControl.PumpOff(m_oWorkerPump);
                                    if (returnVal20 == PASS)
                                    {

                                        Logger.WriteLogFile("state = 20, Pump Off, set volume =0.");

                                        AcquisitionControl.SetFlowVolume(0);
                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(21);


                                        //AcquisitionControl.SetCounter(1);

                                    }
                                    else
                                    {
                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(20);
                                        Logger.WriteErrorFile("Error: (20) Unable stop pump.");
                                    }

                                }
                                //if (AcquisitionControl.GetCounter() == 1)
                                //{
                                //    Logger.WriteLogFile(   "state = 20, counter = 1 Set flow volume to zero.");

                                //    AcquisitionControl.SetFlowVolume(0);
                                //    AcquisitionControl.SetCounter(0);
                                //    AcquisitionControl.SetState(21);


                                //}
                                break;
                            }
                        case 21:
                            {

                                //check for time for ECAL+UPSCALE
                                //
                                if (AcquisitionControl.GetCounter() == 0)
                                {

                                    int returnV = FAIL;
                                    returnV = CleanProcessData();
                                    if (returnV == FAIL)
                                    {
                                        Logger.WriteErrorFile("Unable to clean output files.");
                                    }
                                    else
                                    {
                                        Logger.WriteLogFile("state = 21.  Clean process data1,data2,data3, and data4 files.");
                                    }

                                    Logger.WriteLogFile("state = 21.  Checking for ECAL and UPSCALE time. ");
                                    //bool nec1 = false;
                                    //bool nec2 = false;
                                    //bool nec3 = false;
                                    //bool nec4 = false;
                                    //GetActiveNormalECs(out nec1, out nec2, out nec3, out nec4);


                                    if (AcquisitionControl.GetUpscale() == 2)
                                    {
                                        AcquisitionControl.SetUpscale(0);    //upscale is complete
                                        bool ec1 = false;
                                        bool ec2 = false;
                                        bool ec3 = false;
                                        bool ec4 = false;
                                        GetActiveNormalECs(out ec1, out ec2, out ec3, out ec4);
                                        if (ec1 == true)
                                        {
                                            AcquisitionControl.SetEnergyCondition(1);
                                        }
                                        else if (ec2 == true)
                                        {
                                            AcquisitionControl.SetEnergyCondition(2);

                                        }
                                        else if (ec3 == true)
                                        {
                                            AcquisitionControl.SetEnergyCondition(3);

                                        }
                                        else if (ec4 == true)
                                        {
                                            AcquisitionControl.SetEnergyCondition(4);

                                        }


                                        UpdateOperationMessage("Upscale completed.  Move DR home");

                                        Logger.WriteLogFile("state = 21.  Upscale completed.  Move rod home.");


                                        int retVal;
                                        int drHomeCount = 0;

                                        do
                                        {
                                            retVal = AcquisitionControl.MoveRodHome(SerialManager, this);
                                            drHomeCount += 1;
                                        } while (retVal == FAIL && drHomeCount < 3);
                                        if (retVal == FAIL)
                                        {
                                            AcquisitionControl.SetAlarmValue(107);
                                            this.WriteAlarmToModbus(107);

                                            Halt("Error: Move DR Home.");
                                        }




                                        Logger.WriteLogFile("state = 21.  Upscale Complete. Computing acquisition times.  ");

                                        var AcqStartTime = DateTime.Now;



                                        //
                                        //
                                        //
                                        TimeCalc21AfterUpscale(21, AcqStartTime);
                                        //
                                        //
                                        //

                                        //AcquisitionControl.NozzleDown(SerialManager, this);

                                        UpdateOperationMessage("Moving Nozzle Down");
                                        int returnVal22 = FAIL;
                                        int ndCounter = 0;

                                        do
                                        {
                                            Logger.WriteLogFile("state = 21, after upscale,  sending nozzle down command.");

                                            returnVal22 = AcquisitionControl.NozzleDown(SerialManager, this);
                                            ndCounter += 1;
                                        } while (returnVal22 == FAIL && ndCounter <= 3);

                                        if (returnVal22 == PASS)
                                        {
                                            Logger.WriteLogFile("after upscale received nozzle down pass response from hardware. ");

                                            //Logger.WriteLogFile(   "Signal modbus data addr 700 = 0");
                                            //DataStore xactHoldingRegisters = AcquisitionControl.getDataStore();
                                            //ushort[] zero = new ushort[1] { 0 };
                                            //nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, zero, 700); // signals registers have been updated
                                            //AcquisitionControl.setDataStore(xactHoldingRegisters);


                                            //AcquisitionControl.SetState(22);
                                            //AcquisitionControl.SetCounter(0);

                                            Logger.WriteLogFile("after upscale, move tape half");
                                            int ReturnValAU = AcquisitionControl.MoveTapeHalf(SerialManager, this);
                                            if (ReturnValAU == PASS)
                                            {

                                                Logger.WriteLogFile("Moving tape half complete ");

                                                AcquisitionControl.SetState(23);
                                                AcquisitionControl.SetCounter(0);

                                            }
                                            else
                                            {

                                                if (ReturnValAU == FAIL_NOZZLE)
                                                {

                                                    UpdateOperationMessage("Error: Nozzle Limits (in function: Move Tape Half.)");
                                                    AcquisitionControl.SetAlarmValue(108);
                                                    this.WriteAlarmToModbus(108);

                                                    Halt("Error Nozzle Limits.  (in function: Move tape half.)");


                                                }
                                                else
                                                {
                                                    UpdateOperationMessage("Error: Move Tape Half. Check tape");
                                                    AcquisitionControl.SetAlarmValue(104);
                                                    this.WriteAlarmToModbus(104);

                                                    Halt("Move tape half error: check tape.");
                                                }

                                            }




                                        }
                                        else
                                        {
                                            //displayActionQueue.Enqueue("Unable to move nozzle down. (control state 21)");
                                            UpdateOperationMessage("After Upscale unable to move nozzle down");
                                            Logger.WriteErrorFile("Error:  After Upscale. Unable to move nozzle down.");
                                            Logger.WriteLogFile("Error:  After Upscale. Unable to move nozzle down.");
                                            AcquisitionControl.SetAlarmValue(108);
                                            this.WriteAlarmToModbus(108);

                                            Halt("After Upscale, errr move nozzle down.");

                                        }






                                    }

                                    //this is normal run:
                                    if (AcquisitionControl.GetECAL() == 0)
                                    {
                                        //if the time ECAL, set flags
                                        //#TODO add ecal time logic here
                                        // 1. add parameter noon/midnight/other
                                        // 2. add logic to read parameter here
                                        // 3. validate that upscale happens correctly--after
                                        if (DateTime.Now.Hour == 0 && DateTime.Now.Minute <= 1)
                                        {

                                            AcquisitionControl.SetECAL(1);
                                            AcquisitionControl.SetEnergyCondition(1);
                                            AcquisitionControl.SetUpscale(0);
                                            UpdateOperationMessage("Move DR to Ecal Position");

                                            Logger.WriteLogFile("state = 21.  Move Rod to Ecal Position   ");

                                            AcquisitionControl.MoveRod(SerialManager, Properties.Settings.Default.EcalRodPosition, this);


                                            ////check for stable position read 
                                            //int posOld = 0;
                                            //int posNew = 1;
                                            //int retv = FAIL;
                                            //int counter = 0;
                                            int getRodPositionValue = 0;
                                            //do
                                            //{
                                            //    retv = AcquisitionControl.CheckMotorPosition(SerialManager, 4, out getRodPositionValue);
                                            //    if (retv == PASS)
                                            //    {
                                            //        posNew = getRodPositionValue;
                                            //    }

                                            //    if (posNew == posOld)
                                            //    {
                                            //        break;
                                            //    }

                                            //    posOld = posNew;
                                            //    counter++;
                                            //    Thread.Sleep(500);
                                            //} while (counter < 60);

                                            getRodPositionValue = AcquisitionControl.PollMotorPosition(4, SerialManager);


                                            Logger.WriteLogFile("(21) Move DR to Ecal returned position = " + getRodPositionValue.ToString());
                                            UpdateDynamicRodMessage("DR at position (" + getRodPositionValue.ToString() + ")");

                                            AcquisitionControl.SetCounter(10);
                                        }
                                        //'M" for manufacturing mode
                                        else if ((AcquisitionControl.GetSamplePeriod() == 77) && (DateTime.Now.Hour == 0 || DateTime.Now.Hour == 6 || DateTime.Now.Hour == 12 || DateTime.Now.Hour == 18) && (DateTime.Now.Minute <= 1))
                                        {
                                            AcquisitionControl.SetECAL(1);
                                            AcquisitionControl.SetEnergyCondition(1);
                                            AcquisitionControl.SetUpscale(0);
                                            UpdateOperationMessage("Move DR to Ecal Position");

                                            Logger.WriteLogFile("state = 21.  Move Rod to Ecal Position   ");

                                            AcquisitionControl.MoveRod(SerialManager, Properties.Settings.Default.EcalRodPosition, this);


                                            int getRodPositionValue = 0;

                                            //AcquisitionControl.CheckMotorPosition(SerialManager, 4, out getRodPositionValue);

                                            getRodPositionValue = AcquisitionControl.PollMotorPosition(4, SerialManager);


                                            Logger.WriteLogFile("DR at Ecal returned position = " + getRodPositionValue.ToString());

                                            UpdateDynamicRodMessage("DR at position (" + getRodPositionValue.ToString() + ")");


                                            AcquisitionControl.SetCounter(10);
                                        }
                                        else
                                        {
                                            AcquisitionControl.SetCounter(10);
                                        }

                                    }
                                    else if (AcquisitionControl.GetECAL() == 2)
                                    {

                                        //ecal is done
                                        //compute the wait for EC1,2,3, normal 15m mode for Upscale
                                        DateTime DTNow = DateTime.Now;

                                        //compute time to wait and compute for 15min mode "upscale"
                                        //wait to start  @ 1215...

                                        if (DTNow.Minute >= 0 && DTNow.Minute <= 15)
                                        {
                                            UpscaleStart = DTNow.Date.Add(new TimeSpan(DTNow.Hour, 15, 0));
                                            string msg = "Upscale start time = " + UpscaleStart.Hour.ToString("D2") + ":" + UpscaleStart.Minute.ToString("D2") + ":" + UpscaleStart.Second.ToString("D2");

                                            UpdateOperationMessage(msg);
                                            Logger.WriteLogFile(msg);
                                        }

                                        //compute the ec1,2,3 end times:
                                        var AcqStartTime = UpscaleStart;

                                        //double EC1p = AcquisitionControl.GetEC1Percent() / 100;
                                        //double EC2p = AcquisitionControl.GetEC2Percent() / 100;
                                        //double EC3p = AcquisitionControl.GetEC3Percent() / 100;
                                        double EC1p = 0.20;// AcquisitionControl.GetEC1Percent() / 100;
                                        double EC2p = 0.40;// AcquisitionControl.GetEC2Percent() / 100;
                                        double EC3p = 0.40;// AcquisitionControl.GetEC3Percent() / 100;




                                        int SampleTime = 15;



                                        AcquisitionControl.SetAcquireStartTimeMinutes(AcqStartTime);
                                        double timeValue1s;
                                        timeValue1s = ((SampleTime * EC1p * 60) + 25);   //25 was 80
                                        int itimeValue1s = Convert.ToInt32(timeValue1s);

                                        AcquisitionControl.SetEC1Time(itimeValue1s);  //send seconds

                                        double timeValue2s = ((SampleTime * EC2p * 60) - 12.5);  //12.5 was 40
                                        int itimeValue2 = Convert.ToInt32(timeValue2s);

                                        AcquisitionControl.SetEC2Time(itimeValue2);

                                        double timeValue3s = ((SampleTime * EC3p * 60) - 12.5);  //12.5 was 40

                                        if ((timeValue1s + timeValue2s + timeValue3s) > (SampleTime * 60))
                                        {
                                            timeValue3s = timeValue3s - ((timeValue1s + timeValue2s + timeValue3s) - SampleTime * 60);
                                        }
                                        Logger.WriteLogFile("timeValue1s = " + timeValue1s.ToString() + " timeValue2s = " + timeValue2s.ToString() + " timeValue3s = " + timeValue3s.ToString());

                                        int itimeValue3 = Convert.ToInt32(timeValue3s);


                                        DateTime EC1EndTime = AcqStartTime.AddSeconds(timeValue1s);

                                        AcquisitionControl.SetEC1EndTime(EC1EndTime);
                                        DateTime EC2EndTime = EC1EndTime.AddSeconds(timeValue2s);
                                        AcquisitionControl.SetEC2EndTime(EC2EndTime);


                                        DateTime EC3EndTime = EC2EndTime.AddSeconds(itimeValue3);

                                        DateTime MinuteAdjustment = AcquisitionControl.AddMin(EC3EndTime, 15);


                                        DateTime EC3EndResult;
                                        if (MinuteAdjustment.Second != 0   /* and the minutes must be greater or equal to the end time minutes */)
                                        {
                                            EC3EndResult = MinuteAdjustment.AddSeconds((-1 * MinuteAdjustment.Second));
                                        }
                                        else
                                        {
                                            EC3EndResult = MinuteAdjustment;
                                        }


                                        AcquisitionControl.SetEC3EndTime(EC3EndResult);

                                        Logger.WriteLogFile("(21) UpScale, EC1 End time: " + EC1EndTime.ToString());
                                        Logger.WriteLogFile("(21) UpScale, EC2 End time: " + EC2EndTime.ToString());
                                        Logger.WriteLogFile("(21) UpScale, EC3 End time: " + EC3EndResult.ToString());



                                        //move rod home after ECAL, allows upscale rod position to be used directly from settings
                                        //Version 1.0.0.29
                                        UpdateOperationMessage("Moving DR home after Ecal");
                                        Logger.WriteLogFile("Moving DR home after Ecal.");

                                        int retVal;
                                        int drHomeCount = 0;

                                        do
                                        {
                                            retVal = AcquisitionControl.MoveRodHome(SerialManager, this);
                                            drHomeCount += 1;
                                        } while (retVal == FAIL && drHomeCount < 3);
                                        if (retVal == FAIL)
                                        {
                                            AcquisitionControl.SetAlarmValue(107);
                                            this.WriteAlarmToModbus(107);

                                            Halt("Error: Move DR Home.");
                                        }



                                        AcquisitionControl.SetECAL(0);
                                        AcquisitionControl.SetEnergyCondition(1);
                                        AcquisitionControl.SetUpscale(1);
                                        AcquisitionControl.SetCounter(4);





                                    }
                                    else
                                    { //normal operation
                                        AcquisitionControl.SetCounter(10);
                                    }

                                }


                                else if (AcquisitionControl.GetCounter() == 4 && AcquisitionControl.GetUpscale() == 1 && AcquisitionControl.GetECAL() == 0)
                                {
                                    //moved logic from here to start of upscale...
                                    //int upscaleRodPosition = Properties.Settings.Default.UpscaleRodPosition;
                                    //UpdateOperationMessage("Move DR to Upscale Pos = " + upscaleRodPosition.ToString());
                                    //Logger.WriteLogFile("state = 21.  Move Rod to Upscale Position:  " + upscaleRodPosition.ToString());

                                    //AcquisitionControl.MoveRod(SerialManager, Properties.Settings.Default.UpscaleRodPosition, this);

                                    //int getRodPositionValue = 0;

                                    ////AcquisitionControl.CheckMotorPosition(SerialManager, 4, out getRodPositionValue);

                                    //getRodPositionValue = AcquisitionControl.PollMotorPosition(4, SerialManager);



                                    //Logger.WriteLogFile("Move DR to Upscale returned position = " + getRodPositionValue.ToString());
                                    //UpdateDynamicRodMessage("DR at position (" + getRodPositionValue.ToString() + ")");



                                    AcquisitionControl.SetCounter(5);
                                }




                                else if (AcquisitionControl.GetCounter() == 5 && AcquisitionControl.GetUpscale() == 1 && AcquisitionControl.GetECAL() == 0)
                                {

                                    //waiting for upscale start
                                    TimeSpan TimeRemaining = UpscaleStart - DateTime.Now;
                                    string msg;
                                    msg = "Time to Upscale " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2");
                                    if (TimeRemaining.Seconds % 10 == 0)
                                    {
                                        Logger.WriteLogFile("state = 21. " + msg);
                                    }
                                    UpdateOperationMessage(msg);
                                    if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
                                    {


                                        int upscaleRodPosition = Properties.Settings.Default.UpscaleRodPosition;
                                        UpdateOperationMessage("Move DR to Upscale Pos = " + upscaleRodPosition.ToString());
                                        Logger.WriteLogFile("state = 21.  Move Rod to Upscale Position:  " + upscaleRodPosition.ToString());

                                        AcquisitionControl.MoveRod(SerialManager, Properties.Settings.Default.UpscaleRodPosition, this);

                                        int getRodPositionValue = 0;

                                        //AcquisitionControl.CheckMotorPosition(SerialManager, 4, out getRodPositionValue);

                                        getRodPositionValue = AcquisitionControl.PollMotorPosition(4, SerialManager);



                                        Logger.WriteLogFile("Move DR to Upscale returned position = " + getRodPositionValue.ToString());
                                        UpdateDynamicRodMessage("DR at position (" + getRodPositionValue.ToString() + ")");


                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(24);
                                    }



                                }
                                else if (AcquisitionControl.GetCounter() == 10)
                                {



                                    Logger.WriteLogFile(   "state = 21.  Move nozzle down.");
                                    int returnVal21 = FAIL;
                                    int ndCounterNormalPath = 0;
                                    if (AcquisitionControl.GetCounter() >= 10)
                                    {
                                        Logger.WriteLogFile(   "State = 21, counter =0,  Nozzle down command sent.");
                                        UpdateOperationMessage("Moving nozzle Down");

                                        do
                                        {
                                            Logger.WriteLogFile("Sending nozzle down command....");
                                            returnVal21 = AcquisitionControl.NozzleDown(SerialManager, this);
                                            ndCounterNormalPath += 1;
                                        } while (returnVal21 == FAIL && ndCounterNormalPath <= 3);

                                        if (returnVal21 == PASS)
                                        {
                                            Logger.WriteLogFile(   "Received nozzle down pass response from hardware.  Set state = 22.");


                                            //Logger.WriteLogFile(   "Signal modbus data addr 700 = 0");
                                            //DataStore xactHoldingRegisters = AcquisitionControl.getDataStore();
                                            //ushort[] zero = new ushort[1] { 0 };
                                            //nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, zero, 700); // signals registers have been updated
                                            //AcquisitionControl.setDataStore(xactHoldingRegisters);


                                            AcquisitionControl.SetState(22);
                                            AcquisitionControl.SetCounter(0);


                                        }
                                        else //nozzle down
                                        {
                                            //AcquisitionControl.SetCounter(AcquisitionControl.GetCounter() + 1);
                                            UpdateOperationMessage("Unable to move nozzle down");
                                            Logger.WriteErrorFile("Error: Unable to move nozzle down.");
                                            Logger.WriteLogFile("Error: Unable to move nozzle down.");
                                            //if(AcquisitionControl.GetCounter()>=12)
                                            //{
                                            AcquisitionControl.SetAlarmValue(108);
                                                this.WriteAlarmToModbus(108);
                                                Halt("Error: Move Nozzle Down.");
                                            //}

                                        }
                                    }


                                }
                                break;
                            }
                        case 22:
                            {


                                if (AcquisitionControl.GetECAL() > 0)
                                {
                                    Logger.WriteLogFile(   "state = 22. ECAL move tape half move.");
                                    UpdateOperationMessage("Move tape: half move");
                                    if (AcquisitionControl.GetCounter() ==0 )
                                    {
                                        int ReturnVal = AcquisitionControl.MoveTapeHalf(SerialManager, this);
                                        if (ReturnVal == PASS)
                                        {

                                            Logger.WriteLogFile(   "Moving tape half complete ");

                                            UpdateOperationMessage("Move tape half completed");
                                            AcquisitionControl.SetState(23);
                                            AcquisitionControl.SetCounter(0);

                                        }
                                        else
                                        {
                                            if (ReturnVal == FAIL_NOZZLE)
                                            {

                                                Logger.WriteErrorFile("Error: Nozzle Limits. (in function: Move Tape Half.)");
                                                Logger.WriteLogFile("STOP acquire sent.");
                                                Logger.WriteLogFile("Error: Nozzle Limits.  (in function: Move Tape Half.)");
                                                AcquisitionControl.SetAlarmValue(108);
                                                this.WriteAlarmToModbus(108);

                                                Halt("Error: Nozzle Limits. (in function: Move Tape Half.)");

                                            }
                                            else
                                            {
                                                Logger.WriteErrorFile("Error: Move tape half.  check tape.");
                                                Logger.WriteLogFile("STOP acquire sent.");
                                                Logger.WriteLogFile("Error: Move tape half.  check tape.");
                                                AcquisitionControl.SetAlarmValue(104);
                                                this.WriteAlarmToModbus(104);

                                                Halt("Move tape half error:  check tape.");
                                            }
                                        }

                                    }
                                    //else
                                    //{
                                    //    Logger.WriteErrorFile("Error: Move tape half.  check tape.");
                                    //    Logger.WriteLogFile("STOP acquire sent.");
                                    //    Logger.WriteLogFile("Error: Move tape half.  check tape.");
                                    //    AcquisitionControl.SetAlarmValue(104);
                                    //    this.WriteAlarmToModbus(104);

                                    //    Halt("Move tape half error:  check tape.");
                                    //}

                                }

                                else if (AcquisitionControl.GetUpscale() > 0)
                                {

                                    if (AcquisitionControl.GetCounter() == 0)
                                    {
                                        AcquisitionControl.SetState(23);
                                        AcquisitionControl.SetCounter(0);


                                    }

                                }

                                else
                                {

                                    Logger.WriteLogFile(   "Moving tape full.");
                                    UpdateOperationMessage("Moving tape full");

                                    if (AcquisitionControl.GetCounter() ==0)
                                    {
                                        int returnVal = AcquisitionControl.MoveTapeFull(SerialManager, this);
                                        if (returnVal == PASS)

                                        {
                                            AcquisitionControl.SetState(23);
                                            AcquisitionControl.SetCounter(0);


                                        }
                                        else
                                        {


                                            if (returnVal == FAIL_NOZZLE)
                                            {
                                                Logger.WriteErrorFile("Error: Nozzle Limits. (in function: Move tape full.)");
                                                Logger.WriteLogFile("Error: Nozzle Limits. (in function: Move tape full.)");
                                                Logger.WriteLogFile("STOP acquire sent.");
                                                AcquisitionControl.SetAlarmValue(108);
                                                this.WriteAlarmToModbus(108);
                                                Halt("Error: Nozzle Limits. (in function: Move tape full.");
                                            }
                                            else
                                            {
                                                Logger.WriteErrorFile("Error: Move tape full.  check tape.");
                                                Logger.WriteLogFile("Error: Move tape full.  check tape.");
                                                Logger.WriteLogFile("STOP acquire sent.");
                                                AcquisitionControl.SetAlarmValue(104);
                                                this.WriteAlarmToModbus(104);
                                                Halt("Move tape full error:  check tape.");
                                            }
                                        }


                                    }
                                    //else
                                    //{
                                    //    Logger.WriteErrorFile("Error: Move tape full.  check tape.");
                                    //    Logger.WriteLogFile("Error: Move tape full.  check tape.");
                                    //    Logger.WriteLogFile("STOP acquire sent.");
                                    //    AcquisitionControl.SetAlarmValue(104);
                                    //    this.WriteAlarmToModbus(104);

                                    //    Halt("Move tape full error:  check tape.");
                                    //}
                                }



                                break;


                            }
                        case 23:
                            {


                                Logger.WriteLogFile(   "state = 23. Moving nozzle Up");
                                UpdateOperationMessage("Moving nozzle Up");
                                if (AcquisitionControl.GetCounter() == 0)
                                {
                                    AcquisitionControl.SetCounter(1);
                                }
                                Logger.WriteLogFile("state 23.  Sending nozzle up command.");
                                int returnVal23 = AcquisitionControl.NozzleUp(SerialManager, this);
                                if (returnVal23 == PASS)
                                {

                                    Logger.WriteLogFile(   "(23) Moving Nozzle Up  Pass.");


                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(24);
                                }
                                else
                                {
                                    AcquisitionControl.SetCounter(AcquisitionControl.GetCounter() + 1);

                                    Logger.WriteErrorFile("Error:  Unable to move nozzle up. ");
                                    Logger.WriteLogFile("Error:  Unable to move nozzle up. ");
                                    if (AcquisitionControl.GetCounter() >= 3)
                                    {
                                        AcquisitionControl.SetAlarmValue(108);
                                        this.WriteAlarmToModbus(108);
                                        //Logger.WriteErrorFile("Error:  Unable to move nozzle up. (23)");

                                        Halt("Unable to move nozzle up");
                                    }

                                }

                                break;


                            }
                        case 24:
                            {
                                Logger.WriteLogFile(   "state = 24. check ECal or Upscale");
                                int ecalReturn = 0;
                                int upscaleReturn = 0;
                                ecalReturn = AcquisitionControl.GetECAL();
                                upscaleReturn = AcquisitionControl.GetUpscale();
                                if (ecalReturn > 0)
                                {
                                    Logger.WriteLogFile(   "state = 24. ECAL active.  Not starting pump.  Advance to state 25.  Ecal Active = " + ecalReturn.ToString());
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(25);

                                }
                                if (upscaleReturn > 0)
                                {
                                    Logger.WriteLogFile(   "state = 24. UPSCALE active.  Not starting pump.  Advance to state 25.  Upscale Active = " + upscaleReturn.ToString());
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(25);

                                }

                                if (AcquisitionControl.GetState() == 24)
                                {
                                    UpdateOperationMessage("Start acquisition pump");
                                    Logger.WriteLogFile(   "state = 24. start pump");
                                    Logger.WriteLogFile(   "state = 24.  Set flow volume to zero.");

                                    //AcquisitionControl.SetPin7OutputStateDataset(false);
                                    //AcquisitionControl.SetControlLines(SerialControlLinesManager, false, false);



                                    AcquisitionControl.SetFlowVolume(0);  //clear it before starting pump.
                                    AcquisitionControl.ClrOperatingData();
                                    if (Properties.Settings.Default.OutputPin7 == true /*|| Properties.Settings.Default.OutputPin4 == true*/)
                                    {
                                        int val = AcquisitionControl.GetDataSet();
                                        Logger.WriteInternalLogFile("State 24:  Dataset = " + val.ToString());


                                        bool cl7;
                                        bool cl4;
                                        AcquisitionControl.GetControlLines(SerialIOControlLinesManager, out cl7, out cl4);
                                        Logger.WriteInternalLogFile("cl7 = " + cl7.ToString());
                                        Logger.WriteInternalLogFile("cl4 = " + cl4.ToString());
                                        //cl7=AcquisitionControl.GetPin7OutputStateDataset();
                                        if (cl7 == true)
                                        {
                                            Logger.WriteInternalLogFile("Setting cl7 false.  Setting dataset cl7 false");
                                            AcquisitionControl.SetControlLines(SerialIOControlLinesManager, false, false);
                                            AcquisitionControl.SetPin7OutputStateDataset(false);

                                        }
                                        else
                                        {
                                            Logger.WriteInternalLogFile("Setting cl7 true.  Setting dataset cl7 true");
                                            AcquisitionControl.SetControlLines(SerialIOControlLinesManager, true, false);
                                            AcquisitionControl.SetPin7OutputStateDataset(true);
                                        }
                                    }



                                    Logger.WriteLogFile(   "@24 clear data set; data set = " + AcquisitionControl.GetDataSet().ToString());
                                    AcquisitionControl.SetAcquisitionOpStartDateTime();

                                    //displayActionQueue.Enqueue("Starting Pump.");
                                    int returnVal24 = AcquisitionControl.PumpOn(m_oWorkerPump);
                                    if (returnVal24 == PASS)
                                    {

                                        SetModbusPumpActive(1);
                                        SetModbusPumpActiveTime();

                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(25);

                                    }
                                    else
                                    {

                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(24);
                                        Logger.WriteErrorFile("Error:  (24) Unable to start pump.");
                                        AcquisitionControl.SetAlarmValue(105);
                                        this.WriteAlarmToModbus(105);

                                        Halt("Unable to start pump");

                                    }
                                }
                                break;

                            }
                        case 25:
                            {

                                int ecValue = 0;
                                int destinationV = 0;
                                int destinationI = 0;
                                double presentV = 0.0;
                                double presentI = 0.0;

                                bool ec1 = false;
                                bool ec2 = false;
                                bool ec3 = false;
                                bool ec4 = false;
                                GetActiveNormalECs(out ec1, out ec2, out ec3, out ec4);


                                if(AcquisitionControl.GetECAL()>0 || AcquisitionControl.GetUpscale()>0)
                                {

                                    Logger.WriteLogFile(   "state 25 setting ec1=true, ec2= true, ec3=true,ec4=false");
                                    ec1 = true;
                                    ec2 = true;
                                    ec3 = true;
                                    ec4 = false;
                                }

                                int activeEC = AcquisitionControl.GetEnergyCondition();
                                Logger.WriteLogFile(   "Active Energy Condition = "+activeEC.ToString());


                                if (AcquisitionControl.GetCounter() == 0)
                                {
                                    Logger.WriteLogFile(   "state = 25. Ramp X-rays.");

                                    AcquisitionControl.SetCounter(1);
                                    //displayActionQueue.Enqueue("Ramp Xrays.");
                                    UpdateOperationMessage("Ramping X-rays");
                                    Thread.Sleep(1000);


                                }

                                if (AcquisitionControl.GetECAL() > 0)
                                {
                                    //set xray variables

                                    destinationV = Properties.Settings.Default.EcalkV;
                                    destinationI = Properties.Settings.Default.EcaluA;

                                    presentV = readInputVoltage;
                                    presentV = presentV * 50.0 / 10.0;


                                    presentI = readInputCurrent;
                                    presentI = presentI * 2000.0 / 10.0;


                                    Logger.WriteLogFile(   "ECAL ramp V from: " + presentV.ToString("F2") + " to: " + destinationV.ToString("F2"));
                                    Logger.WriteLogFile(   "ECAL ramp I from: " + presentI.ToString("F2") + " to: " + destinationI.ToString("F2"));



                                }
                                else if (AcquisitionControl.GetUpscale() > 0)
                                {

                                    Logger.WriteLogFile(   "Upscale, Ramp Voltage");
                                    //EC1 ramp xrays
                                    ecValue = AcquisitionControl.GetEnergyCondition();

                                    if (ecValue == 1)
                                    {
                                        //read from parameter storage    
                                        int EC1kV; //EC1kV
                                                   //set:
                                                   //Properties.Settings.Default.Tnist= "abc";
                                                   //Properties.Settings.Default.Save();



                                        Logger.WriteLogFile(   "Upscale (25) setting EC1 V and I.");



                                        EC1kV = Properties.Settings.Default.EC1kV;
                                        float fEC1kV;
                                        fEC1kV = Convert.ToSingle(EC1kV);

                                        int EC1uA; //EC1kV
                                        EC1uA = Properties.Settings.Default.EC1uA;
                                        float fEC1uA;
                                        fEC1uA = Convert.ToSingle(EC1uA);

                                        //
                                        // set filter example
                                        //


                                        destinationV = Convert.ToInt32(fEC1kV);
                                        destinationI = Convert.ToInt32(fEC1uA);
                                    }
                                    else if (ecValue == 2)
                                    {

                                        Logger.WriteLogFile(   "Upscale (25) setting EC2 V and I for comm interface.");

                                        int EC2kV;
                                        EC2kV = Properties.Settings.Default.EC2kV;
                                        float fEC2kV;
                                        fEC2kV = Convert.ToSingle(EC2kV);

                                        int EC2uA;
                                        EC2uA = Properties.Settings.Default.EC2uA;
                                        float fEC2uA;
                                        fEC2uA = Convert.ToSingle(EC2uA);

                                        destinationV = Convert.ToInt32(fEC2kV);
                                        destinationI = Convert.ToInt32(fEC2uA);


                                    }
                                    else if (ecValue == 3)
                                    {
                                        Logger.WriteLogFile(   "UPSCALE (25) setting EC3 V and I for comm interface.");

                                        int EC3kV;
                                        EC3kV = Properties.Settings.Default.EC3kV;
                                        float fEC3kV;
                                        fEC3kV = Convert.ToSingle(EC3kV);

                                        int EC3uA;
                                        EC3uA = Properties.Settings.Default.EC3uA;
                                        float fEC3uA;
                                        fEC3uA = Convert.ToSingle(EC3uA);


                                        destinationV = Convert.ToInt32(fEC3kV);
                                        destinationI = Convert.ToInt32(fEC3uA);

                                        //set these values in the files written by xrsfp //bhc
                                    }

                                    presentV = readInputVoltage;
                                    presentV = presentV * 50.0 / 10.0;


                                    presentI = readInputCurrent;
                                    presentI = presentI * 2000.0 / 10.0;


                                    Logger.WriteLogFile(   "UPSCALE ramp V from: " + presentV.ToString("F2") + " to: " + destinationV.ToString("F2"));
                                    Logger.WriteLogFile(   "UPSCALE ramp I from: " + presentI.ToString("F2") + " to: " + destinationI.ToString("F2"));


                                }
                                else
                                {

                                    //EC1 ramp xrays
                                    ecValue = AcquisitionControl.GetEnergyCondition();

                                    if (ecValue == 1 && ec1 == true)
                                    {


                                        //#TODO at least active energy condition? 
                                        CheckDetectorConnection();

                                        //int retVal=FAIL;
                                        //int count = 0;
                                        //do
                                        //{
                                        //    retVal = AcquisitionControl.CheckDetectorConnection();
                                        //    count += 1;
                                        //} while (count < 3 && retVal == FAIL);
                                        //if(retVal==FAIL)
                                        //{
                                        //    Halt("Unable to connect to detector.");
                                        //    AcquisitionControl.SetAlarmValue(110);
                                        //    WriteAlarmToModbus(110);

                                        //}





                                        //read from parameter storage    
                                        int EC1kV; //EC1kV


                                        Logger.WriteLogFile(   "(25) setting EC1 V and I for comm interface.");

                                        //bhc verify data reads here:


                                        EC1kV = Properties.Settings.Default.EC1kV;
                                        float fEC1kV;
                                        fEC1kV = Convert.ToSingle(EC1kV);

                                        int EC1uA; //EC1kV
                                        EC1uA = Properties.Settings.Default.EC1uA;
                                        float fEC1uA;
                                        fEC1uA = Convert.ToSingle(EC1uA);

                                        destinationV = Convert.ToInt32(fEC1kV);
                                        destinationI = Convert.ToInt32(fEC1uA);
                                        //set these values in the files written by xrsfp //bhc
                                    }
                                    else if (ecValue == 2 && ec2 == true)
                                    {

                                        Logger.WriteLogFile(   "(25) setting EC2 V and I for comm interface.");

                                        int EC2kV;
                                        EC2kV = Properties.Settings.Default.EC2kV;
                                        float fEC2kV;
                                        fEC2kV = Convert.ToSingle(EC2kV);

                                        int EC2uA;
                                        EC2uA = Properties.Settings.Default.EC2uA;
                                        float fEC2uA;
                                        fEC2uA = Convert.ToSingle(EC2uA);

                                        destinationV = Convert.ToInt32(fEC2kV);
                                        destinationI = Convert.ToInt32(fEC2uA);

                                        //destinationV = 46;
                                        //destinationI = 800;
                                        //set these values in the files written by xrsfp //bhc
                                    }
                                    else if (ecValue == 3 && ec3 == true)
                                    {
                                        Logger.WriteLogFile(   "(25) setting EC3 V and I for comm interface.");

                                        int EC3kV;
                                        EC3kV = Properties.Settings.Default.EC3kV;
                                        float fEC3kV;
                                        fEC3kV = Convert.ToSingle(EC3kV);

                                        int EC3uA;
                                        EC3uA = Properties.Settings.Default.EC3uA;
                                        float fEC3uA;
                                        fEC3uA = Convert.ToSingle(EC3uA);


                                        destinationV = Convert.ToInt32(fEC3kV);
                                        destinationI = Convert.ToInt32(fEC3uA);

                                        //set these values in the files written by xrsfp //bhc
                                    }
                                    else if (ecValue == 4 && ec4 == true)
                                    {
                                        Logger.WriteLogFile(   "(25) setting EC4 V and I for comm interface.");

                                        int EC4kV;
                                        EC4kV = Properties.Settings.Default.EC4kV;
                                        float fEC4kV;
                                        fEC4kV = Convert.ToSingle(EC4kV);

                                        int EC4uA;
                                        EC4uA = Properties.Settings.Default.EC4uA;
                                        float fEC4uA;
                                        fEC4uA = Convert.ToSingle(EC4uA);


                                        destinationV = Convert.ToInt32(fEC4kV);
                                        destinationI = Convert.ToInt32(fEC4uA);

                                        //set these values in the files written by xrsfp //bhc
                                    }



                                    else
                                    {
                                        destinationV = 0;
                                        destinationI = 0;
                                        bool setEC4uA = myxrsfp.Send_kV[0];

                                    }


                                    presentV = readInputVoltage;
                                    presentV = presentV * 50.0 / 10.0;


                                    presentI = readInputCurrent;
                                    presentI = presentI * 2000.0 / 10.0;


                                    Logger.WriteLogFile(   "ramp V from: " + presentV.ToString("F2") + " to: " + destinationV.ToString("F2"));
                                    Logger.WriteLogFile(   "ramp I from: " + presentI.ToString("F2") + " to: " + destinationI.ToString("F2"));

                                }
                                Logger.WriteLogFile(   "ramp V from: " + presentV.ToString("F2") + " to: " + destinationV.ToString("F2"));
                                Logger.WriteLogFile(   "ramp I from: " + presentI.ToString("F2") + " to: " + destinationI.ToString("F2"));
                                int returnVal25 = AcquisitionControl.RampXrays(presentV, presentI, destinationV, destinationI, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);

                                if (mtbInterlockStatus.InvokeRequired)
                                {
                                    mtbInterlockStatus.Invoke(new MethodInvoker(delegate { mtbInterlockStatus.Text = "Closed"; }));

                                }
                                else
                                {
                                    mtbInterlockStatus.Text = "Closed";
                                }

                                if (returnVal25 == PASS)
                                {
                                    Logger.WriteLogFile(   "(25)Ramp return:  PASS.");

                                    UpdateOperationMessage("Ramp X-rays Pass");
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(26);

                                }
                                else
                                {
                                    AcquisitionControl.SetCounter(0);

                                    AcquisitionControl.SetState(25);

                                    Logger.WriteErrorFile("Error:  (25) Unable to ramp xrays.");
                                    Logger.WriteLogFile("Error:  (25) Unable to ramp xrays.");
                                    UpdateOperationMessage("Unable to ramp xrays");
                                }

                            }
                            break;

                        case 26:


                            {
                                Logger.WriteLogFile("state = 26.");

                                if (AcquisitionControl.GetCounter() == 0)
                                {
                                    //AcquisitionControl.SetCounter();
                                    UpdateOperationMessage("Move FW");
                                    Logger.WriteLogFile("state 26. Move FW to EC.");




                                    if (AcquisitionControl.GetECAL() > 0)
                                    {


                                        int ECend;
                                        int ECstart;



                                        Logger.WriteLogFile("Start of Ecal, Move FW home");
                                        int homeCount = 0;
                                        int retVal = FAIL;
                                        do
                                        {
                                            retVal = AcquisitionControl.MoveFWHome(SerialManager, this);
                                            if (retVal != PASS)
                                            {
                                                homeCount++;
                                            }
                                        } while (homeCount < 3 && retVal == FAIL);
                                        if (retVal == PASS)
                                        {
                                            AcquisitionControl.SetEnergyConditionPrevious(0);
                                            //
                                            // end FW home
                                            //


                                            ECend = 1;
                                            ECstart = 0;
                                            AcquisitionControl.SetCounter(1);
                                        }
                                        else
                                        {
                                            AcquisitionControl.SetEnergyConditionPrevious(0);
                                            ECend = 1;
                                            ECstart = AcquisitionControl.GetEnergyConditionPrevious();
                                            AcquisitionControl.SetAlarmValue(106);
                                            this.WriteAlarmToModbus(106);
                                            Halt("Unable to move FW Home.");
                                        }
                                    }
                                    else
                                    {
                                        bool ec1, ec2, ec3, ec4;
                                        GetActiveNormalECs(out ec1, out ec2, out ec3, out ec4);

                                        if (AcquisitionControl.GetECAL() > 0 || AcquisitionControl.GetUpscale() > 0)
                                        {

                                            ec1 = true;
                                            ec2 = true;
                                            ec3 = true;
                                            ec4 = false;
                                        }


                                        int ECend;
                                        //int ECstart;

                                        ECend = AcquisitionControl.GetEnergyCondition();

                                        if ((ECend == 1 && ec1 == true) || (ECend == 2 && ec2 == true) || (ECend == 3 && ec3 == true) || (ECend == 4 && ec4 == true))
                                        {
                                            AcquisitionControl.SetCounter(1);
                                        }
                                        //else
                                        //{
                                        //    AcquisitionControl.SetCounter(0);
                                        //    AcquisitionControl.SetState(28);
                                        //}
                                    }
                                    AcquisitionControl.SetCounter(1);

                                }
                                else if (AcquisitionControl.GetCounter() == 1)
                                {


                                    string status;
                                    //int ECend;
                                    //int ECstart;
                                    fwECstart = AcquisitionControl.GetEnergyConditionPrevious();
                                    fwECend = AcquisitionControl.GetEnergyCondition();

                                    status = "Move Filter Wheel to EC " + fwECend.ToString();
                                    Logger.WriteLogFile("state = 26. " + status);


                                    //Logger.WriteLogFile(   "Moving FW from: " + ECstart.ToString() + " to: " + ECend.ToString());
                                    //UpdateOperationMessage("Moving FW from:  EC" + ECstart.ToString() + "  to:  EC" + ECend.ToString()); 
                                    //int beforePosition = 0;
                                    //
                                    //int returnVal = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out beforePosition);
                                    //Logger.WriteLogFile(   "EC " + ECend.ToString() + " (destination) motor position, before move = " + beforePosition.ToString());
                                    //Logger.WriteLogFile(   "Check before FW postion returned: " + returnVal.ToString());



                                    filterWheelReturnValue = AcquisitionControl.MoveFWEC(SerialManager, fwECstart, fwECend, this);

                                    AcquisitionControl.SetCounter(2);
                                    
                                    if(fwRetry==1)
                                    {
                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(27);


                                    }





                                }
                                else if (AcquisitionControl.GetCounter()>=2)
                                {
                                    UpdateOperationMessage("Loading analysis file");


                                    int energyCondition = AcquisitionControl.GetEnergyCondition();
                                    int LTFR1 = 0, LTFR2 = 0, LTFR3 = 0, LTFR4 = 0;

                                    bool ec1, ec2, ec3, ec4;
                                    GetActiveNormalECs(out ec1, out ec2, out ec3, out ec4);

                                    if (AcquisitionControl.GetECAL() > 0 || AcquisitionControl.GetUpscale() > 0)
                                    {

                                        ec1 = true;
                                        ec2 = true;
                                        ec3 = true;
                                        ec4 = false;
                                    }

                                    switch (energyCondition)
                                    {
                                        case 1:
                                            if (ec1 == true)
                                            {
                                                LTFR1 = 1;
                                            }
                                            break;
                                        case 2:
                                            if (ec2 == true)
                                            {
                                                LTFR2 = 1;
                                            }
                                            break;
                                        case 3:
                                            if (ec3 == true)
                                            {
                                                LTFR3 = 1;
                                            }
                                            break;
                                        case 4:
                                            if (ec4 == true)
                                            {
                                                LTFR4 = 1;
                                            }
                                            break;
                                        default:
                                            Logger.WriteInternalLogFile("No valid EC.");
                                            break;
                                    }

                                    int returnVal26 = FAIL;

                                    if (LTFR1 == 1 || LTFR2 == 1 || LTFR3 == 1 || LTFR4 == 1)
                                    {
                                        returnVal26 = AcquisitionControl.LoadMTFRFile(energyCondition);
                                    }
                                    else
                                    {
                                        Logger.WriteInternalLogFile("Error:  (26) Energy Condition " + energyCondition.ToString() + " not enabled.  No load of analysis file.");
                                        Halt("No valid Energy Condition.  EC = " + energyCondition.ToString());
                                        //AcquisitionControl.SetCounter(0);
                                        //                                    AcquisitionControl.SetState(27);

                                    }

                                    if (returnVal26 == PASS)
                                    {
                                        Logger.WriteLogFile("(26) load MFTRFile + cond code returned: true");
                                        //retryLoadMFTActive = 0;
                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(27);

                                    }
                                    else
                                    {
                                        int counterValue = AcquisitionControl.GetCounter();
                                        if (counterValue <= 4)
                                        {
                                            AcquisitionControl.SetState(26);
                                            counterValue++;
                                            AcquisitionControl.SetCounter(counterValue);
                                            //retryLoadMFTActive = 1;
                                        }
                                        if (counterValue > 4)
                                        {
                                            //retryLoadMFTActive = 0;
                                            Logger.WriteErrorFile("Error:  (26) Unable to load master file  " + energyCondition.ToString());
                                            Logger.WriteLogFile("Error:  (26) Unable to load master file  " + energyCondition.ToString());

                                            Halt("Unable to load master file " + energyCondition.ToString());
                                        }

                                    }
                                }
                            }
                            break;

                        case 27:
                            {

                                if (AcquisitionControl.GetCounter() >= 0)
                                {

                                    if (filterWheelReturnValue == PASS)
                                    {

                                        Logger.WriteLogFile("EC " + fwECend.ToString() + " fw MOVE RETURNED PASS.");
                                        int position = 0;

                                        //int returnVal27 = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);  //1=FW
                                        position = AcquisitionControl.PollMotorPosition(1, SerialManager);


                                        Logger.WriteLogFile("EC " + fwECend.ToString() + " (destination) motor position, after move = " + position.ToString());
                                       // Logger.WriteLogFile("Check FW motor postion returned: " + returnVal27.ToString());


                                        if (fwECend == 1)
                                        {


                                            if (position.ToString().Contains(Properties.Settings.Default.FWEC1.ToString()))
                                            {
                                                UpdateOperationMessage("Move FW to EC1 Pass");
                                                UpdateFilterWheelMessage("FW at EC1 (" + Properties.Settings.Default.FWEC1.ToString() + ")");
                                                AcquisitionControl.SetEnergyConditionPrevious(1);
                                                AcquisitionControl.SetCounter(0);
                                                AcquisitionControl.SetState(28);
                                            }
                                            else
                                            {

                                                //incorrect position returned
                                                if (fwRetry == 0)
                                                {
                                                    UpdateOperationMessage("Unable to move FW to EC1, moving FW home");
                                                    Logger.WriteErrorFile("Error: (27) Unable to move Filter Wheel to EC1.");
                                                    Logger.WriteLogFile("Error: (27) Unable to move Filter Wheel to EC1.");



                                                    Logger.WriteLogFile("WARNING:  incorrect position returned.  Sending FW home");

                                                    int homeCount = 0;
                                                    int retVal = FAIL;
                                                    do
                                                    {
                                                        retVal = AcquisitionControl.MoveFWHome(SerialManager, this);
                                                        if (retVal != PASS)
                                                        {
                                                            homeCount++;
                                                        }
                                                    } while (homeCount < 3 && retVal == FAIL);

                                                    if (retVal == PASS)
                                                    {
                                                        AcquisitionControl.SetEnergyConditionPrevious(0);

                                                        //send FW to correct EC....
                                                        fwECstart = AcquisitionControl.GetEnergyConditionPrevious();
                                                        fwECend = AcquisitionControl.GetEnergyCondition();

                                                        string status = "Move Filter Wheel to EC " + fwECend.ToString() + " retry.";
                                                        UpdateOperationMessage(status);

                                                        fwRetry = 1;
                                                        AcquisitionControl.SetCounter(1);
                                                        AcquisitionControl.SetState(26);

                                                    }
                                                    else
                                                    {
                                                        AcquisitionControl.SetAlarmValue(106);
                                                        this.WriteAlarmToModbus(106);

                                                        Halt("Error:  Failed to move FW Home.");

                                                    }
                                                }
                                                else
                                                {

                                                    Halt("Error:  Failed to move FW to EC1");

                                                }




                                            }
                                        }
                                        else if (fwECend == 2)
                                        {
                                            //Logger.WriteLogFile(   "EC "+ECend.ToString()+ " (destination) motor position, after move = " + position.ToString());
                                            if (position.ToString().Contains(Properties.Settings.Default.FWEC2.ToString()))
                                            {
                                                UpdateOperationMessage("Move FW to EC2 Pass");
                                                UpdateFilterWheelMessage("FW at EC2 (" + Properties.Settings.Default.FWEC2.ToString() + ")");
                                                AcquisitionControl.SetEnergyConditionPrevious(2);
                                                AcquisitionControl.SetCounter(0);
                                                AcquisitionControl.SetState(28);
                                            }
                                            else
                                            {
                                                if (fwRetry == 0)
                                                {
                                                    //incorrect position returned
                                                    //AcquisitionControl.SetState(27);
                                                    UpdateOperationMessage("Unable to move FW to EC2, moving FW home");
                                                    Logger.WriteErrorFile("Error: (27) Unable to move Filter Wheel to EC2.");
                                                    Logger.WriteLogFile("Error: (27) Unable to move Filter Wheel to EC2.");

                                                    Logger.WriteLogFile("WARNING:  incorrect position returned.  Sending FW home");

                                                    int homeCount = 0;
                                                    int retVal = FAIL;
                                                    do
                                                    {
                                                        retVal = AcquisitionControl.MoveFWHome(SerialManager, this);
                                                        if (retVal != PASS)
                                                        {
                                                            homeCount++;
                                                        }
                                                    } while (homeCount < 3 && retVal == FAIL);


                                                    if (retVal == PASS)
                                                    {
                                                        AcquisitionControl.SetEnergyConditionPrevious(0);

                                                        //send FW to correct EC....
                                                        fwECstart = AcquisitionControl.GetEnergyConditionPrevious();
                                                        fwECend = AcquisitionControl.GetEnergyCondition();

                                                        string status = "Move Filter Wheel to EC " + fwECend.ToString() + " retry.";
                                                        UpdateOperationMessage(status);

                                                        fwRetry = 1;
                                                        AcquisitionControl.SetCounter(1);
                                                        AcquisitionControl.SetState(26);
                                                    }
                                                    else
                                                    {
                                                        AcquisitionControl.SetAlarmValue(106);
                                                        this.WriteAlarmToModbus(106);

                                                        Halt("Error:  Failed to move FW Home");

                                                    }
                                                }
                                                else
                                                {
                                                    Halt("Error:  Failed to move FW to EC2");

                                                }




                                            }
                                        }
                                        else if (fwECend == 3)
                                        {
                                            //Logger.WriteLogFile(   "EC " + ECend.ToString() + " (destination) motor position, after move = " + position.ToString());
                                            if (position.ToString().Contains(Properties.Settings.Default.FWEC3.ToString()))
                                            {
                                                UpdateOperationMessage("Move FW to EC3 Pass");
                                                UpdateFilterWheelMessage("FW at EC3 (" + Properties.Settings.Default.FWEC3.ToString() + ")");

                                                AcquisitionControl.SetEnergyConditionPrevious(3);
                                                AcquisitionControl.SetCounter(0);
                                                AcquisitionControl.SetState(28);
                                            }
                                            else
                                            {
                                                if (fwRetry == 0)
                                                {
                                                    Logger.WriteErrorFile("Error: (27) Unable to move Filter Wheel to EC3.");
                                                    Logger.WriteLogFile("Error: (27) Unable to move Filter Wheel to EC3.");

                                                    Logger.WriteLogFile("WARNING:  incorrect position returned.  Sending FW home");
                                                    UpdateOperationMessage("Unable to move FW to EC3, moving FW home");

                                                    int homeCount = 0;
                                                    int retVal = FAIL;
                                                    do
                                                    {
                                                        retVal = AcquisitionControl.MoveFWHome(SerialManager, this);
                                                        if (retVal != PASS)
                                                        {
                                                            homeCount++;
                                                        }
                                                    } while (homeCount < 3 && retVal == FAIL);
                                                    if (retVal == PASS)
                                                    {
                                                        AcquisitionControl.SetEnergyConditionPrevious(0);

                                                        //send FW to correct EC....
                                                        fwECstart = AcquisitionControl.GetEnergyConditionPrevious();
                                                        fwECend = AcquisitionControl.GetEnergyCondition();

                                                        string status = "Move Filter Wheel to EC " + fwECend.ToString() + " retry.";
                                                        UpdateOperationMessage(status);

                                                        fwRetry = 1;
                                                        AcquisitionControl.SetCounter(1);
                                                        AcquisitionControl.SetState(26);
                                                    }
                                                    else
                                                    {
                                                        AcquisitionControl.SetAlarmValue(106);
                                                        this.WriteAlarmToModbus(106);
                                                        Halt("Error:  Failed to move FW Home");

                                                    }
                                                }
                                                else
                                                {
                                                    Halt("Error:  Failed to move FW to EC3");

                                                }



                                            }
                                        }



                                        else if (fwECend == 4)
                                        {
                                            if (fwRetry == 0)
                                            {
                                                //Logger.WriteLogFile(   "EC " + ECend.ToString() + " (destination) motor position, after move = " + position.ToString());
                                                if (position.ToString().Contains(Properties.Settings.Default.FWEC4.ToString()))
                                                {
                                                    UpdateOperationMessage("Move FW to EC4 Pass");
                                                    UpdateFilterWheelMessage("FW at EC4 (" + Properties.Settings.Default.FWEC2.ToString() + ")");
                                                    AcquisitionControl.SetEnergyConditionPrevious(4);
                                                    AcquisitionControl.SetCounter(0);
                                                    AcquisitionControl.SetState(28);
                                                }
                                                else
                                                {
                                                    Logger.WriteErrorFile("Error (27) Unable to move Filter Wheel to EC4.");
                                                    Logger.WriteLogFile("Error (27) Unable to move Filter Wheel to EC4.");

                                                    Logger.WriteLogFile("WARNING:  incorrect position returned.  Sending FW home");
                                                    UpdateOperationMessage("Unable to move FW to EC4, moving FW home");

                                                    int homeCount = 0;
                                                    int retVal = FAIL;
                                                    do
                                                    {
                                                        retVal = AcquisitionControl.MoveFWHome(SerialManager, this);
                                                        if (retVal != PASS)
                                                        {
                                                            homeCount++;
                                                        }
                                                    } while (homeCount < 3 && retVal == FAIL);
                                                    if (retVal == PASS)
                                                    {
                                                        AcquisitionControl.SetEnergyConditionPrevious(0);

                                                        //send FW to correct EC....
                                                        fwECstart = AcquisitionControl.GetEnergyConditionPrevious();
                                                        fwECend = AcquisitionControl.GetEnergyCondition();

                                                        string status = "Move Filter Wheel to EC " + fwECend.ToString() + " retry.";
                                                        UpdateOperationMessage(status);

                                                        fwRetry = 1;
                                                        AcquisitionControl.SetCounter(1);
                                                        AcquisitionControl.SetState(26);

                                                    }
                                                    else
                                                    {
                                                        AcquisitionControl.SetAlarmValue(106);
                                                        this.WriteAlarmToModbus(106);
                                                        Halt("Error:  Failed to move FW Home");


                                                    }
                                                }
                                            }
                                            else
                                            {
                                                Halt("Error:  Failed to move FW to EC4");

                                            }



                                        }
                                    }
                                    else
                                    {
                                        Logger.WriteLogFile("Unable to move FW.  Sending FW home.");

                                        int homeCount = 0;
                                        int retVal = FAIL;
                                        do
                                        {
                                            retVal = AcquisitionControl.MoveFWHome(SerialManager, this);
                                            if (retVal != PASS)
                                            {
                                                homeCount++;
                                            }
                                        } while (homeCount < 3 && retVal == FAIL);

                                        if (retVal == PASS)
                                        {
                                            AcquisitionControl.SetEnergyConditionPrevious(0);

                                            //send FW to correct EC....
                                            fwECstart = AcquisitionControl.GetEnergyConditionPrevious();
                                            fwECend = AcquisitionControl.GetEnergyCondition();

                                            string status = "Move Filter Wheel to EC " + fwECend.ToString() + " retry.";

                                            fwRetry = 1;
                                            AcquisitionControl.SetCounter(1);
                                            AcquisitionControl.SetState(26);

                                        }
                                        else
                                        {
                                            AcquisitionControl.SetAlarmValue(106);
                                            this.WriteAlarmToModbus(106);

                                            Halt("Error:  Failed to move FW Home.");

                                        }
                                    }
                                }
                            }
                            break;


                        case 28:
                            {

                                bool ec1, ec2, ec3, ec4;
                                GetActiveNormalECs(out ec1, out ec2, out ec3, out ec4);



                                if (AcquisitionControl.GetECAL() > 0  || AcquisitionControl.GetUpscale()>0)
                                {

                                    ec1 = true;
                                    ec2 = true;
                                    ec3 = true;
                                    ec4 = false;
                                }


                                if (AcquisitionControl.GetCounter() == 0)
                                {

                                    Logger.WriteLogFile(   "state = 28. Start and Wait for ec time to expire.");
                                    //clear retry flag for FW
                                    fwRetry = 0;
                                }
                                //wait for EC time to expire....
                                //determine EC
                                int CurrentEC = AcquisitionControl.GetEnergyCondition();





                                if (AcquisitionControl.GetECAL() > 0)
                                {
                                    Logger.WriteLogFile("AcquisitionControl.counter = " + AcquisitionControl.GetCounter());
                                    if (AcquisitionControl.GetCounter() <= 2)
                                    {
                                        ec1time = DateTime.Now.AddSeconds(Properties.Settings.Default.EcalTime);
                                        TimeSpan time = ec1time - DateTime.Now;
                                        Logger.WriteLogFile(   "EC1 ECAL start time: " + DateTime.Now.ToString());

                                        float kV;
                                        string kVs;
                                        if (mtbIOActualkV.InvokeRequired)
                                        {
                                            mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                        }
                                        else
                                        {
                                            actualValueV = mtbIOActualkV.Text;
                                        }
                                        kVs = actualValueV;
                                        kV = Convert.ToSingle(kVs);
                                        bool boolresponse_kV = myxrsfp.Send_kV[kV];
                                        float uA;
                                        string uAs;
                                        if (mtbIOActualuA.InvokeRequired)
                                        {
                                            mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                        }
                                        else
                                        {
                                            actualValueI = mtbIOActualuA.Text;
                                        }
                                        uAs = actualValueI;
                                        uA = Convert.ToSingle(uAs);
                                        bool boolresponse_uA = myxrsfp.Send_uA[uA];


                                        //AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) - PRESET_END_ADJUST_ECAL);
                                        AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) + (time.Hours * 3600) - PRESET_END_ADJUST_ECAL);

                                        Thread.Sleep(3000);
                                        float deadTime = 0;

                                        if (Properties.Settings.Default.EC1AC.Contains("ON"))
                                        {

                                            AcquisitionControl.AutoCurrent((readInputCurrent * 2000.0 / 10.0), (readInputVoltage * 50.0 / 10.0), m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);

                                        }
                                        else
                                        {
                                            deadTime = AcquisitionControl.GetDeadTime();
                                        }
                                        //float kV;
                                        //string kVs;
                                        if (mtbIOActualkV.InvokeRequired)
                                        {
                                            mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                        }
                                        else
                                        {
                                            actualValueV = mtbIOActualkV.Text;
                                        }
                                        kVs = actualValueV;
                                        kV = Convert.ToSingle(kVs);
                                        boolresponse_kV = myxrsfp.Send_kV[kV];
                                        //float uA;
                                        //string uAs;
                                        if (mtbIOActualuA.InvokeRequired)
                                        {
                                            mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                        }
                                        else
                                        {
                                            actualValueI = mtbIOActualuA.Text;
                                        }
                                        uAs = actualValueI;
                                        uA = Convert.ToSingle(uAs);
                                        boolresponse_uA = myxrsfp.Send_uA[uA];

                                        Logger.WriteLogFile(   "ECAL dead time = " + deadTime.ToString("F2"));







                                        AcquisitionControl.SetCounter(AcquisitionControl.GetCounter()+1 );
                                    }
                                    //displayActionQueue.Enqueue("Waiting for EC1 to end...");
                                    DateTime AcquisitionStartTime = AcquisitionControl.GetAcquireStartTime();

                                    var TimeRemaining = ec1time - System.DateTime.Now;

                                    string msg;
                                    msg = "Time Remaining ECAL EC1 = " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2");
                                    if (TimeRemaining.Hours == 0 && TimeRemaining.Minutes==0 && TimeRemaining.Seconds % 10 == 0)
                                    {
                                        Logger.WriteLogFile(   msg);
                                    }
                                    UpdateOperationMessage(msg);
                                    if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
                                    {
                                        UpdateOperationMessage("End Ecal");
                                        //Logger.WriteLogFile(   "End EC1, save spec Raw and Adj, calling auto analyze.");

                                        float FGainReturn = 0f;

                                        float FOffsetReturn = 0f;

                                        bool result = AcquisitionControl.PerformEcal(out FGainReturn, out FOffsetReturn,"c:/temp/acquisition.txt");

                                        Logger.WriteLogFile(   "Perform Ecal return value = " + result.ToString());



                                        AcquisitionControl.SaveCESSpectrumRaw("c:/Ecal_Data_Raw", "sp_data", 1);
                                        AcquisitionControl.AdjustSpectrum();

                                        AcquisitionControl.SaveCESSpectrum("c:/Ecal_Data", "sp_data", 1);


                                        //if(FOffsetReturn<0 && FOffsetReturn>-50.0)
                                        //if(FOffsetReturn > -50.0 && FOffsetReturn <50.0 )  //make symmetrical???  was <0
                                        if (FOffsetReturn > -100.0 && FOffsetReturn < 100.0)  //double the windows as slower detectors are coming in at -50.5 11.12.2019 1700                                        {
                                        { 
                                                if (FGainReturn>-100.0 && FGainReturn<100.0)
                                                {
                                                //
                                                //save FWHM value from Cr and Nb
                                                // a Cross code change is necessary for Cr and Nb values
                                                //float fcr;
                                                //float fnb;
                                                //AcquisitionControl.ReadFWHM(out fcr, out fnb);
                                                //

                                                AcquisitionControl.SetCounter(0);
                                                AcquisitionControl.SetState(29);

                                            }
                                            else
                                            {

                                                Logger.WriteLogFile(   "Invalid Ecal Gain.  Out of Range.  Gain = " +FGainReturn.ToString("F2"));
                                                Logger.WriteLogFile(   "Setting Gain and offset to default values.");
                                                //need to set gain and offset to default reasonable value
                                                //write to cross via com interface and to the cross ini file
                                                //BETTER:  update to use the "last known good value" !
                                                AcquisitionControl.DefaultGainAndOffset();


                                            }
                                        }
                                        else
                                        {
                                            Logger.WriteLogFile(   "Invalid Ecal Offset.  Out of Range.  Offset = " + FOffsetReturn.ToString("F2"));
                                            Logger.WriteLogFile(   "Setting Gain and offset to default values.");
                                            //need to set gain and offset to default reasonable value
                                            //write to cross via com interface and to the cross ini file
                                            AcquisitionControl.DefaultGainAndOffset();

                                        }

                                        if (AcquisitionControl.GetCounter()>=3)
                                        {
                                            AcquisitionControl.SetAlarmValue(109);
                                            this.WriteAlarmToModbus(109);

                                            Halt("Invalid Ecal.  Gain = " + FGainReturn.ToString("F2") + "  Offset = " + FOffsetReturn.ToString("F2"));
                                            Logger.WriteLogFile(   "Setting Gain and offset to default values.");  
                                            AcquisitionControl.DefaultGainAndOffset();
                                        }

                                    }


                                }
                                else
                                {


                                    //normal run
                                    if (CurrentEC == 1 && ec1 == true)
                                    {
                                        if (AcquisitionControl.GetCounter() == 0)
                                        {
                                            DateTime ec1time = AcquisitionControl.GetEC1EndTime();
                                            TimeSpan time = ec1time - DateTime.Now;
                                            Logger.WriteLogFile(   "EC1 start time: " + DateTime.Now.ToString());

                                            float kV;
                                            string kVs;
                                            //tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Text = Tnistvalue.ToString(); }));//sets the value
                                            //string actualValue;
                                            if (mtbIOActualkV.InvokeRequired)
                                            {
                                                mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                            }
                                            else
                                            {
                                                actualValueV = mtbIOActualkV.Text;
                                            }
                                            kVs = actualValueV;
                                            kV = Convert.ToSingle(kVs);
                                            bool boolresponse_kV = myxrsfp.Send_kV[kV];
                                            float uA;
                                            string uAs;
                                            if (mtbIOActualuA.InvokeRequired)
                                            {
                                                mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                            }
                                            else
                                            {
                                                actualValueI = mtbIOActualuA.Text;
                                            }
                                            uAs = actualValueI;
                                            uA = Convert.ToSingle(uAs);
                                            bool boolresponse_uA = myxrsfp.Send_uA[uA];



                                            //AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) - PRESET_END_ADJUST);
                                            AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) + (time.Hours * 3600) -PRESET_END_ADJUST);

                                            Thread.Sleep(3000);
                                            float deadTime = 0;
                                            if (Properties.Settings.Default.EC1AC.Contains("ON"))
                                            {

                                                AcquisitionControl.AutoCurrent((readInputCurrent * 2000.0 / 10.0), (readInputVoltage * 50.0 / 10.0), m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                                                deadTime = AcquisitionControl.GetDeadTime();

                                            }
                                            else
                                            {
                                                deadTime = AcquisitionControl.GetDeadTime();
                                            }
                                            //float kV;
                                            //string kVs;
                                            //tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Text = Tnistvalue.ToString(); }));//sets the value
                                            //string actualValue;
                                            if (mtbIOActualkV.InvokeRequired)
                                            {
                                                mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                            }
                                            else
                                            {
                                                actualValueV = mtbIOActualkV.Text;
                                            }
                                            kVs = actualValueV;
                                            kV = Convert.ToSingle(kVs);
                                            boolresponse_kV = myxrsfp.Send_kV[kV];
                                            //float uA;
                                            //string uAs;
                                            if (mtbIOActualuA.InvokeRequired)
                                            {
                                                mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                            }
                                            else
                                            {
                                                actualValueI = mtbIOActualuA.Text;
                                            }
                                            uAs = actualValueI;
                                            uA = Convert.ToSingle(uAs);
                                            boolresponse_uA = myxrsfp.Send_uA[uA];





                                            Logger.WriteLogFile(   "EC1 deadTime = " + deadTime.ToString("F2"));
                                            AcquisitionControl.SetCounter(1);



                                        }
                                        //displayActionQueue.Enqueue("Waiting for EC1 to end...");
                                        DateTime AcquisitionStartTime = AcquisitionControl.GetAcquireStartTime();
                                        var TimeRemaining = AcquisitionControl.GetEC1EndTime() - System.DateTime.Now;

                                        //displayActionQueue.Enqueue("Time Remaining EC1 = " + TimeRemaining.Hours.ToString() + ":" + TimeRemaining.Minutes.ToString() + ":" + TimeRemaining.Seconds.ToString());
                                        string msg;
                                        msg = "Time Remaining EC1 = " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2");
                                        if (TimeRemaining.Hours == 0 && TimeRemaining.Minutes == 0 && TimeRemaining.Seconds % 10 == 0)
                                        {
                                            Logger.WriteLogFile(   msg);
                                        }
                                        UpdateOperationMessage(msg);

                                        if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
                                        {
                                            //displayActionQueue.Enqueue("End EC1.");

                                            if(ec2==false && ec3==false && ec4==false)
                                            {
                                                //if (ec4 == false)
                                                //{
                                                    //ec3 ended--so get flow volume to be saved in temporary storage   

                                                    double value = AcquisitionControl.GetFlowVolume();
                                                    Logger.WriteLogFile("(28) get flow volume (END EC3) = " + value.ToString("F3"));
                                                    Logger.WriteLogFile("(28) saving value to item location....");
                                                    AcquisitionControl.SetItem(value);

                                                    value = AcquisitionControl.GetItem();
                                                    Logger.WriteLogFile("(28) read back flow vol item location =" + value.ToString("F3"));

                                                    //RECALCULATE HERE FOR NEXT ACQUISITION
                                                    if (AcquisitionControl.GetSamplePeriod() == 77)
                                                    {
                                                        AcquisitionStartTime.AddMinutes(15);
                                                    }
                                                    else
                                                    {
                                                        AcquisitionStartTime.AddMinutes(AcquisitionControl.GetSamplePeriod());
                                                    }
                                                    AcquisitionControl.SetAcquireStartTime(AcquisitionStartTime);

                                                    //AcquisitionControl.SetCounter(2);
                                                    //}
                                                //}

                                            }


                                            UpdateOperationMessage("End EC1");
                                            Logger.WriteLogFile(   "End EC1, save spec Raw and Adj, calling auto analyze.");




                                            AcquisitionControl.SaveCESSpectrumRaw("c:/spectrum_data_raw", "sp_data", 1);
                                            AcquisitionControl.AdjustSpectrum();

                                            AcquisitionControl.SaveCESSpectrum("c:/spectrum_data", "sp_data", 1);

                                            AcquisitionControl.AutoAnalyze();
                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(29);

                                        }

                                    }
                                    else if (/*AcquisitionControl.GetEC2Enabled() == true && */CurrentEC == 2 && ec2 == true)
                                    {


                                        if (AcquisitionControl.GetCounter() == 0)
                                        {
                                            DateTime ec2time = AcquisitionControl.GetEC2EndTime();
                                            TimeSpan time = ec2time - DateTime.Now;
                                            Logger.WriteLogFile(   "EC2 start time: " + DateTime.Now.ToString());

                                            float kV;
                                            string kVs;

                                            //read from GUI
                                            if (mtbIOActualkV.InvokeRequired)
                                            {
                                                mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                            }
                                            else
                                            {
                                                actualValueV = mtbIOActualkV.Text;
                                            }

                                            kVs = actualValueV;
                                            kV = Convert.ToSingle(kVs);
                                            bool boolresponse_kV = myxrsfp.Send_kV[kV];
                                            float uA;
                                            string uAs;
                                            if (mtbIOActualuA.InvokeRequired)
                                            {
                                                mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                            }
                                            else
                                            {
                                                actualValueI = mtbIOActualuA.Text;
                                            }
                                            uAs = actualValueI;
                                            uA = Convert.ToSingle(uAs);
                                            bool boolresponse_uA = myxrsfp.Send_uA[uA];


                                            //AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) - PRESET_END_ADJUST);
                                            AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) + (time.Hours * 3600)-PRESET_END_ADJUST);


                                            Thread.Sleep(3000);
                                            float deadTime = 0;
                                            if (Properties.Settings.Default.EC2AC.Contains("ON"))
                                            {

                                                AcquisitionControl.AutoCurrent((readInputCurrent * 2000.0 / 10.0), (readInputVoltage * 50.0 / 10.0), m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                                                deadTime = AcquisitionControl.GetDeadTime();
                                            }
                                            else
                                            {
                                                deadTime = AcquisitionControl.GetDeadTime();
                                            }

                                            //float kV;
                                            //string kVs;

                                            //read from GUI
                                            if (mtbIOActualkV.InvokeRequired)
                                            {
                                                mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                            }
                                            else
                                            {
                                                actualValueV = mtbIOActualkV.Text;
                                            }

                                            kVs = actualValueV;
                                            kV = Convert.ToSingle(kVs);
                                            boolresponse_kV = myxrsfp.Send_kV[kV];
                                            //float uA;
                                            //string uAs;
                                            if (mtbIOActualuA.InvokeRequired)
                                            {
                                                mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                            }
                                            else
                                            {
                                                actualValueI = mtbIOActualuA.Text;
                                            }
                                            uAs = actualValueI;
                                            uA = Convert.ToSingle(uAs);
                                            boolresponse_uA = myxrsfp.Send_uA[uA];



                                            Logger.WriteLogFile(   "EC2 dead time = " + deadTime.ToString("F2"));


                                            AcquisitionControl.SetCounter(1);

                                        }

                                        //time to wait 2
                                        //displayActionQueue.Enqueue("Waiting for EC2 to end...");
                                        DateTime AcquisitionStartTime = AcquisitionControl.GetAcquireStartTime();

                                        var TimeRemaining = AcquisitionControl.GetEC2EndTime() - System.DateTime.Now;
                                        string msg;
                                        msg = "Time Remaining EC2 = " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2");



                                        UpdateOperationMessage(msg);

                                        if (TimeRemaining.Hours ==0 && TimeRemaining.Minutes == 0 && TimeRemaining.Seconds % 10 == 0)
                                        {
                                            Logger.WriteLogFile(   msg);
                                        }

                                        //Logger.WriteLogFile(   msg);

                                        if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
                                        {
                                            UpdateOperationMessage("End EC2");

                                            if (ec3 == false && ec4 == false)
                                            {
                                                //if (ec4 == false)
                                               //{
                                                    //ec3 ended--so get flow volume to be saved in temporary storage   

                                                    double value = AcquisitionControl.GetFlowVolume();
                                                    Logger.WriteLogFile("(28) get flow volume (END EC3) = " + value.ToString("F3"));
                                                    Logger.WriteLogFile("(28) saving value to item location....");
                                                    AcquisitionControl.SetItem(value);

                                                    value = AcquisitionControl.GetItem();
                                                    Logger.WriteLogFile("(28) read back flow vol item location =" + value.ToString("F3"));

                                                    //RECALCULATE HERE FOR NEXT ACQUISITION
                                                    if (AcquisitionControl.GetSamplePeriod() == 77)
                                                    {
                                                        AcquisitionStartTime.AddMinutes(15);
                                                    }
                                                    else
                                                    {
                                                        AcquisitionStartTime.AddMinutes(AcquisitionControl.GetSamplePeriod());
                                                    }
                                                    AcquisitionControl.SetAcquireStartTime(AcquisitionStartTime);

                                                    //AcquisitionControl.SetCounter(2);
                                                    //}
                                                //}

                                            }



                                            Logger.WriteLogFile(   "End EC2, save spec, calling auto analyze.");



                                            AcquisitionControl.SaveCESSpectrumRaw("c:/spectrum_data_raw", "sp_data", 2);
                                            AcquisitionControl.AdjustSpectrum();

                                            AcquisitionControl.SaveCESSpectrum("c:/spectrum_data", "sp_data", 2);

                                            AcquisitionControl.AutoAnalyze();
                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(29);
                                        }

                                    }

                                    else if (/*AcquisitionControl.GetEC3Enabled() == true &&*/ CurrentEC == 3 && ec3 == true)
                                    {

                                        if (AcquisitionControl.GetCounter() == 0)
                                        {
                                            DateTime ec3time = AcquisitionControl.GetEC3EndTime();
                                            TimeSpan time = ec3time - DateTime.Now;
                                            Logger.WriteLogFile(   "EC3 start time: " + DateTime.Now.ToString());

                                            float kV;
                                            string kVs;
                                            if (mtbIOActualkV.InvokeRequired)
                                            {
                                                mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                            }
                                            else
                                            {
                                                actualValueV = mtbIOActualkV.Text;
                                            }
                                            kVs = actualValueV;
                                            kV = Convert.ToSingle(kVs);
                                            bool boolresponse_kV = myxrsfp.Send_kV[kV];
                                            float uA;
                                            string uAs;

                                            if (mtbIOActualuA.InvokeRequired)
                                            {

                                                mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                            }
                                            else
                                            {
                                                actualValueI = mtbIOActualuA.Text;
                                            }

                                            uAs = actualValueI;
                                            uA = Convert.ToSingle(uAs);
                                            bool boolresponse_uA = myxrsfp.Send_uA[uA];


                                            //AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) - PRESET_END_ADJUST);
                                            AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) + (time.Hours * 3600)-PRESET_END_ADJUST);

                                            Thread.Sleep(3000);
                                            float deadTime = 0;
                                            if (Properties.Settings.Default.EC3AC.Contains("ON"))
                                            {

                                                Logger.WriteLogFile(   "EC3 autocurrent = ON");
                                                AcquisitionControl.AutoCurrent((readInputCurrent * 2000.0 / 10.0), (readInputVoltage * 50.0 / 10.0), m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                                                deadTime = AcquisitionControl.GetDeadTime();
                                            }
                                            else
                                            {
                                                deadTime = AcquisitionControl.GetDeadTime();
                                            }

                                            //float kV;
                                            //string kVs;
                                            if (mtbIOActualkV.InvokeRequired)
                                            {
                                                mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                            }
                                            else
                                            {
                                                actualValueV = mtbIOActualkV.Text;
                                            }
                                            kVs = actualValueV;
                                            kV = Convert.ToSingle(kVs);
                                            boolresponse_kV = myxrsfp.Send_kV[kV];
                                            //float uA;
                                            //string uAs;

                                            if (mtbIOActualuA.InvokeRequired)
                                            {

                                                mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                            }
                                            else
                                            {
                                                actualValueI = mtbIOActualuA.Text;
                                            }

                                            uAs = actualValueI;
                                            uA = Convert.ToSingle(uAs);
                                            boolresponse_uA = myxrsfp.Send_uA[uA];



                                            Logger.WriteLogFile(   "EC3 dead time = " + deadTime.ToString("F2"));



                                            AcquisitionControl.SetCounter(1);

                                        }


                                        //time to wait 3
                                        DateTime AcquisitionStartTime = AcquisitionControl.GetAcquireStartTime();

                                        var TimeRemaining = AcquisitionControl.GetEC3EndTime() - System.DateTime.Now;
                                        string msg;
                                        msg = "Time Remaining EC3 = " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2");
                                        UpdateOperationMessage(msg);

                                        if (TimeRemaining.Hours == 0 && TimeRemaining.Minutes == 0 && TimeRemaining.Seconds % 10 == 0)
                                        {
                                            Logger.WriteLogFile(   msg);
                                        }

                                        //Logger.WriteLogFile(   msg);

                                        if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
                                        {


                                            if (ec4 == false)
                                            {
                                                //ec3 ended--so get flow volume to be saved in temporary storage   

                                                double value = AcquisitionControl.GetFlowVolume();
                                                Logger.WriteLogFile("(28) get flow volume (END EC3) = " + value.ToString("F3"));
                                                Logger.WriteLogFile("(28) saving value to item location....");
                                                AcquisitionControl.SetItem(value);

                                                value = AcquisitionControl.GetItem();
                                                Logger.WriteLogFile("(28) read back flow vol item location =" + value.ToString("F3"));

                                                //RECALCULATE HERE FOR NEXT ACQUISITION
                                                if (AcquisitionControl.GetSamplePeriod() == 77)
                                                {
                                                    AcquisitionStartTime.AddMinutes(15);
                                                }
                                                else
                                                {
                                                    AcquisitionStartTime.AddMinutes(AcquisitionControl.GetSamplePeriod());
                                                }
                                                AcquisitionControl.SetAcquireStartTime(AcquisitionStartTime);

                                                //AcquisitionControl.SetCounter(2);
                                                //}
                                            }
                                            UpdateOperationMessage("End EC3");

                                            Logger.WriteLogFile(   "End EC3, saving spec, calling auto analyze.");

                                            AcquisitionControl.SaveCESSpectrumRaw("c:/spectrum_data_raw", "sp_data", 3);
                                            AcquisitionControl.AdjustSpectrum();
                                            AcquisitionControl.SaveCESSpectrum("c:/spectrum_data", "sp_data", 3);

                                            AcquisitionControl.AutoAnalyze();
                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(29);

                                        }

                                    }


                                    else if (/*AcquisitionControl.GetEC4Enabled() == true &&*/ CurrentEC == 4 && ec4 == true)
                                    {




                                        if (AcquisitionControl.GetCounter() == 0)
                                        {
                                            DateTime ec4time = AcquisitionControl.GetEC4EndTime();
                                            TimeSpan time = ec4time - DateTime.Now;
                                            Logger.WriteLogFile(   "EC4 start time: " + DateTime.Now.ToString());

                                            float kV;
                                            string kVs;
                                            if (mtbIOActualkV.InvokeRequired)
                                            {
                                                mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                            }
                                            else
                                            {
                                                actualValueV = mtbIOActualkV.Text;
                                            }
                                            kVs = actualValueV;
                                            kV = Convert.ToSingle(kVs);
                                            bool boolresponse_kV = myxrsfp.Send_kV[kV];
                                            float uA;
                                            string uAs;

                                            if (mtbIOActualuA.InvokeRequired)
                                            {

                                                mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                            }
                                            else
                                            {
                                                actualValueI = mtbIOActualuA.Text;
                                            }

                                            uAs = actualValueI;
                                            uA = Convert.ToSingle(uAs);
                                            bool boolresponse_uA = myxrsfp.Send_uA[uA];


                                            //AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) - PRESET_END_ADJUST);
                                            AcquisitionControl.StartXrsfpAcquisition(time.Seconds + (time.Minutes * 60) + (time.Hours * 3600) - PRESET_END_ADJUST);

                                            Thread.Sleep(3000);
                                            float deadTime = 0;
                                            if (Properties.Settings.Default.EC4AC.Contains("ON"))
                                            {

                                                Logger.WriteLogFile(   "EC4 autocurrent = ON");
                                                AcquisitionControl.AutoCurrent((readInputCurrent * 2000.0 / 10.0), (readInputVoltage * 50.0 / 10.0), m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                                                deadTime = AcquisitionControl.GetDeadTime();
                                            }
                                            else
                                            {
                                                deadTime = AcquisitionControl.GetDeadTime();
                                            }

                                            //float kV;
                                            //string kVs;
                                            if (mtbIOActualkV.InvokeRequired)
                                            {
                                                mtbIOActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbIOActualkV.Text; }));
                                            }
                                            else
                                            {
                                                actualValueV = mtbIOActualkV.Text;
                                            }
                                            kVs = actualValueV;
                                            kV = Convert.ToSingle(kVs);
                                            boolresponse_kV = myxrsfp.Send_kV[kV];
                                            //float uA;
                                            //string uAs;

                                            if (mtbIOActualuA.InvokeRequired)
                                            {

                                                mtbIOActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbIOActualuA.Text; }));
                                            }
                                            else
                                            {
                                                actualValueI = mtbIOActualuA.Text;
                                            }

                                            uAs = actualValueI;
                                            uA = Convert.ToSingle(uAs);
                                            boolresponse_uA = myxrsfp.Send_uA[uA];



                                            Logger.WriteLogFile(   "EC4 dead time = " + deadTime.ToString("F2"));



                                            AcquisitionControl.SetCounter(1);

                                        }


                                        //time to wait 4
                                        DateTime AcquisitionStartTime = AcquisitionControl.GetAcquireStartTime();

                                        var TimeRemaining = AcquisitionControl.GetEC4EndTime() - System.DateTime.Now;
                                        string msg;
                                        msg = "Time Remaining EC4 = " + TimeRemaining.Hours.ToString("D2") + ":" + TimeRemaining.Minutes.ToString("D2") + ":" + TimeRemaining.Seconds.ToString("D2");
                                        UpdateOperationMessage(msg);

                                        if (TimeRemaining.Hours == 0 && TimeRemaining.Minutes == 0 && TimeRemaining.Seconds % 10 == 0)
                                        {
                                            Logger.WriteLogFile(   msg);
                                        }

                                        //Logger.WriteLogFile(   msg);

                                        if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
                                        {
                                            
                                             
                                            //ec4 ended--so get flow volume to be saved in temporary storage   
                                            //if()
                                            //{ 
                                            double value = AcquisitionControl.GetFlowVolume();
                                            Logger.WriteLogFile("(28) get flow volume (END EC4) = " + value.ToString("F3"));
                                            Logger.WriteLogFile("(28) saving value to item location....");
                                            AcquisitionControl.SetItem(value);

                                            value = AcquisitionControl.GetItem();
                                            Logger.WriteLogFile("(28) read back flow vol item location =" + value.ToString("F3"));

                                            //RECALCULATE HERE FOR NEXT ACQUISITION     --
                                            if (AcquisitionControl.GetSamplePeriod() == 77)
                                            {
                                                AcquisitionStartTime.AddMinutes(15);
                                            }
                                            else
                                            {
                                                AcquisitionStartTime.AddMinutes(AcquisitionControl.GetSamplePeriod());
                                            }
                                            AcquisitionControl.SetAcquireStartTime(AcquisitionStartTime);

                                            //}

                                            
                                            UpdateOperationMessage("End EC4");

                                            Logger.WriteLogFile(   "End EC4, saving spec, calling auto analyze.");

                                            AcquisitionControl.SaveCESSpectrumRaw("c:/spectrum_data_raw", "sp_data", 4);
                                            AcquisitionControl.AdjustSpectrum();
                                            AcquisitionControl.SaveCESSpectrum("c:/spectrum_data", "sp_data", 4);

                                            AcquisitionControl.AutoAnalyze();
                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(29);

                                        }


                                    }


                                }

                            }
                            break;

                        case 29:
                            {

                                bool ec1, ec2, ec3, ec4;
                                GetActiveNormalECs(out ec1, out ec2, out ec3, out ec4);



                                Logger.WriteLogFile(   "state = 29.  Wait for Analysis. ");
                                UpdateOperationMessage("Perform Analysis");
                                // wait for Auto Analyze to complete
                                int AACounter;
                                if (AcquisitionControl.GetECAL() > 0)
                                {

                                    AACounter = AcquisitionControl.GetCounter();
                                    AACounter++;
                                    AcquisitionControl.SetCounter(AACounter);
                                    if (AACounter == 8)  //this is the time to complete auto analyze
                                    {
                                        AcquisitionControl.SetEC1Done(true);
                                        UpdateOperationMessage("ECAL analysis done");


                                        AcquisitionControl.SetEnergyCondition(1);
                                        AcquisitionControl.SetECAL(2); //ECAL done.    //two means done   state 21 advances to upscale
                                        AcquisitionControl.SetState(21);
                                        AcquisitionControl.SetCounter(0);


                                        //may add EC4,5, ect here
                                        //done with all EC in acquisition

                                        //   AcquisitionControl.SetCounter(0);
                                        //   AcquisitionControl.SetState(30);
                                        //}


                                    }
                                }
                                else
                                {
                                    if(AcquisitionControl.GetECAL()>0 || AcquisitionControl.GetUpscale()>0)
                                    {
                                        ec1 = true;
                                        ec2 = true;
                                        ec3 = true;
                                        ec4 = false;
                                    }


                                    //normal run logic here:
                                    if (AcquisitionControl.GetEnergyCondition() == 1 && ec1 == true)
                                    {

                                        AACounter = AcquisitionControl.GetCounter();
                                        AACounter++;
                                        AcquisitionControl.SetCounter(AACounter);
                                        int exists=0;
                                        exists = CheckFileExists("c:\\Process_Data\\data1.txt");
                                        if (AACounter >= 7 || exists==1)  //this is the time to complete auto analyze   or find data1.txt 
                                        {
                                            AcquisitionControl.SetEC1Done(true);
                                            UpdateOperationMessage("EC1 analysis done");
                                            Logger.WriteLogFile(   "state = 29 (wait for autoanalyze to complete) ec1 done -- advance energy condition... ");
                                            UpdateOperationMessage("Advance Energy Condition");

                                            if (ec2 == true)
                                            {
                                                AcquisitionControl.SetEnergyCondition(2);
                                                AcquisitionControl.SetState(25);
                                                AcquisitionControl.SetCounter(0);
                                            }
                                            else if (ec3 == true)
                                            {
                                                AcquisitionControl.SetEnergyCondition(3);
                                                AcquisitionControl.SetState(25);
                                                AcquisitionControl.SetCounter(0);
                                            }
                                            else if (ec4 == true)
                                            {
                                                AcquisitionControl.SetEnergyCondition(4);
                                                AcquisitionControl.SetState(25);
                                                AcquisitionControl.SetCounter(0);
                                            }

                                            else
                                            {
                                                AcquisitionControl.SetCounter(0);
                                                AcquisitionControl.SetState(30);
                                            }

                                        }
                                    }
                                    else if (AcquisitionControl.GetEnergyCondition() == 2 && ec2 == true)
                                    {
                                        AACounter = AcquisitionControl.GetCounter();
                                        AACounter++;
                                        AcquisitionControl.SetCounter(AACounter);

                                        int exists=0;
                                        exists = CheckFileExists("c:\\Process_Data\\data2.txt");

                                        if (AACounter >= 7 || exists ==1)
                                        {
                                            AcquisitionControl.SetEC2Done(true);
                                            UpdateOperationMessage("EC2 analysis done");

                                            UpdateOperationMessage("Advance Energy Condition");

                                            if (ec3 == true)
                                            {
                                                AcquisitionControl.SetEnergyCondition(3);
                                                AcquisitionControl.SetState(25);
                                                AcquisitionControl.SetCounter(0);
                                            }
                                            else if (ec4 == true)
                                            {
                                                AcquisitionControl.SetEnergyCondition(4);
                                                AcquisitionControl.SetState(25);
                                                AcquisitionControl.SetCounter(0);
                                            }

                                            else
                                            {
                                                AcquisitionControl.SetCounter(0);
                                                AcquisitionControl.SetState(30);
                                            }





                                            //if (AcquisitionControl.GetEC3Enabled() == true)
                                            //{
                                            //    Logger.WriteLogFile(   "EC2 done, EC = EC3.");
                                            //    UpdateOperationMessage("Advance to EC3.");

                                            //    AcquisitionControl.SetEnergyCondition(3);
                                            //    AcquisitionControl.SetState(25);
                                            //    AcquisitionControl.SetCounter(0);
                                            //}
                                            //else
                                            //{
                                            //    //done with all EC in acquisition
                                            //    UpdateOperationMessage("All EC done (EC3 disabled)");
                                            //    Logger.WriteLogFile(   "all EC done, state = 30.");
                                            //    AcquisitionControl.SetCounter(0);
                                            //    AcquisitionControl.SetState(30);
                                            //}

                                        }


                                    }
                                    else if (AcquisitionControl.GetEnergyCondition() == 3 && ec3 == true /*&& AcquisitionControl.GetEC3Done() == false*/)
                                    {
                                        AACounter = AcquisitionControl.GetCounter();
                                        AACounter++;
                                        AcquisitionControl.SetCounter(AACounter);

                                        int exists = 0;
                                        exists = CheckFileExists("c:\\Process_Data\\data3.txt");

                                        if (AACounter >= 7 || exists == 1)
                                        {
                                            AcquisitionControl.SetEC3Done(true);
                                            UpdateOperationMessage("EC3 analysis done");

                                            UpdateOperationMessage("Advance Energy Condition");

                                            if (ec4 == true)
                                            {
                                                AcquisitionControl.SetEnergyCondition(4);
                                                AcquisitionControl.SetState(25);
                                                AcquisitionControl.SetCounter(0);
                                            }
                                            else
                                            {
                                                //add done
                                                AcquisitionControl.SetCounter(0);
                                                AcquisitionControl.SetState(30);
                                            }


                                        }
                                    }
                                    else if (AcquisitionControl.GetEnergyCondition() == 4 && ec4 == true /*&& AcquisitionControl.GetEC3Done() == false*/)
                                    {
                                        AACounter = AcquisitionControl.GetCounter();
                                        AACounter++;
                                        AcquisitionControl.SetCounter(AACounter);

                                        int exists = 0;
                                        exists = CheckFileExists("c:\\Process_Data\\data4.txt");

                                        if (AACounter >= 7 || exists == 1)
                                        {
                                            AcquisitionControl.SetEC4Done(true);
                                            UpdateOperationMessage("EC4 analysis done");

                                            UpdateOperationMessage("Advance Energy Condition");

                                            //if (ec4 == true)
                                            //{
                                            //    AcquisitionControl.SetEnergyCondition(4);
                                            //    AcquisitionControl.SetState(25);
                                            //    AcquisitionControl.SetCounter(0);
                                            //}
                                            //else
                                            //{

                                            AcquisitionControl.SetCounter(0);
                                            AcquisitionControl.SetState(30);
                                            //                                                }


                                        }


                                    }


                                    

                                }
                                break;
                            }
                        case 30:
                            {

                                Logger.WriteLogFile(   "state = 30.  Turn Pump Off");
                                AcquisitionControl.PumpOff(m_oWorkerPump);
                                //pump off triggers the volume value to be saved.
                                UpdateOperationMessage("Pump off");

                                Logger.WriteLogFile(   "state = 30.  Set flow volume to zero.");
                                AcquisitionControl.SetFlowVolume(0);
                                SetModbusPumpActive(0);

                                AcquisitionControl.SetCounter(0);
                                AcquisitionControl.SetState(31);

                                break;

                            }

                        case 31:
                            {

                                bool ec1, ec2, ec3, ec4;
                                GetActiveNormalECs(out ec1, out ec2, out ec3, out ec4);

                                //poll for output file exists -- up to to 10 seconds to give analysis program time to generate output
                                int checkForOutputFile1 = 0;
                                int checkForOutputFile2 = 0;
                                int checkForOutputFile3 = 0;
                                int checkForOutputFile4 = 0;
                                if (ec1 == true)
                                {
                                    checkForOutputFile1 = PollFileExists("C:\\process_data\\data1.txt");
                                    if(checkForOutputFile1==0)
                                    {
                                         Halt("No Data1 file found.");
                                    }
                                }
                                if (ec2 == true)
                                {
                                    checkForOutputFile2 = PollFileExists("C:\\process_data\\data2.txt");
                                    if (checkForOutputFile2 == 0)
                                    {
                                        Halt("No Data2 file found.");
                                    }

                                }

                                if (ec3 == true)
                                {
                                    checkForOutputFile3 = PollFileExists("C:\\process_data\\data3.txt");
                                    if (checkForOutputFile3 == 0)
                                    {
                                        Halt("No Data3 file found.");
                                    }
                                }
                                if (ec4 == true)
                                {
                                    checkForOutputFile4 = PollFileExists("C:\\process_data\\data4.txt");
                                    if (checkForOutputFile4 == 0)
                                    {
                                        Halt("No Data4 file found.");
                                    }

                                }


                                if (ec1==true && checkForOutputFile4==1 )
                                {
                                    Logger.WriteLogFile("data1.txt found.");
                                }
                                if (ec2 == true && checkForOutputFile2 == 1)
                                {
                                    Logger.WriteLogFile("data2.txt found.");
                                }
                                //else
                                //{
                                //    Halt("No Data2 file found.");
                                //}

                                if (ec3 == true && checkForOutputFile3 == 1)
                                {
                                    Logger.WriteLogFile("data3.txt found.");
                                }
                                if (ec4 == true && checkForOutputFile4 == 1)
                                {
                                    Logger.WriteLogFile("data4.txt found.");
                                }


                                if (AcquisitionControl.GetECAL()>0 || AcquisitionControl.GetUpscale()>0)
                                {
                                    ec1 = true;
                                    ec2 = true;
                                    ec3 = true;
                                    ec4 = false;
                                }

                                //need the minimum active ec for determining start time.
                                int minActive = 0;

                                

                                if (ec1 == true)
                                {
                                    minActive = 1;

                                }
                                else if (ec2 == true)
                                {
                                    minActive = 2;
                                }
                                else if (ec3 == true)
                                {
                                    minActive = 3;
                                }
                                else if(ec4 ==true)
                                {
                                    minActive = 4;
                                }
                                

                                System.IO.StreamReader file1=null;
                                System.IO.StreamReader file2 = null;
                                System.IO.StreamReader file3 = null;
                                System.IO.StreamReader file4 = null;
                                string tempString = "";

                                if (AcquisitionControl.GetCounter() <=2)
                                {
                                    AcquisitionControl.SetCounter(AcquisitionControl.GetCounter() + 1);
                                    try
                                    {
                                        //process normal output
                                        Logger.WriteLogFile(   "state=31  Generate concentration data.");
                                        //displayActionQueue.Enqueue("get flow and write final data from the 3 files + volume.");
                                        UpdateOperationMessage("Generating concentration data");

                                        //get the previous flow summation
                                        double flowForCalculation = AcquisitionControl.GetFlowVolumeForAnalysis();

                                        //bhcop
                                        //                                        AcquisitionControl.SetVolume(flowForCalculation);

                                        if (AcquisitionControl.GetUpscale() == 1)
                                        {
                                            flowForCalculation = 1000; //removes multiply by 1000 during upscale
                                        }
                                        else
                                        {
                                            AcquisitionControl.SetVolume(flowForCalculation);
                                        }
                                        Logger.WriteLogFile(   "(31) Get flow volume for analysis=" + flowForCalculation.ToString("F3"));


                                        string line;
                                        //string templine;
                                        int numberofElements = 0;

                                        List<string> elementDataSorted = new List<string>();
                                        List<string> elementData = new List<string>();

                                        List<string> elementDataSymbol = new List<string>();
                                        List<string> elementDataAtWt = new List<string>();
                                        List<string> elementDataMass = new List<string>();
                                        List<string> elementDataMassUnc = new List<string>();

                                        List<string> elementDataConc = new List<string>();
                                        List<string> elementDataConcUnc = new List<string>();
                                        List<string> elementDataUncer = new List<string>();
                                        List<string> elementDataConV = new List<string>();

                                        //start read data file 1
                                        try
                                        {
                                            if (ec1 == true)
                                            {
                                                Logger.WriteLogFile("(31) processing data1 file");



                                                file1 = new System.IO.StreamReader("c:/process_data/data1.txt");

                                                while ((line = file1.ReadLine()) != null)
                                                {
                                                    if (line.Contains("StartTime") && minActive==1)
                                                    {
                                                        tempString = line;  //this is EC1 start time
                                                        Logger.WriteLogFile("for EC1 start time:  " + tempString);
                                                    }
                                                    if (line.Contains("NumElements"))
                                                    {
                                                        string[] items = line.Split(',');
                                                        numberofElements = Convert.ToInt16(items[1]);
                                                        line = file1.ReadLine();

                                                        for (int i = 0; i < numberofElements; i++)
                                                        {
                                                            line = file1.ReadLine();
                                                            if (line.Contains("Xx"))
                                                            {
                                                                continue;
                                                            }
                                                            else
                                                            {
                                                                string[] elementItems = line.Split(',');

                                                                elementDataSymbol.Add(elementItems[0]);
                                                                elementData.Add(elementItems[0]);
                                                                elementDataAtWt.Add(elementItems[1]);
                                                                elementData.Add(elementItems[1]);

                                                                elementDataMass.Add(elementItems[2]);
                                                                elementData.Add(elementItems[2]);

                                                                elementDataMassUnc.Add(elementItems[3]);
                                                                elementData.Add(elementItems[3]);


                                                                double conc = Convert.ToDouble(elementDataMass.Last());

                                                                double concentration = (conc * 1000) / flowForCalculation;


                                                                string concUnc = UpdateConcUncertainty(elementItems[2], elementItems[3], concentration);



                                                                elementDataConc.Add(concentration.ToString("F4"));
                                                                elementData.Add(concentration.ToString("F4"));

                                                                elementDataConcUnc.Add(concUnc);

                                                                elementData.Add(concUnc);


                                                            }
                                                        }
                                                    }
                                                }

                                                file1.Close();

                                                //end read data file 1 
                                            }
                                        }
                                        catch(Exception Ex)
                                        {
                                            Logger.WriteErrorFile("Error: reading data1.txt file");
                                            Logger.WriteInternalLogFile("Error: reading data1.txt file = " + Ex.ToString());
                                            Logger.WriteLogFile("Error: reading data1.txt file = " + Ex.ToString());

                                        }
                                        try
                                        {

                                            if (ec2 == true)
                                            {
                                                Logger.WriteLogFile(   "(31) processing data2 file");


                                                file2 = new System.IO.StreamReader("c:/process_data/data2.txt");
                                                while ((line = file2.ReadLine()) != null)
                                                {
                                                    if (line.Contains("StartTime") && minActive == 2)
                                                    {
                                                        tempString = line;  //this is EC1 start time
                                                    }

                                                    if (line.Contains("NumElements"))
                                                    {
                                                        string[] items = line.Split(',');
                                                        numberofElements = Convert.ToInt16(items[1]);
                                                        line = file2.ReadLine();

                                                        int action = 0;

                                                        for (int i = 0; i < numberofElements; i++)
                                                        {
                                                            line = file2.ReadLine();
                                                            if (line.Contains("Xx"))
                                                            {
                                                                continue;
                                                            }
                                                            else
                                                            {
                                                                string[] elementItems = line.Split(',');
                                                                if (elementItems[0].Contains("Nb"))
                                                                {
                                                                    action = 1;

                                                                    //Update check of Nb here remove from upscale
                                                                    //else if (Element.Contains("Nb"))
                                                                    //                                        
                                                                    double measuredValue = Convert.ToDouble(elementItems[2]);

                                                                    double upperLimit = (Properties.Settings.Default.Nb * (1.0 + (Properties.Settings.Default.NbAlarmPercent / 100.0)));
                                                                    double lowerLimit = (Properties.Settings.Default.Nb * (1.0 - (Properties.Settings.Default.NbAlarmPercent / 100.0)));

                                                                    if (measuredValue >= upperLimit)
                                                                    {
                                                                        if (AcquisitionControl.GetUpscale() == 0)
                                                                        {
                                                                            Warning("Nb value high.  Nb = " + measuredValue.ToString("F2") + " Upper Limit = " + upperLimit.ToString("F2"));
                                                                            AcquisitionControl.SetAlarmValue(203);
                                                                            WriteAlarmToModbus(203);
                                                                        }
                                                                    }
                                                                    else if (measuredValue <= lowerLimit)
                                                                    {
                                                                        if (AcquisitionControl.GetUpscale() == 0)
                                                                        {
                                                                            Warning("Nb value low.  Nb = " + measuredValue.ToString("F2") + " Lower Limit = " + lowerLimit.ToString("F2"));
                                                                            AcquisitionControl.SetAlarmValue(203);
                                                                            WriteAlarmToModbus(203);
                                                                        }
                                                                    }
                                                                    if(measuredValue > 1000 && AcquisitionControl.GetUpscale()==0) 
                                                                    {

                                                                        Warning("Nb value above max limit = " + measuredValue.ToString("F2") + " max limit = 1000.");
                                                                        AcquisitionControl.SetAlarmValue(205);
                                                                        WriteAlarmToModbus(205);

                                                                    }

                                                                }
                                                                else
                                                                {
                                                                    action = 0;
                                                                }



                                                                /*
                                                                //if (action!=1)  //remove Nb
                                                                //{
                                                                elementDataSymbol.Add(elementItems[0]);
                                                                elementData.Add(elementItems[0]);
                                                                elementDataAtWt.Add(elementItems[1]);
                                                                elementData.Add(elementItems[1]);
                                                                elementDataConc.Add(elementItems[2]);
                                                                elementData.Add(elementItems[2]);

                                                                //string unc = UpdateUncertainty(elementItems[2], elementItems[3]);


                                                                //elementDataUncer.Add(unc);
                                                                //elementData.Add(unc);


                                                                double conc = Convert.ToDouble(elementDataConc.Last());
                                                                double concentration = 0.0;


                                                                //double flowForNb = 500.0;
                                                                if (action == 1)
                                                                {
                                                                    concentration = conc * 1;  //changed to 1 from 5

                                                                }
                                                                else
                                                                {
                                                                    concentration = (conc * 1000) / flowForCalculation;

                                                                }


                                                                string unc = UpdateConcUncertainty(elementItems[2], elementItems[3], concentration);


                                                                elementDataUncer.Add(unc);
                                                                elementData.Add(unc);


                                                                elementDataConV.Add(concentration.ToString("F4"));

                                                                elementData.Add(concentration.ToString("F4"));
                                                                //}
                                                                */

                                                                //string[] elementItems = line.Split(',');

                                                                elementDataSymbol.Add(elementItems[0]);
                                                                elementData.Add(elementItems[0]);
                                                                elementDataAtWt.Add(elementItems[1]);
                                                                elementData.Add(elementItems[1]);

                                                                elementDataMass.Add(elementItems[2]);
                                                                elementData.Add(elementItems[2]);

                                                                elementDataMassUnc.Add(elementItems[3]);
                                                                elementData.Add(elementItems[3]);


                                                                double conc = Convert.ToDouble(elementDataMass.Last());

                                                                double concentration = 0.0;// (conc * 1000) / flowForCalculation;


                                                                if (action == 1)
                                                                {
                                                                    concentration = conc * 1;  //changed to 1 from 5

                                                                }
                                                                else
                                                                {
                                                                    concentration = (conc * 1000) / flowForCalculation;
                                                                }


                                                                string concUnc = UpdateConcUncertainty(elementItems[2], elementItems[3], concentration);



                                                                elementDataConc.Add(concentration.ToString("F4"));
                                                                elementData.Add(concentration.ToString("F4"));

                                                                elementDataConcUnc.Add(concUnc);
                                                                elementData.Add(concUnc);


                                                            }
                                                        }
                                                    }
                                                }
                                                file2.Close();

                                            }
                                        }
                                        catch (Exception Ex)
                                        {
                                            Logger.WriteErrorFile("Error reading data2.txt file = " + Ex.ToString());
                                            Logger.WriteLogFile("Error reading data2.txt file = " + Ex.ToString());

                                        }

                                        try
                                        {
                                            if (ec3 == true)
                                            {
                                                Logger.WriteLogFile(   "(31) processing data3 file");



                                                file3 = new System.IO.StreamReader("c:/process_data/data3.txt");
                                                while ((line = file3.ReadLine()) != null)
                                                {
                                                    if (line.Contains("StartTime") && minActive == 3)
                                                    {
                                                        tempString = line;  //this is EC1 start time
                                                    }


                                                    if (line.Contains("NumElements"))
                                                    {
                                                        string[] items = line.Split(',');
                                                        numberofElements = Convert.ToInt16(items[1]);
                                                        line = file3.ReadLine();

                                                        for (int i = 0; i < numberofElements; i++)
                                                        {
                                                            line = file3.ReadLine();
                                                            if (line.Contains("Xx"))
                                                            {
                                                                continue;
                                                            }
                                                            else
                                                            {
                                                                /*
                                                                string[] elementItems = line.Split(',');

                                                                elementDataSymbol.Add(elementItems[0]);
                                                                elementData.Add(elementItems[0]);
                                                                elementDataAtWt.Add(elementItems[1]);
                                                                elementData.Add(elementItems[1]);
                                                                elementDataConc.Add(elementItems[2]);
                                                                elementData.Add(elementItems[2]);



                                                                //string unc = UpdateUncertainty(elementItems[2], elementItems[3]);

                                                                //elementDataUncer.Add(unc);
                                                                //elementData.Add(unc);

                                                                double conc = Convert.ToDouble(elementDataConc.Last());
                                                                double concentration = (conc * 1000) / flowForCalculation;


                                                                string unc = UpdateConcUncertainty(elementItems[2], elementItems[3], concentration);

                                                                elementDataUncer.Add(unc);
                                                                elementData.Add(unc);



                                                                elementDataConV.Add(concentration.ToString("F4"));

                                                                elementData.Add(concentration.ToString("F4"));
                                                                */

                                                                string[] elementItems = line.Split(',');

                                                                elementDataSymbol.Add(elementItems[0]);
                                                                elementData.Add(elementItems[0]);
                                                                elementDataAtWt.Add(elementItems[1]);
                                                                elementData.Add(elementItems[1]);

                                                                elementDataMass.Add(elementItems[2]);
                                                                elementData.Add(elementItems[2]);

                                                                elementDataMassUnc.Add(elementItems[3]);
                                                                elementData.Add(elementItems[3]);


                                                                double conc = Convert.ToDouble(elementDataMass.Last());

                                                                double concentration = 0.0;// (conc * 1000) / flowForCalculation;


                                                                //if (action == 1)
                                                                //{
                                                                //    concentration = conc * 1;  //changed to 1 from 5
                                                                //}
                                                                //else
                                                                //{
                                                                    concentration = (conc * 1000) / flowForCalculation;
                                                                //}


                                                                string concUnc = UpdateConcUncertainty(elementItems[2], elementItems[3], concentration);



                                                                elementDataConc.Add(concentration.ToString("F4"));
                                                                elementData.Add(concentration.ToString("F4"));

                                                                elementDataConcUnc.Add(concUnc);
                                                                elementData.Add(concUnc);





                                                            }
                                                        }
                                                    }
                                                }




                                                //bhc process  the data in the "old" dataset (i.e. make averages)
                                                //
                                                //

                                                file3.Close();
                                            }
                                        }
                                        catch (Exception Ex)
                                        {
                                            Logger.WriteErrorFile("Error reading data3.txt file = " + Ex.ToString());
                                            Logger.WriteLogFile("Error reading data3.txt file = " + Ex.ToString());

                                        }

                                        try
                                        {
                                            if (ec4 == true)
                                            {
                                                Logger.WriteLogFile(   "(31) processing data4 file");



                                                file4 = new System.IO.StreamReader("c:/process_data/data4.txt");
                                                while ((line = file4.ReadLine()) != null)
                                                {
                                                    if (line.Contains("StartTime") && minActive == 4)
                                                    {
                                                        tempString = line;  //this is EC1 start time
                                                    }
                                                    if (line.Contains("NumElements"))
                                                    {
                                                        string[] items = line.Split(',');
                                                        numberofElements = Convert.ToInt16(items[1]);
                                                        line = file4.ReadLine();

                                                        for (int i = 0; i < numberofElements; i++)
                                                        {
                                                            line = file4.ReadLine();
                                                            if (line.Contains("Xx"))
                                                            {
                                                                continue;
                                                            }
                                                            else
                                                            {
                                                                /*
                                                                string[] elementItems = line.Split(',');

                                                                elementDataSymbol.Add(elementItems[0]);
                                                                elementData.Add(elementItems[0]);
                                                                elementDataAtWt.Add(elementItems[1]);
                                                                elementData.Add(elementItems[1]);
                                                                elementDataConc.Add(elementItems[2]);
                                                                elementData.Add(elementItems[2]);

                                                                //string unc = UpdateUncertainty(elementItems[2], elementItems[3]);


                                                                //elementDataUncer.Add(unc);
                                                                //elementData.Add(unc);


                                                                //elementDataUncer.Add(elementItems[3]);
                                                                //elementData.Add(elementItems[3]);

                                                                double conc = Convert.ToDouble(elementDataConc.Last());
                                                                double concentration = (conc * 1000) / flowForCalculation;


                                                                string unc = UpdateConcUncertainty(elementItems[2], elementItems[3], concentration);


                                                                elementDataUncer.Add(unc);
                                                                elementData.Add(unc);




                                                                elementDataConV.Add(concentration.ToString("F4"));

                                                                elementData.Add(concentration.ToString("F4"));
                                                                                                                                string[] elementItems = line.Split(',');

                                                                elementDataSymbol.Add(elementItems[0]);
                                                                elementData.Add(elementItems[0]);
                                                                elementDataAtWt.Add(elementItems[1]);
                                                                elementData.Add(elementItems[1]);

                                                                elementDataMass.Add(elementItems[2]);
                                                                elementData.Add(elementItems[2]);

                                                                elementDataMassUnc.Add(elementItems[3]);
                                                                elementData.Add(elementItems[3]);


                                                                double conc = Convert.ToDouble(elementDataMass.Last());

                                                                double concentration = 0.0;// (conc * 1000) / flowForCalculation;


                                                                //if (action == 1)
                                                                //{
                                                                //    concentration = conc * 1;  //changed to 1 from 5
                                                                //}
                                                                //else
                                                                //{
                                                                    concentration = (conc * 1000) / flowForCalculation;
                                                                //}


                                                                string concUnc = UpdateConcUncertainty(elementItems[2], elementItems[3], concentration);



                                                                elementDataConc.Add(concentration.ToString("F4"));
                                                                elementData.Add(concentration.ToString("F4"));

                                                                elementDataConcUnc.Add(concUnc);
                                                                elementData.Add(concUnc);
                                                                */
                                                                string[] elementItems = line.Split(',');

                                                                elementDataSymbol.Add(elementItems[0]);
                                                                elementData.Add(elementItems[0]);
                                                                elementDataAtWt.Add(elementItems[1]);
                                                                elementData.Add(elementItems[1]);

                                                                elementDataMass.Add(elementItems[2]);
                                                                elementData.Add(elementItems[2]);

                                                                elementDataMassUnc.Add(elementItems[3]);
                                                                elementData.Add(elementItems[3]);


                                                                double conc = Convert.ToDouble(elementDataMass.Last());

                                                                double concentration = 0.0;// (conc * 1000) / flowForCalculation;


                                                                //if (action == 1)
                                                                //{
                                                                //    concentration = conc * 1;  //changed to 1 from 5
                                                                //}
                                                                //else
                                                                //{
                                                                concentration = (conc * 1000) / flowForCalculation;
                                                                //}


                                                                string concUnc = UpdateConcUncertainty(elementItems[2], elementItems[3], concentration);



                                                                elementDataConc.Add(concentration.ToString("F4"));
                                                                elementData.Add(concentration.ToString("F4"));

                                                                elementDataConcUnc.Add(concUnc);
                                                                elementData.Add(concUnc);







                                                            }
                                                        }
                                                    }
                                                }

                                                file4.Close();
                                            }

                                        }
                                        catch (Exception Ex)
                                        {
                                            Logger.WriteErrorFile("Error reading data4.txt file = " + Ex.ToString());
                                            Logger.WriteLogFile("Error reading data4.txt file = " + Ex.ToString());

                                        }



                                        Logger.WriteLogFile(   "(31) processing element data");

                                        int tempitems = elementData.Count();

                                        string[] array = new string[tempitems / 6];
                                        string[] tempa = new string[7];
                                        int cnt = 0;
                                        int arraycnt = 0;



                                        try
                                        {
                                            foreach (string thing in elementData)
                                            {

                                                tempa[cnt] = thing; //.Trim();
                                                cnt++;
                                                if (cnt == 6)
                                                {
                                                    array[arraycnt] = tempa[0] + "," + tempa[1] + "," + tempa[2] + "," + tempa[3] + "," + tempa[4] + "," + tempa[5];    
                                                    arraycnt += 1;
                                                    cnt = 0;
                                                }



                                            }
                                            //sort the data
                                            elementDataSorted = array
                                                .OrderBy(arr => arr[3])
                                                .ThenBy(arr => arr[4])
                                                .ToList();

                                        }
                                        catch (Exception Ex)
                                        {
                                            Logger.WriteInternalLogFile(" Error sorting element data.  Ex = " + Ex.ToString());
                                        }


                                        //bhcop
                                        //after the write above, the data set may be incremented:
                                        Logger.WriteLogFile(   "Get Upscale = " + AcquisitionControl.GetUpscale().ToString());
                                        Logger.WriteLogFile(   "Get Ecal = " + AcquisitionControl.GetECAL().ToString());

                                        if (AcquisitionControl.GetUpscale() == 1 || AcquisitionControl.GetUpscale() == 2 || AcquisitionControl.GetECAL() > 0)
                                        {

                                            Logger.WriteLogFile(   "Do not increment data set during upscale or ECAL");
                                            vol = AcquisitionControl.GetVolume();
                                            Logger.WriteLogFile(   "@upscale active, Dataset = " + AcquisitionControl.GetDataSet().ToString() + " Volume = " + vol.ToString("F2"));

                                            int value;
                                            value = AcquisitionControl.GetUpscale();
                                            Logger.WriteLogFile(   "Get Upscale = " + value.ToString());
                                        }
                                        else
                                        {
                                            Logger.WriteLogFile(   "Not in Upscale.  Not in Ecal.");

                                            int datas = AcquisitionControl.GetDataSet();
                                            vol = AcquisitionControl.GetVolume();
                                            Logger.WriteLogFile(   "BEFORE:  Dataset = " + AcquisitionControl.GetDataSet().ToString() + " Volume = " + vol.ToString("F2"));

                                            if (datas == 1)
                                            {
                                                AcquisitionControl.SetDataSet(2);
                                                Logger.WriteLogFile(" state 20, dataset was 1, set to 2.");

                                            }
                                            else
                                            {
                                                AcquisitionControl.SetDataSet(1);
                                                Logger.WriteLogFile(" state 20, dataset was 2, set to 1.");

                                            }




                                            Logger.WriteLogFile(   "Increment data set (@31).  Prepare to write to dataset = " + AcquisitionControl.GetDataSet().ToString());
                                            vol = AcquisitionControl.GetVolume();
                                            Logger.WriteLogFile(   "AFTER:  Dataset = " + AcquisitionControl.GetDataSet().ToString() + " Volume = " + vol.ToString("F2"));
                                        }

                                        DateTime now = DateTime.Now;


                                        TextWriter tw = new StreamWriter("c:/process_data/" + now.Month.ToString("D2") + "_" + now.Day.ToString("D2") + "_" + now.Year.ToString("D4") + "__" + now.Hour.ToString("D2") + "_" + now.Minute.ToString("D2") + "_" + now.Second.ToString("D2") + "_outout.txt");

                                        //may add ecal summary file:
                                        //TextWriter tw_EcalData = new StreamWriter("c:/Ecal_data/" + now.Month.ToString("D2") + "_" + now.Day.ToString("D2") + "_" + now.Year.ToString("D4") + "__" + now.Hour.ToString("D2") + "_" + now.Minute.ToString("D2") + "_" + now.Second.ToString("D2") + "_outout.txt");


                                        //int index = 0;
                                        string outputString = "";
                                        double flowValue = 0.0;
                                        flowValue = AcquisitionControl.GetFlowVolumeForAnalysis();
                                        AcquisitionControl.SetFlowVolume(flowValue);

                                        if (AcquisitionControl.GetUpscale() == 1)
                                        {
                                            flowValue = 1000;  //removes multiply by 1000
                                        }




                                        string upscaleDataDirectory = "C:/Upscale_Data";
                                        string upscaleDataDirectoryArchive = "C:/Upscale_Data/Archive";

                                        string upscaleDirectory = "C:/Upscale"; //large files
                                        string upscaleDirectoryArchive = "C:/Upscale/Archive";

                                        System.IO.Directory.CreateDirectory(upscaleDirectory);
                                        System.IO.Directory.CreateDirectory(upscaleDirectoryArchive);

                                        System.IO.Directory.CreateDirectory(upscaleDataDirectory);
                                        System.IO.Directory.CreateDirectory(upscaleDataDirectoryArchive);

                                        TextWriter tw_UpscaleData = null;
                                        if (AcquisitionControl.GetUpscale() == 1)
                                        {
                                            //twData is for upscale
                                            tw_UpscaleData = new StreamWriter(upscaleDataDirectory + "/Upscale_Data_" + now.Month.ToString("D2") + "_" + now.Day.ToString("D2") + "_" + now.Year.ToString("D4") + "__" + now.Hour.ToString("D2") + "_" + now.Minute.ToString("D2") + "_" + now.Second.ToString("D2") + "_outout.txt");
                                        }
                                        //set date time in correct format (need leading zeros)
                                        DateTime start = AcquisitionControl.GetAcquisitionOpStartDateTime();
                                        DateTime startUpscale1 = AcquisitionControl.GetAcquisitionOpStartDateTime();
                                        DateTime startUpscale = startUpscale1.AddDays(1);   //always add a day since it's after midnight.

                                        //outputString = ", Acquisition Start Time = ," + start.ToString("MM/dd/yyyy HH:mm:ss") + ",";   //add date time formatting string here -- for modbus
                                        //tw.WriteLine(outputString);


                                        //
                                        //                                        tempString Format: Start of EC1: StartTime,04-19-17 02:02:32,
                                        //                                          Start of EC1: StartTime,04-19-17 02:02:32,

                                        string[] tempStringSplit;
                                        string[] tempStringSplit2;
                                        string[] tempStringSplit3;

                                        tempStringSplit = tempString.Split(',');
                                        //CrStringSplit = CrString.Split(',');
                                        tempStringSplit2 = tempStringSplit[1].Split(' ');
                                        tempStringSplit3 = tempStringSplit2[1].Split(':');   //0=hour, 1=min, 2=seconds


                                        //bool parsedUpper = Int32.TryParse(Linputs[0], out numValueLimitUpper);

                                        //if (!parsedUpper)
                                        //{
                                        //    Logger.WriteErrorFile("Int32.TryParse could not parse " + Linputs[0].ToString() + "  to an int.");
                                        //}
                                        int hour = 0;
                                        int minute = 0;


                                        bool parsedHour = Int32.TryParse(tempStringSplit3[0], out hour);
                                        bool parsedMinute = Int32.TryParse(tempStringSplit3[1], out minute);

                                        Logger.WriteLogFile("parseHour = " + parsedHour.ToString());
                                        Logger.WriteLogFile("parsedMinute = " + parsedMinute.ToString());
                                        Logger.WriteLogFile("minute: " + minute.ToString());
                                        Logger.WriteLogFile("hour: " + hour.ToString());

                                        if (parsedHour == true && AcquisitionControl.GetSamplePeriod() == 60)
                                        {
                                            Logger.WriteLogFile(   "hour = " + hour.ToString("D2") + " min = " + minute.ToString("D2"));
                                            //the hour is valid and can be used to set acquisition time
                                            if (hour == 2)
                                            {

                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 01:00:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile(   "hour=2, outputString = " + outputString);

                                                tw.WriteLine(outputString);
                                            }
                                            else if (hour == 1 && minute >= 0 && minute <= 15)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 00:30:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile(   "hour=1, outputString = " + outputString);

                                                tw.WriteLine(outputString);

                                            }
                                            else if (hour == 0 && minute >= 30 && minute <= 38)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 23:00:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile(   "hour=0, min>30 outputString = " + outputString);

                                                tw.WriteLine(outputString);

                                            }
                                            else if (hour == 0 && minute >= 15 && minute <= 20)    //upscale
                                            {

                                                outputString = ", Sample Start Time = ," + startUpscale.ToString("MM/dd/yyyy") + " 00:15:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile(   "hour=0 min>15, min<=20, outputString = " + outputString);

                                                tw.WriteLine(outputString);
                                                tw_UpscaleData.WriteLine(outputString);

                                            }
                                            else
                                            {

                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:00:00") + ",";   //add date time formatting string here -- for modbus and for output file write


                                                Logger.WriteLogFile(   "normal, outputString = " + outputString);
                                                tw.WriteLine(outputString);

                                            }


                                        }
                                        //1.2.0.1
                                        //04.19.2019
                                        //issue at top  of each our
                                        else if(AcquisitionControl.GetSamplePeriod()==5)
                                        {
                                            if ((hour == 0) && (minute >= 15) && (minute < 20))    //upscale
                                            {

                                                outputString = ", Sample Start Time = ," + startUpscale.ToString("MM/dd/yyyy") + " 00:15:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile("hour=0 min>15, min<=20, outputString = " + outputString);

                                                tw.WriteLine(outputString);
                                                tw_UpscaleData.WriteLine(outputString);
                                                Logger.WriteInternalLogFile("temp: 0 15 20 " + outputString);

                                            }
                                            else if ((hour == 0) && (minute >= 30) && (minute < 35)) //this is the analysis start time for the sample at 23:50   
                                            {

                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 23:55:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile("hour=0, minute = "+minute.ToString()+" min>30 outputString = " + outputString);

                                                tw.WriteLine(outputString);
                                                Logger.WriteInternalLogFile("temp: 0 30 35 " + outputString);


                                            }
                                            else if (start.Minute >= 0 && start.Minute < 5)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:00:00") + ",";
                                                tw.WriteLine(outputString);
                                                Logger.WriteInternalLogFile("temp: 0 5  " + outputString);

                                            }
                                            else if (start.Minute >= 5 && start.Minute < 10)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:05:00") + ",";
                                                tw.WriteLine(outputString);
                                                Logger.WriteInternalLogFile("temp: 5 10  " + outputString);
                                            }
                                            else if (start.Minute >= 10 && start.Minute < 15)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:10:00") + ",";
                                                tw.WriteLine(outputString);
                                                Logger.WriteInternalLogFile("temp: 10 15  " + outputString);

                                            }
                                            else if (start.Minute >= 15 && start.Minute < 20)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:15:00") + ",";
                                                tw.WriteLine(outputString);
                                                Logger.WriteInternalLogFile("temp: 15 20  " + outputString);

                                            }
                                            else if (start.Minute >= 20 && start.Minute < 25)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:20:00") + ",";
                                                tw.WriteLine(outputString);
                                                Logger.WriteInternalLogFile("temp: 20 25  " + outputString);

                                            }
                                            else if (start.Minute >= 25 && start.Minute < 30)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:25:00") + ",";
                                                tw.WriteLine(outputString);
                                                Logger.WriteInternalLogFile("temp: 25 30 " + outputString);

                                            }
                                            else if (start.Minute >= 30 && start.Minute < 35)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:30:00") + ",";
                                                tw.WriteLine(outputString);
                                                Logger.WriteInternalLogFile("temp: 30 35 " + outputString);

                                            }
                                            else if (start.Minute >= 35 && start.Minute < 40)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:35:00") + ",";
                                                tw.WriteLine(outputString);
                                                Logger.WriteInternalLogFile("temp: 35 40 " + outputString);

                                            }
                                            else if (start.Minute >= 40 && start.Minute < 45)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:40:00") + ",";
                                                tw.WriteLine(outputString);
                                                Logger.WriteInternalLogFile("temp: 40 45 " + outputString);

                                            }
                                            else if (start.Minute >= 45 && start.Minute < 50)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:45:00") + ",";
                                                tw.WriteLine(outputString);
                                                Logger.WriteInternalLogFile("temp: 45 50 " + outputString);

                                            }
                                            else if (start.Minute >= 50 && start.Minute < 55)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:50:00") + ",";
                                                tw.WriteLine(outputString);
                                                Logger.WriteInternalLogFile("temp: 50 55 " + outputString);

                                            }
                                            else if (start.Minute >= 55 && start.Minute <= 59)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:55:00") + ",";
                                                tw.WriteLine(outputString);
                                                Logger.WriteInternalLogFile("temp: 55 59 " + outputString);


                                            }





                                        }
                                        else if (AcquisitionControl.GetSamplePeriod() == 15)
                                        {
                                            if (hour == 0 && minute >= 15 && minute <= 20)    //upscale
                                            {

                                                outputString = ", Sample Start Time = ," + startUpscale.ToString("MM/dd/yyyy") + " 00:15:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile(   "hour=0 min>15, min<=20, outputString = " + outputString);

                                                tw.WriteLine(outputString);
                                                tw_UpscaleData.WriteLine(outputString);

                                            }
                                            else if (hour == 0 && minute >= 30 && minute <= 35) //this is the analysis start time for the sample at 23:30
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 23:45:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile(   "hour=0, min>30 outputString = " + outputString);

                                                tw.WriteLine(outputString);

                                            }
                                            else if (start.Minute >= 0 && start.Minute < 15)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:00:00") + ",";
                                                tw.WriteLine(outputString);

                                            }
                                            else if (start.Minute >= 15 && start.Minute < 30)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:15:00") + ",";
                                                tw.WriteLine(outputString);
                                            }
                                            else if (start.Minute >= 30 && start.Minute < 45)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:30:00") + ",";
                                                tw.WriteLine(outputString);

                                            }
                                            else if (start.Minute >= 45 && start.Minute <=59)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:45:00") + ",";
                                                tw.WriteLine(outputString);

                                            }
                                            //tw.WriteLine(outputString);
                                        }



                                        else if (AcquisitionControl.GetSamplePeriod() == 77)    //ASCII Code for 'M', Maintenance Mode
                                        {
                                            Logger.WriteLogFile(   "hour = " + hour.ToString("D2") + " min = " + minute.ToString("D2"));
                                            if ((hour == 0 || hour == 6 || hour == 12 || hour == 18) && (minute >= 30 && minute <= 38)) //every 6 hour
                                            {
                                                if (hour == 0 && minute >= 30 && minute <= 38)
                                                {
                                                    outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 23:45:00" + ",";
                                                    Logger.WriteLogFile(   "hour=0, minute=30, outputString = " + outputString);
                                                    tw.WriteLine(outputString);
                                                }

                                                else if (hour == 6 && minute >= 30 && minute <= 38)
                                                {
                                                    outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 05:45:00" + ",";
                                                    Logger.WriteLogFile(   "hour=6, minute=30, outputString = " + outputString);
                                                    tw.WriteLine(outputString);
                                                }

                                                else if (hour == 12 && minute >= 30 && minute <= 38)
                                                {
                                                    outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 11:45:00" + ",";
                                                    Logger.WriteLogFile(   "hour=12, minute=30, outputString = " + outputString);
                                                    tw.WriteLine(outputString);
                                                }

                                                else if (hour == 18 && minute >= 30 && minute <= 38)
                                                {
                                                    outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 17:45:00" + ",";
                                                    Logger.WriteLogFile(   "hour=18, minute=30, outputString = " + outputString);
                                                    tw.WriteLine(outputString);
                                                }

                                            }
                                            else
                                            {


                                                if (hour == 0 && minute >= 15 && minute <= 20)    //upscale
                                                {

                                                    outputString = ", Sample Start Time = ," + startUpscale.ToString("MM/dd/yyyy") + " 00:15:00" + ",";   //add date time formatting string here -- for modbus
                                                    Logger.WriteLogFile(   "hour=0 min>15, min<=20, outputString = " + outputString);

                                                    tw.WriteLine(outputString);
                                                    tw_UpscaleData.WriteLine(outputString);

                                                }
                                                else if (hour == 0 && minute >= 30 && minute <= 35) //this is the analysis start time for the sample at 23:30
                                                {
                                                    outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 23:45:00" + ",";   //add date time formatting string here -- for modbus
                                                    Logger.WriteLogFile(   "hour=0, min>30 outputString = " + outputString);

                                                    tw.WriteLine(outputString);

                                                }

                                                else if (start.Minute >= 0 && start.Minute < 15)
                                                {
                                                    outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:00:00") + ",";
                                                    tw.WriteLine(outputString);

                                                }
                                                else if (start.Minute >= 15 && start.Minute < 30)
                                                {
                                                    outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:15:00") + ",";
                                                    tw.WriteLine(outputString);
                                                }
                                                else if (start.Minute >= 30 && start.Minute < 45)
                                                {
                                                    outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:30:00") + ",";
                                                    tw.WriteLine(outputString);

                                                }
                                                else if ((start.Minute >= 45 && start.Minute < 60) && (hour != 0 && hour != 6 && hour != 12 && hour != 18))
                                                {
                                                    outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:45:00") + ",";
                                                    tw.WriteLine(outputString);

                                                }
                                                else  //handle case of last sample start time being at :45 for ecal/upscale hours 
                                                {
                                                    DateTime temp;
                                                    temp = start.AddHours(0.5);
                                                    outputString = ", Sample Start Time = ," + temp.ToString("MM/dd/yyyy HH:mm:00") + ",";
                                                    tw_UpscaleData.WriteLine(outputString);
                                                }
                                            }

                                            //tw.WriteLine(outputString);

                                        }
                                        else if (AcquisitionControl.GetSamplePeriod() == 30) //this works for all things except Update and Ecal
                                        {
                                            if (hour == 0 && minute >= 15 && minute <= 20)    //upscale
                                            {

                                                outputString = ", Sample Start Time = ," + startUpscale.ToString("MM/dd/yyyy") + " 00:15:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile(   "hour=0 min>15, min<=20, outputString = " + outputString);

                                                tw.WriteLine(outputString);
                                                tw_UpscaleData.WriteLine(outputString);

                                            }
                                            else if (hour == 0 && minute >= 30 && minute <= 35) //this is the analysis start time for the sample at 23:30
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 23:30:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile(   "hour=0, min>30 outputString = " + outputString);

                                                tw.WriteLine(outputString);

                                            }

                                            else if (minute <= 29)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:30:00") + ",";   //add date time formatting string here -- for modbus
                                                tw.WriteLine(outputString);
                                            }
                                            else
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:00:00") + ",";   //add date time formatting string here -- for modbus
                                                tw.WriteLine(outputString);

                                            }

                                        }
                                        else if (parsedHour == true && AcquisitionControl.GetSamplePeriod() == 120)
                                        {

                                            Logger.WriteLogFile(   "hour = " + hour.ToString("D2") + " min = " + minute.ToString("D2"));
                                            //the hour is valid and can be used to set acquisition time


                                            if (hour == 0 && minute >= 15 && minute <= 20)    //upscale
                                            {

                                                outputString = ", Sample Start Time = ," + startUpscale.ToString("MM/dd/yyyy") + " 00:15:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile(   "hour=0 min>15, min<=20, outputString = " + outputString);

                                                tw.WriteLine(outputString);
                                                tw_UpscaleData.WriteLine(outputString);

                                            }
                                            else if (hour == 0 && minute >= 30 && minute <= 35)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 22:00:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile(   "hour=0, min>30 outputString = " + outputString);

                                                tw.WriteLine(outputString);

                                            }



                                            else if (hour == 2)  //EC1 start time
                                            {

                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 00:30:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile(   "hour=2, outputString = " + outputString);

                                                tw.WriteLine(outputString);
                                            }
                                            //else if (hour == 4)  //EC1 start time
                                            //{
                                            //    outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 02:00:00" + ",";   //add date time formatting string here -- for modbus
                                            //    Logger.WriteLogFile(   "hour=4, outputString = " + outputString);

                                            //    tw.WriteLine(outputString);

                                            //}

                                            //                                            else if (hour == 2 && minute >= 0 && minute <= 15)
                                            //                                           {
                                            //                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 00:30:00" + ",";   //add date time formatting string here -- for modbus
                                            //                                                Logger.WriteLogFile(   "hour=1, outputString = " + outputString);
                                            //                                                tw.WriteLine(outputString);
                                            //
                                            //                                            }
                                            else if (hour == 0 && minute >= 30 && minute <= 38)  //00:30 EC1 start
                                            {
                                                //DateTime temp;
                                                //temp = start.AddDays(-1);
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 22:00:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile(   "hour=0, min>30 outputString = " + outputString);

                                                tw.WriteLine(outputString);

                                            }
                                            else if (hour == 0 && minute >= 15 && minute <= 20)    //upscale
                                            {

                                                outputString = ", Sample Start Time = ," + startUpscale.ToString("MM/dd/yyyy") + " 00:15:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile(   "hour=0 min>15, min<=20, outputString = " + outputString);

                                                tw.WriteLine(outputString);
                                                tw_UpscaleData.WriteLine(outputString);

                                            }
                                            else if (hour == 0 && minute >= 00 && minute <= 05)  //before ecal
                                            {
                                                //DateTime temp;
                                                //temp = start.AddDays(-1);
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 20:00:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile(   "hour=0, min>05 outputString = " + outputString);

                                                tw.WriteLine(outputString);

                                            }


                                            else
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:00:00") + ",";   //add date time formatting string here -- for modbus
                                                tw.WriteLine(outputString);
                                            }

                                        }
                                        else if (parsedHour == true && AcquisitionControl.GetSamplePeriod() == 240)
                                        {
                                            if (hour == 0 && minute >= 15 && minute <= 20)    //upscale
                                            {

                                                outputString = ", Sample Start Time = ," + startUpscale.ToString("MM/dd/yyyy") + " 00:15:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile(   "hour=0 min>15, min<=20, outputString = " + outputString);

                                                tw.WriteLine(outputString);
                                                tw_UpscaleData.WriteLine(outputString);

                                            }
                                            else if (hour == 0 && minute >= 30 && minute <= 35)
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy") + " 20:00:00" + ",";   //add date time formatting string here -- for modbus
                                                Logger.WriteLogFile(   "hour=0, min>30 outputString = " + outputString);

                                                tw.WriteLine(outputString);

                                            }
                                            else
                                            {
                                                outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:00:00") + ",";   //add date time formatting string here -- for modbus
                                                tw.WriteLine(outputString);
                                            }


                                        }





                                        else
                                        {
                                            outputString = ", Sample Start Time = ," + start.ToString("MM/dd/yyyy HH:00:00") + ",";   //add date time formatting string here -- for modbus
                                            tw.WriteLine(outputString);
                                        }

                                        string timeOutputString = outputString;
                                        //tw.WriteLine("Sum volume for sample period:  " + flowValue.ToString("F2") + ","); //add comma here
                                        tw.WriteLine("Start of EC1: " + tempString + ",");

                                        tw.WriteLine("At Sym, At No, Mass, Mass Unc, Concentration, Concentration Unc");

                                        /// generate output if upscale data created
                                        string CrString;
                                        string CdString;
                                        string PbString;
                                        string NbString;
                                        string[] CrStringSplit;
                                        string[] CdStringSplit;
                                        string[] PbStringSplit;
                                        string[] NbStringSplit;

                                        if (AcquisitionControl.GetUpscale() == 1)// only perform at upscale time -- note time fixed at 30
                                        {
                                            outputString = ", Start Time = ," + now.ToString("MM/dd/yyyy HH:30:00") + ",";
                                            tw_UpscaleData.WriteLine(outputString);
                                        }



                                        foreach (String s in elementDataSorted)
                                        {

                                            outputString = s + ",";
                                            tw.WriteLine(outputString + ",");

                                            if (AcquisitionControl.GetUpscale() == 1)
                                            {
                                                if (outputString.Contains("Cr"))
                                                {
                                                    CrString = outputString;
                                                    CrStringSplit = CrString.Split(',');
                                                    tw_UpscaleData.WriteLine(CrStringSplit[0] + "," + CrStringSplit[2]);

                                                    AcquisitionControl.CheckUpscale("Cr", CrStringSplit[2], this);


                                                }
                                                else if (outputString.Contains("Cd"))
                                                {
                                                    CdString = outputString;
                                                    CdStringSplit = CdString.Split(',');

                                                    tw_UpscaleData.WriteLine(CdStringSplit[0] + "," + CdStringSplit[2]);
                                                    AcquisitionControl.CheckUpscale("Cd", CdStringSplit[2], this);

                                                }
                                                else if (outputString.Contains("Pb"))
                                                {
                                                    PbString = outputString;
                                                    PbStringSplit = PbString.Split(',');
                                                    tw_UpscaleData.WriteLine(PbStringSplit[0] + "," + PbStringSplit[2]);
                                                    AcquisitionControl.CheckUpscale("Pb", PbStringSplit[2], this);

                                                }
                                                else if (outputString.Contains("Nb"))
                                                {
                                                    NbString = outputString;
                                                    NbStringSplit = NbString.Split(',');
                                                    tw_UpscaleData.WriteLine(NbStringSplit[0] + "," + NbStringSplit[2]);
                                                    AcquisitionControl.CheckUpscale("Nb", NbStringSplit[2], this);
                                                }
                                            }



                                        }
                                        if (AcquisitionControl.GetUpscale() == 1)
                                        {
                                            tw_UpscaleData.Close();
                                        }
                                        else
                                        {
                                            //check here for Nb upscale warning generation

                                        }



                                        outputString = ",*****,";
                                        tw.WriteLine(outputString);
                                        //add the acquisition data from when acquisition time was taken:
                                        //bhcop
                                        //DateTime start = AcquisitionControl.GetAcquisitionOpStartDateTime();
                                        //outputString = ", Acquisition Start Time = ," + start.ToString();
                                        //tw.WriteLine(outputString);
                                        //outputString = ", Sample Operating Parameters ," + start.ToString("MM/dd/yyyy HH:mm:ss") + ",";
                                        //tw.WriteLine(outputString);
                                        tw.WriteLine(timeOutputString);
                                        double ambientTemp = AcquisitionControl.GetAmbientTemp();
                                        outputString = ", Ambient Temp (avg) = ," + ambientTemp.ToString("F2") + ",";
                                        tw.WriteLine(outputString);
                                        double sampleTemp = AcquisitionControl.GetSampleTemp();
                                        outputString = ", Sample Temp (avg) = ," + sampleTemp.ToString("F2") + ",";
                                        tw.WriteLine(outputString);
                                        double bP = AcquisitionControl.GetAtmPress();
                                        outputString = ", BP (avg) = ," + bP.ToString("F2") + ",";
                                        tw.WriteLine(outputString);
                                        double tapePress = AcquisitionControl.GetTapePress();
                                        outputString = ", Tape Pressure (avg) = ," + tapePress.ToString("F2") + ",";
                                        tw.WriteLine(outputString);
                                        double flow25 = AcquisitionControl.GetFlow25();
                                        outputString = ", Flow 25 (avg) = ," + flow25.ToString("F2") + ",";
                                        tw.WriteLine(outputString);
                                        double flowAct = AcquisitionControl.GetFlowAct();
                                        outputString = ", Flow Act (avg) = ," + flowAct.ToString("F2") + ",";
                                        tw.WriteLine(outputString);

                                        double flowStd = AcquisitionControl.GetFlowStd();
                                        outputString = ", Flow Std (avg) = ," + flowStd.ToString("F2") + ",";
                                        tw.WriteLine(outputString);

                                        //double volume = AcquisitionControl.GetVolume();
                                        outputString = ", Volume = ," + flowValue.ToString("F2") + ",";
                                        tw.WriteLine(outputString);

                                        double tubetemp = AcquisitionControl.GetTubeTemp();
                                        outputString = ", Tube Temp (avg) = ," + tubetemp.ToString("F2") + ",";
                                        tw.WriteLine(outputString);

                                        double enclosureTemp = AcquisitionControl.GetEnclosureTemp();
                                        outputString = ", Enclosure Temp (avg) = ," + enclosureTemp.ToString("F2") + ",";
                                        tw.WriteLine(outputString);

                                        double filamentMon = AcquisitionControl.GetFilamentMonitor();
                                        outputString = ", Filament Monitor (avg) = ," + filamentMon.ToString("F2") + ",";
                                        tw.WriteLine(outputString);

                                        double sddTemp = AcquisitionControl.GetSDDTemp();
                                        outputString = ", SDD Temp (avg) = ," + sddTemp.ToString("F2") + ",";
                                        tw.WriteLine(outputString);

                                        double dppTemp = AcquisitionControl.GetDPPTemp();
                                        outputString = ", DPP Temp (avg) = ," + dppTemp.ToString("F2") + ",";
                                        tw.WriteLine(outputString);

                                        double relativeHumidity = AcquisitionControl.GetRelativeHumidity();
                                        outputString = ", Relative Humidity (avg) = ," + relativeHumidity.ToString("F2") + ",";
                                        tw.WriteLine(outputString);


                                        double windAvg = 0;
                                        double dirAvg = 0;
                                        int returnVal = AcquisitionControl.GetWindSpeedandDirectionAvg(out windAvg, out dirAvg);
                                        if (returnVal == PASS)
                                        {
                                            Logger.WriteLogFile(   "GetWindSpeedandDirection Pass");

                                        }
                                        else
                                        {
                                            Logger.WriteLogFile(   "GetWindSpeedandDirection Fail");
                                        }
                                        try
                                        {
                                            outputString = ", Wind Speed (avg) = ," + windAvg.ToString("F2") + ",";
                                            tw.WriteLine(outputString);
                                        }
                                        catch
                                        {
                                            Logger.WriteErrorFile("No Wind Speed recorded during sample.");
                                        }
                                        try
                                        { 
                                            outputString = ", Wind Direction (avg) = ," + dirAvg.ToString("F2") + ",";
                                            tw.WriteLine(outputString);
                                         }
                                        catch
                                        {
                                            Logger.WriteErrorFile("No Wind Direction recorded during sample.");
                                        }

                                        int sampleTime = Properties.Settings.Default.SampleTime;
                                        
                                        //
                                        // prevent 77 from being written to adapt db
                                        //
                                        if (sampleTime ==77)
                                        {
                                            sampleTime = 15;
                                        }

                                        outputString = ", Sample Time (min) = ," + sampleTime.ToString() + ",";
                                        tw.WriteLine(outputString);

                                        //need to pull in value from Error and Warning
                                        outputString = ", Alarm = , " + AcquisitionControl.GetAlarmValue().ToString() + ",";// AlarmCode.ToString() + ",";
                                        tw.WriteLine(outputString);


                                        if (Properties.Settings.Default.OutputPin7==true)
                                        {
                                            bool cl7;
                                            cl7=AcquisitionControl.GetPin7OutputStateDataset();
                                            outputString = ", Control Line 7 State during Sample = ," + cl7.ToString() + ",";
                                                tw.WriteLine(outputString);
                                        }

                                        ushort []tempData;
                                        tempData = AcquisitionControl.GetPumpStartTime();

                                        // test format
                                        //outputString = ", Pump Start Time = ," + tempData[0].ToString() + " " + tempData[1].ToString() + " " + tempData[2].ToString() + " " + tempData[3].ToString() + " " + tempData[4].ToString() + " " + tempData[5].ToString(); 
                                        outputString = ", Pump Start Time = ," + tempData[1].ToString("D2") + "/" + tempData[2].ToString("D2") + "/" + tempData[0].ToString() + " " + tempData[3].ToString("D2") + ":" + tempData[4].ToString("D2") + ":" + tempData[5].ToString("D2");     
                                        tw.WriteLine(outputString);






                                        outputString = ", XC version = ,"+myFileVersionInfo.FileVersion;
                                        tw.WriteLine(outputString);



                                        tw.Close(); // must be closed before modbus can open the file
                                        

                                        Logger.WriteLogFile(   "Done writing process data file.");


Debugtag1:
                                        string path = @"C:\Process_Data";
                                            string processFile = nModbusOperations.findProcessFile(path);

                                            List<string> conc_and_dateTime = new List<string>();
                                            List<string> instrumentData = new List<string>();
                                            List<string> conc_and_dateTime_No_Nb = new List<string>();

                                            nModbusOperations.getRawData(processFile, out conc_and_dateTime, out instrumentData, out conc_and_dateTime_No_Nb);

                                          //  nModbusOperations

                                            ushort[] modbusDataArray = nModbusOperations.createModbusArray(conc_and_dateTime);
                                            ushort[] modbusDataArrayNoNb = nModbusOperations.createModbusArray(conc_and_dateTime_No_Nb);

                                            ushort[] dateTime = nModbusOperations.modbusDateTimeArray(modbusDataArray);
                                            ushort[] dateTimeNoNb = nModbusOperations.modbusDateTimeArray(modbusDataArrayNoNb);
                                            ushort[] telemetryData = nModbusOperations.ModbusTelemetryArray(instrumentData);
                                            ushort[] atomicNumbers = nModbusOperations.atomicNumberArray(modbusDataArray);
                                            ushort[] atomicNumbersNoNb = nModbusOperations.atomicNumberArray(modbusDataArrayNoNb);
                                            ushort[] concArray = nModbusOperations.modbusConcArray(modbusDataArray);
                                            ushort[] concArrayNoNb = nModbusOperations.modbusConcArray(modbusDataArrayNoNb);
                                            ushort[] uncArray = nModbusOperations.modbusUncArray(modbusDataArray);
                                            ushort[] uncArrayNoNb = nModbusOperations.modbusUncArray(modbusDataArrayNoNb);

                                            DataStore xactHoldingRegisters = AcquisitionControl.getDataStore();
                                        //upate modbus registers//

                                        if (/*Properties.Settings.Default.OutputPin4 == false &&*/
                                                                Properties.Settings.Default.OutputPin7 == false)
                                        {
                                            try
                                            {
                                                nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, atomicNumbers, 100);
                                                nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, concArray, 200);
                                                nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, uncArray, 200 + concArray.Length);
                                                //nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, uncArray, 400);

                                                nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, dateTime, 701);
                                                nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, telemetryData, 701 + dateTime.Length + 1);

                                                ushort[] oneValue = new ushort[1] { 1 };
                                                Logger.WriteLogFile(   "Signal modbus data. Addr 700 = 1");
                                                nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, oneValue, 700); // signals registers have been updated
                                                AcquisitionControl.setDataStore(xactHoldingRegisters);
                                                BackgroundManager.m_oWorkerFiveMinute.RunWorkerAsync();  //will clear addr 700 in 5 min

                                            }
                                            catch (Exception Ex)
                                            {
                                                Logger.WriteErrorFile("Error writing Modbus data.  Ex = " + Ex.ToString());
                                                Logger.WriteLogFile("Error writing Modbus data.  Ex = " + Ex.ToString());

                                            }
                                        }
                                        //
                                        //update adapt database
                                        //
                                        // do NOT do this for upscale or ecal:  add check for runState 1.0.0.41


                                        //                                        if (AcquisitionControl.GetUpscale() ==0  && AcquisitionControl.GetECAL()==0 && runState==1)  //AcquisitionControl.SetUpscale
                                        //FOR DEBUG ONLY
                                        if (AcquisitionControl.GetUpscale() ==0  && AcquisitionControl.GetECAL()==0 /*&& runState==1*/)  //AcquisitionControl.SetUpscale
                                        {
                                            try
                                            {
                                                //if (sampleTime != 5)  //an update to the adapt web app is necessary for adapt data in 5 min mode
                                                //{
                                                    AdaptDB db = new AdaptDB();
                                                    //string db_path = @"‪C:\XactControl\Adapt\adapt.db";  //throws exception at attempt to open the db`
                                                    string db_path = "C:\\XactControl\\Adapt\\adapt.db";  //works!

                                                    //C:\XactControl\Adapt
                                                    SQLiteConnection dbConnection;
                                                    db.DBConnection(db_path, out dbConnection);
                                                    db.updateDateTime(dbConnection, conc_and_dateTime_No_Nb, instrumentData);
                                                    db.updateXactData(dbConnection, conc_and_dateTime_No_Nb, instrumentData);
                                                    db.updateInstrumentStatusData(dbConnection, conc_and_dateTime_No_Nb, instrumentData);
                                                    db.updateWindData(dbConnection, conc_and_dateTime_No_Nb, instrumentData);
                                                    dbConnection.Close();
                                                //}
                                                //else
                                                //{
                                                //    Logger.WriteInternalLogFile("Five minute data not logged to adapt db.");
                                                //
                                                //}
                                            }
                                            catch (Exception Ex)
                                            {
                                                Logger.WriteInternalLogFile("Error writing adapt db.  Ex = " + Ex.ToString());
                                            }
                                        }


                                        //****************************************//


                                        double flowItem = 0.0;
                                        if (AcquisitionControl.GetUpscale() > 0 || AcquisitionControl.GetECAL() > 0)
                                        {
                                            Logger.WriteLogFile(   "Upscale or Ecal active do not update flow values.");
                                        }
                                        else
                                        {
                                            flowItem = AcquisitionControl.GetItem();
                                            Logger.WriteLogFile(   "(31) Get (flow volume) Item to save for next time: " + flowItem.ToString("F3"));
                                            Logger.WriteLogFile(   "(31) Set (flow volume) to fv fa");

                                            AcquisitionControl.SetFlowVolumeForAnalysis(flowItem);
                                            double tempFlowItem = 0.0;
                                            //readback for confirmation
                                            tempFlowItem = AcquisitionControl.GetFlowVolumeForAnalysis();
                                            Logger.WriteLogFile(   "(31) Get (flow volume) to fv fa to readback: " + tempFlowItem.ToString("F3"));

                                        }



                                        try
                                        {

                                            DateTime nowcsv = DateTime.Now;
                                            int countOfFiles = GetCountOfFilesInDirectory("c:/Process_Data_CSV");
                                            if (countOfFiles >= 4000)
                                            {
                                                ZipAllFilesInDirectory("C:/Process_Data_CSV", "C:/Process_Data_CSV_Archive/" + nowcsv.Month.ToString() + "_" + nowcsv.Day.ToString() + "_" + nowcsv.Year.ToString() + "__" + nowcsv.Hour.ToString() + "_" + nowcsv.Minute.ToString() + "_" + nowcsv.Second.ToString() + ".zip");
                                                DeleteAllFilesInDirectory("C:/Process_Data_CSV");
                                            }
                                            GenerateCSVOutput(AcquisitionControl.GetUpscale());

                                        }
                                        catch (Exception Ex)
                                        {
                                            Logger.WriteInternalLogFile("Error (state 31) in call to Generate CSV Output. Ex = " + Ex.ToString());
                                        }


                                        AcquisitionControl.SetCounter(0);
                                        AcquisitionControl.SetState(32);
                                    }
                                    catch (Exception Ex)
                                    {
                                        Logger.WriteInternalLogFile("Exception in state machine (31).  Ex = " + Ex.ToString());
                                        
                                        //stop acquisition thread                                        
                                        //stop pump thread
                                        //ramp xrays to zero
                                        int returnVal;

                                        //read presentV (actual 'kV') from NI
                                        double presentV = 0.0;
                                        presentV = readInputVoltage;
                                        presentV = presentV * 50.0 / 10.0;

                                        //ActualV.Text = presentV.ToString();
                                        presentV = Math.Round(presentV, 2, MidpointRounding.AwayFromZero);


                                        //read presentI (actual i) from NI
                                        double presentI = 0.0;
                                        presentI = readInputCurrent;
                                        presentI = presentI * 2000.0 / 10.0;
                                        presentI = Math.Round(presentI, 2, MidpointRounding.AwayFromZero);


                                        if (presentV > 5 && presentI > 10)
                                        {
                                            //Logger.WriteLogFile("c:/temp/shutdown.txt", "Pausing shutdown to ramp down xrays...");
                                           
                                            returnVal = AcquisitionControl.RampXrays(presentV, presentI, 0.0, 0.0, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                                            Thread.Sleep(6000);
                                            //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                                            AcquisitionControl.InterlockOpen(this);
                                            //InterlockOpen();

                                            //if (mtbInterlockStatus.InvokeRequired)
                                            //{
                                            //    mtbInterlockStatus.Invoke(new MethodInvoker(delegate { mtbInterlockStatus.Text = "O"; }));

                                            //}
                                            //else
                                            //{
                                            //    mtbInterlockStatus.Text = "OPEN";
                                            //}

                                            Thread.Sleep(1000);
                                            

                                        }

                                    }
                                }
                                else
                                {
                                    AcquisitionControl.SetAlarmValue(110);
                                    //
                                    //this prevents endless loop in state 31
                                    //
                                    Halt("Error in data output state (31)");
                                    Logger.WriteLogFile(   "Issue in state machine (31) ");
                                }
                                
                                

                            }
                            break;
                        case 32:
                            {
                                


                                Logger.WriteLogFile(   "state=32  Reset to EC1.  Clear parameters.");
                                UpdateOperationMessage("Data calculation and output complete");
                                AcquisitionControl.SetEC1Done(false);
                                AcquisitionControl.SetEC2Done(false);
                                AcquisitionControl.SetEC3Done(false);
                                AcquisitionControl.SetEC4Done(false);

                                //check of enabled energy conditions:
                                //ec1 is required:
                                if (AcquisitionControl.GetEC1Enabled() == true)
                                {
                                    Logger.WriteLogFile(   "EC1 enabled. Set to ec1");
                                    AcquisitionControl.SetEnergyCondition(1);
                                }
                                else if (AcquisitionControl.GetEC2Enabled() == true)
                                {
                                    Logger.WriteLogFile(   "EC2 enabled. Set to ec2");

                                    AcquisitionControl.SetEnergyCondition(2);
                                }
                                else if (AcquisitionControl.GetEC3Enabled() == true)
                                {
                                    Logger.WriteLogFile(   "EC3 enabled. Set to ec3");
                                    AcquisitionControl.SetEnergyCondition(3);
                                }
                                else if (AcquisitionControl.GetEC4Enabled() == true)
                                {
                                    Logger.WriteLogFile(   "EC4 enabled. Set to ec4");
                                    AcquisitionControl.SetEnergyCondition(4);
                                }


                                if (AcquisitionControl.GetUpscale() == 1)
                                {

                                    Logger.WriteLogFile(   "State 32 upscale ended.  Set state to 21.");
                                    AcquisitionControl.SetState(21);   
                                    AcquisitionControl.SetUpscale(2);
                                }
                                else
                                {
                                    var AcqEndTime = AcquisitionControl.GetAcquireEndTime(DateTime.Now);
                                    Logger.WriteLogFile(   "Get acq end time -- after add sample time: " + AcqEndTime.ToString());
                                    var AcqStartTime = DateTime.Now;
                                    

                                    
                                    //if(AcqStartTime.Second !=0)
                                    //{
                                    //    AcqStartTime.AddSeconds(-1 * AcqStartTime.Second);
                                    //}

                                    TimeCalc(32,AcqStartTime);






                                }



                                if (AcquisitionControl.GetUpscale() == 2)  //upscale completed
                                  {
                                    Logger.WriteLogFile(   "getupscale=2, state set to 21.");
                                    AcquisitionControl.SetCounter(0);  
                                    AcquisitionControl.SetState(21);   
                                }
                                else
                                {
                                    Logger.WriteLogFile(   "Set state to 21.");
                                    AcquisitionControl.SetCounter(0);
                                    AcquisitionControl.SetState(21);
                                }

                            }
                            break;

                        //case 33:
                        //    {

                        //        Logger.WriteLogFile(   "state = 33.  Output complete.");
                                

                        //        // double volume = AcquisitionControl.GetFlowVolume();

                        //        //apply volume to the 3 files and write final data.


                        //        AcquisitionControl.SetCounter(0);
                        //        AcquisitionControl.SetState(34);



                        //    }
                        //    break;

                        //case 34:
                        //    {
                        //        Logger.WriteLogFile(   "state = 34.  Reset control flags.  Reset state machine.");
                                

                        //        AcquisitionControl.SetEC1Done(false);
                        //        AcquisitionControl.SetEC2Done(false);
                        //        AcquisitionControl.SetEC3Done(false);
                        //        AcquisitionControl.SetEC1Enabled(true);
                        //        AcquisitionControl.SetEC2Enabled(true);
                        //        AcquisitionControl.SetEC3Enabled(true);

                        //        //apply volume to the 3 files and write final data.

                        //        DateTime AcquisitionStartTime = System.DateTime.Now;
                        //        AcquisitionControl.SetAcquireStartTime(AcquisitionStartTime);



                        //        var TimeRemaining = AcquisitionStartTime - System.DateTime.Now;
                        //        if (TimeRemaining.Hours <= 0 && TimeRemaining.Minutes <= 0 && TimeRemaining.Seconds <= 0)
                        //        {
                        //            UpdateOperationMessage("Starting EC1");
                        //            ////#bhc
                        //            AcquisitionControl.SetAcquireStartTime(AcquisitionStartTime);
                        //            double EC1p = AcquisitionControl.GetEC1Percent() / 100;
                        //            double EC2p = AcquisitionControl.GetEC2Percent() / 100;
                        //            double EC3p = AcquisitionControl.GetEC3Percent() / 100;






                        //            //return to check on
                        //            AcquisitionControl.SetCounter(0);
                        //            AcquisitionControl.SetState(21);

                        //        }
                        //        break;
                        //    }



                    }
                }
                catch (Exception Ex)
                {
                    UpdateOperationMessage("Exception in state machine logic");
                    Logger.WriteInternalLogFile("Error in state machine logic.  Ex = " + Ex.ToString());
                }
                finally
                {

                    //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                    //Logger.WriteInternalLogFile("Done with acq. state task.  state = "+AcquisitionControl.GetState().ToString());
                    Monitor.Exit(lockObj);
                }
            }
            else
            {

                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                AcquisitionLockCounter++;
                if (AcquisitionLockCounter > 50)
                {
                    Logger.WriteInternalLogFile("Lock not obtained for acq timer -- task not yet completed.  State = " + AcquisitionControl.GetState().ToString());
                }
            }
        }



        public string UpdateConcUncertainty(string sMass, string sMassUnc, double concentration)
        {
            string output = "-1.0000";

            double dmass = 0.0;
            double dmassunc = 0.0;
            double totalUnc = 0.0;
            try
            {
                bool smassSuccess = double.TryParse(sMass, out dmass);
                bool smassuncSuccess = double.TryParse(sMassUnc, out dmassunc);

                if(smassSuccess==true && smassuncSuccess==true)
                {
                    if (dmass != 0)
                    {
                        totalUnc = (((dmassunc / dmass) * (dmassunc / dmass)) + (0.03 * 0.03) + (0.01 * 0.01));
                        //    double totalUnc = (Convert.ToDouble(data[4]) * unC);
                        //    stotalUnc = totalUnc.ToString("F2");
                        double updatedUnc = Math.Pow(totalUnc, 0.5);



                        double updatedUnc2 = concentration * updatedUnc;

                        output = updatedUnc2.ToString("F4");
                        //    double totalUnc = (Convert.ToDouble(data[4]) * unC);
                        //    stotalUnc = totalUnc.ToString("F2");



                    }
                    else
                    {
                        output = "0.0000";
                    }
                  

                }


                return output;
            }
            catch(Exception Ex)
            {
                Logger.WriteInternalLogFile("Error:  in Update Conc Uncertainty.  Ex = " + Ex.ToString());
                Logger.WriteLogFile("Error:  in Update Conc Uncertainty.  Ex = " + Ex.ToString());
                //Logger.WriteErrorFile("Error:  in Update Conc Uncertainty.");
                return "-1.0000";
            }


        }





        public void SetModbusPumpActive(ushort pumpValue)
        {
            try
            {
                ushort[] oneValue = new ushort[1] { pumpValue };
                Logger.WriteLogFile("Setting pump Active value = " + pumpValue.ToString());


                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                DataStore dataStoreLivePumpState = AcquisitionControl.getDataStore();

                nModbusOperations.updateModbusSlaveRegisters(dataStoreLivePumpState, oneValue, 851);
                
            }
            catch (Exception Ex)
            {
                Logger.WriteErrorFile("Error Set Modbus Pump Active.  Ex = " + Ex.ToString());
            }


        }

        public void SetModbusPumpActiveTime()
        {
            try
            {
                readInputTimerCounter = 0;
                ushort[] rTC = new ushort[6];
                rTC = nModbusOperations.ModbusDateTimeArrayFromDTNow(DateTime.Now);

                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                DataStore dataStorePumpStartTime = AcquisitionControl.getDataStore();

                nModbusOperations.updateModbusSlaveRegisters(dataStorePumpStartTime, rTC, 880);
                AcquisitionControl.SetPumpStartTime(rTC);
            }  
            catch(Exception Ex)
            {
                //Logger.WriteErrorFile("Error: in set (Modbus):  Pump Active Time. ");

                Logger.WriteInternalLogFile("Error: in set (Modbus):  Pump Active Time.  Ex = " + Ex.ToString());
                Logger.WriteLogFile("Error: in set (Modbus):  Pump Active Time.  Ex = " + Ex.ToString());

            }

        }





        /// <summary>
        /// bhcop
        /// </summary>
        public void ProcessOperationalParameters()
        {
            //process data structure here

        }



        
        //public void TimeCalc21ForUpscale(DateTime AcqStartTime)
        //{
        //    AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

        //    double EC1p = AcquisitionControl.GetEC1Percent() / 100;
        //    double EC2p = AcquisitionControl.GetEC2Percent() / 100;
        //    double EC3p = AcquisitionControl.GetEC3Percent() / 100;
        //    double EC4p = AcquisitionControl.GetEC4Percent() / 100;

        //    int SampleTime = AcquisitionControl.GetSamplePeriod();
        //    if (SampleTime == 15 || SampleTime == 77)
        //    {

        //        int iSampleTime = 15;
        //        AcquisitionControl.SetAcquireStartTimeMinutes(AcqStartTime);
        //        double timeValue1s;
        //        timeValue1s = ((iSampleTime * EC1p * 60) + 80);
        //        int itimeValue1s = Convert.ToInt32(timeValue1s);

        //        AcquisitionControl.SetEC1Time(itimeValue1s);  //send seconds

        //        double timeValue2s = ((iSampleTime * EC2p * 60) - 40);
        //        int itimeValue2 = Convert.ToInt32(timeValue2s);

        //        AcquisitionControl.SetEC2Time(itimeValue2);


        //        double timeValue3s = ((iSampleTime * EC3p * 60) - 40);



        //        if ((timeValue1s + timeValue2s + timeValue3s) > (iSampleTime * 60))
        //        {
        //            timeValue3s = timeValue3s - ((timeValue1s + timeValue2s + timeValue3s) - iSampleTime * 60);
        //        }
        //        Logger.WriteLogFile(   "timeValue1s = " + timeValue1s.ToString() + " timeValue2s = " + timeValue2s.ToString() + " timeValue3s = " + timeValue3s.ToString());

        //        int itimeValue3 = Convert.ToInt32(timeValue3s);

        //        DateTime EC1EndTime = AcqStartTime.AddSeconds(timeValue1s);

        //        AcquisitionControl.SetEC1EndTime(EC1EndTime);
        //        DateTime EC2EndTime = EC1EndTime.AddSeconds(timeValue2s);
        //        AcquisitionControl.SetEC2EndTime(EC2EndTime);

        //        DateTime EC3EndTime = EC2EndTime.AddSeconds(itimeValue3);

        //        DateTime MinuteAdjustment = AcquisitionControl.AddMin(EC3EndTime, iSampleTime);

        //        DateTime EC3EndResult;

        //        if (MinuteAdjustment.Second != 0)
        //        {
        //            EC3EndResult = MinuteAdjustment.AddSeconds((-1 * MinuteAdjustment.Second));
        //        }
        //        else
        //        {
        //            EC3EndResult = MinuteAdjustment;
        //        }


        //        AcquisitionControl.SetEC3EndTime(EC3EndResult);

        //        Logger.WriteLogFile(   "(Upscale 21) 15, EC1 End time: " + EC1EndTime.ToString());
        //        Logger.WriteLogFile(   "(Upscale 21) 15, EC2 End time: " + EC2EndTime.ToString());
        //        Logger.WriteLogFile(   "(Upscale 21) 15, EC3 End time: " + EC3EndResult.ToString());



        //    }
        //    else if (SampleTime == 30 || SampleTime == 60 /*|| SampleTime==120 || SampleTime==180 || SampleTime == 240*/)
        //    {
        //        SampleTime = 30;
        //        AcquisitionControl.SetAcquireStartTimeMinutes(AcqStartTime);
        //        double timeValue1s;
        //        timeValue1s = ((SampleTime * EC1p * 60) + 80);
        //        int itimeValue1s = Convert.ToInt32(timeValue1s);

        //        AcquisitionControl.SetEC1Time(itimeValue1s);  //send seconds

        //        double timeValue2s = ((SampleTime * EC2p * 60) - 40);
        //        int itimeValue2 = Convert.ToInt32(timeValue2s);

        //        AcquisitionControl.SetEC2Time(itimeValue2);


        //        double timeValue3s = ((SampleTime * EC3p * 60) - 40);

        //        if ((timeValue1s + timeValue2s + timeValue3s) > (SampleTime * 60))
        //        {
        //            timeValue3s = timeValue3s - ((timeValue1s + timeValue2s + timeValue3s) - SampleTime * 60);
        //        }

        //        int itimeValue3 = Convert.ToInt32(timeValue3s);

        //        DateTime EC1EndTime = AcqStartTime.AddSeconds(timeValue1s);

        //        AcquisitionControl.SetEC1EndTime(EC1EndTime);
        //        DateTime EC2EndTime = EC1EndTime.AddSeconds(timeValue2s);
        //        AcquisitionControl.SetEC2EndTime(EC2EndTime);


        //        DateTime EC3EndTime = EC2EndTime.AddSeconds(itimeValue3);

        //        DateTime EC3EndResult;


        //        DateTime MinuteAdjustment = AcquisitionControl.AddMin(EC3EndTime, SampleTime);


        //        if (MinuteAdjustment.Second != 0   /* and the minutes must be greater or equal to the end time minutes */)
        //        {
        //            EC3EndResult = MinuteAdjustment.AddSeconds((-1 * MinuteAdjustment.Second));
        //        }
        //        else
        //        {
        //            EC3EndResult = MinuteAdjustment;
        //        }


        //        AcquisitionControl.SetEC3EndTime(EC3EndResult);

        //        Logger.WriteLogFile(   "(21) 30(+), EC1 End time: " + EC1EndTime.ToString());
        //        Logger.WriteLogFile(   "(21) 30(+), EC2 End time: " + EC2EndTime.ToString());
        //        Logger.WriteLogFile(   "(21) 30(+), EC3 End time: " + EC3EndResult.ToString());



        //    }
        //    if (SampleTime == 120 || SampleTime == 180 || SampleTime == 240)
        //    {
        //        int LocalSampleTime = SampleTime - 30;


        //        AcquisitionControl.SetAcquireStartTimeMinutes(AcqStartTime);
        //        double timeValue1s;
        //        timeValue1s = ((LocalSampleTime * EC1p * 60) + 80);
        //        int itimeValue1s = Convert.ToInt32(timeValue1s);

        //        AcquisitionControl.SetEC1Time(itimeValue1s);  //send seconds

        //        double timeValue2s = ((LocalSampleTime * EC2p * 60) - 40);
        //        int itimeValue2 = Convert.ToInt32(timeValue2s);

        //        AcquisitionControl.SetEC2Time(itimeValue2);


        //        double timeValue3s = ((LocalSampleTime * EC3p * 60) - 40);



        //        if ((timeValue1s + timeValue2s + timeValue3s) > (LocalSampleTime * 60))
        //        {
        //            timeValue3s = timeValue3s - ((timeValue1s + timeValue2s + timeValue3s) - LocalSampleTime * 60);
        //        }

        //        int itimeValue3 = Convert.ToInt32(timeValue3s);


        //        DateTime EC1EndTime = AcqStartTime.AddSeconds(timeValue1s);

        //        AcquisitionControl.SetEC1EndTime(EC1EndTime);
        //        DateTime EC2EndTime = EC1EndTime.AddSeconds(timeValue2s);
        //        AcquisitionControl.SetEC2EndTime(EC2EndTime);


        //        DateTime EC3EndTime = EC2EndTime.AddSeconds(itimeValue3);

        //        DateTime EC3EndResult;


        //        if (EC3EndTime.Minute != 0)
        //        {
        //            if (EC3EndTime.Minute >= 59)
        //            {
        //                EC3EndResult = EC3EndTime.AddSeconds(60 - EC3EndTime.Second);
        //            }
        //            else
        //            {
        //                EC3EndResult = EC3EndTime.AddSeconds(EC3EndTime.Second - 60);
        //            }
        //        }
        //        else
        //        {
        //            if (EC3EndTime.Second != 0)
        //            {
        //                EC3EndResult = EC3EndTime.AddSeconds(-1 * EC3EndTime.Second);
        //            }
        //            else
        //            {
        //                EC3EndResult = EC3EndTime;
        //            }
        //        }




        //        AcquisitionControl.SetEC3EndTime(EC3EndResult);



        //        Logger.WriteLogFile(   "(21) , EC1 End time: " + EC1EndTime.ToString());
        //        Logger.WriteLogFile(   "(21) , EC2 End time: " + EC2EndTime.ToString());
        //        Logger.WriteLogFile(   "(21) , EC3 End time: " + EC3EndResult.ToString());



        //    }






        //}


        //private void TimeCalc16(DateTime AcquisitionStartTime)
        //{
        //    AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
        //    int state = 16;

        //    Logger.WriteLogFile(   "TimeCalc, state = 16");
        //    double EC1p = AcquisitionControl.GetEC1Percent() / 100.0;
        //    double EC2p = AcquisitionControl.GetEC2Percent() / 100.0;
        //    double EC3p = AcquisitionControl.GetEC3Percent() / 100.0;
        //    double EC4p = AcquisitionControl.GetEC4Percent() / 100.0;

        //    //try
        //    //{
        //        int SampleTime = AcquisitionControl.GetSamplePeriod();
        //        if (SampleTime == 15 || SampleTime == 77)
        //        {
        //            int iSampleTime = 15;
        //            double timeValue1s = ((iSampleTime * EC1p * 60) + 80);
        //            int itimeValue1s = Convert.ToInt32(timeValue1s);

        //            AcquisitionControl.SetEC1Time(itimeValue1s);  //send seconds

        //            double timeValue2s = ((iSampleTime * EC2p * 60) - 40);
        //            int itimeValue2s = Convert.ToInt32(timeValue2s);

        //            AcquisitionControl.SetEC2Time(itimeValue2s);

        //            double timeValue3s = ((iSampleTime * EC3p * 60) - 40);
        //            int itimeValue3s = Convert.ToInt32(timeValue3s);

        //            double timeValue4s = ((iSampleTime * EC4p * 60) - 40);
        //            int itimeValue4s = Convert.ToInt32(timeValue4s);


        //            Logger.WriteLogFile(   "state = " + state.ToString() + " time EC1: " + itimeValue1s.ToString());
        //            Logger.WriteLogFile(   "state = " + state.ToString() + " time EC2: " + itimeValue2s.ToString());
        //            Logger.WriteLogFile(   "state = " + state.ToString() + " time EC3: " + itimeValue3s.ToString());
        //            Logger.WriteLogFile(   "state = " + state.ToString() + " time EC4: " + itimeValue4s.ToString());

        //            if ((itimeValue1s + itimeValue2s + itimeValue3s) > (iSampleTime * 60))
        //            {

        //                timeValue3s = timeValue3s - ((timeValue1s + timeValue2s + timeValue3s) - (iSampleTime * 60));
        //                Logger.WriteLogFile(   "state = " + state.ToString() + " time EC3 (adjust needed) ");
        //                Logger.WriteLogFile(   "state = " + state.ToString() + " time EC3 (adjusted): " + itimeValue3s.ToString());

        //            }

        //            itimeValue3s = Convert.ToInt32(timeValue3s);

        //            AcquisitionControl.SetEC3Time(itimeValue3s);

        //            DateTime AcqStartTime = AcquisitionStartTime;

        //            DateTime EC1EndTime = AcqStartTime.AddSeconds(timeValue1s);

        //            AcquisitionControl.SetEC1EndTime(EC1EndTime);
        //            DateTime EC2EndTime = EC1EndTime.AddSeconds(timeValue2s);
        //            AcquisitionControl.SetEC2EndTime(EC2EndTime);

        //            DateTime tempEC3EndTime = EC2EndTime.AddSeconds(timeValue3s);  //EC2EndTime.AddSeconds(timeValue3s);

        //            Logger.WriteLogFile(   "tempEC3EndTime.Second = " + tempEC3EndTime.Second.ToString());
        //            DateTime EC3EndTime;
        //            if (tempEC3EndTime.Second != 0)
        //            {
        //                EC3EndTime = tempEC3EndTime.AddSeconds((-1 * tempEC3EndTime.Second));
        //            }
        //            else
        //            {
        //                EC3EndTime = tempEC3EndTime;
        //            }
        //            Logger.WriteLogFile(   "EC3EndTime.Second after subtraction = " + EC3EndTime.Second.ToString());

        //            AcquisitionControl.SetEC3EndTime(EC3EndTime);

        //            Logger.WriteLogFile(   "(16) EC1 End time: " + EC1EndTime.ToString());
        //            Logger.WriteLogFile(   "(16) EC2 End time: " + EC2EndTime.ToString());
        //            Logger.WriteLogFile(   "(16) EC3 End time: " + EC3EndTime.ToString());

        //            //verify end in seconds is 00

        //        }
        //        else if (SampleTime == 30)
        //        {
        //            double timeValue1s = ((SampleTime * EC1p * 60) + 40);
        //            int itimeValue1s = Convert.ToInt32(timeValue1s);

        //            AcquisitionControl.SetEC1Time(itimeValue1s);  //send seconds

        //            double timeValue2s = ((SampleTime * EC2p * 60) - 20);
        //            int itimeValue2 = Convert.ToInt32(timeValue2s);

        //            AcquisitionControl.SetEC2Time(itimeValue2);


        //            double timeValue3s = ((SampleTime * EC3p * 60) - 20);

        //            if ((timeValue1s + timeValue2s + timeValue3s) > (SampleTime * 60))
        //            {
        //                timeValue3s = timeValue3s - ((timeValue1s + timeValue2s + timeValue3s) - SampleTime * 60);
        //            }

        //            int itimeValue3 = Convert.ToInt32(timeValue3s);



        //            AcquisitionControl.SetEC3Time(itimeValue3);

        //            DateTime AcqStartTime = AcquisitionStartTime;

        //            DateTime EC1EndTime = AcqStartTime.AddSeconds(timeValue1s);

        //            AcquisitionControl.SetEC1EndTime(EC1EndTime);
        //            DateTime EC2EndTime = EC1EndTime.AddSeconds(timeValue2s);
        //            AcquisitionControl.SetEC2EndTime(EC2EndTime);

        //            DateTime EC3EndTime = EC2EndTime.AddSeconds(timeValue3s);  //EC2EndTime.AddSeconds(timeValue3s);

        //            Logger.WriteLogFile(   "EC3EndTime.Second = " + EC3EndTime.Second.ToString());
        //            if (EC3EndTime.Second != 0)
        //            {
        //                EC3EndTime.AddSeconds((-1 * EC3EndTime.Second));
        //            }
        //            Logger.WriteLogFile(   "EC3EndTime.Second after subtraction = " + EC3EndTime.Second.ToString());

        //            AcquisitionControl.SetEC3EndTime(EC3EndTime);

        //            Logger.WriteLogFile(   "(16) EC1 End time: " + EC1EndTime.ToString());
        //            Logger.WriteLogFile(   "(16) EC2 End time: " + EC2EndTime.ToString());
        //            Logger.WriteLogFile(   "(16) EC3 End time: " + EC3EndTime.ToString());




        //            //verify end in seconds is 00



        //        }
        //        //time calc 16
        //        else if (SampleTime == 60 || SampleTime == 120 || SampleTime == 180 || SampleTime == 240)
        //        {


        //            DateTime DTNow = DateTime.Now;
        //            DateTime EC3EndTime = DTNow.AddHours((SampleTime / 60.0));

        //            AcquisitionControl.SetEC3EndTime(EC3EndTime);



        //            Logger.WriteLogFile(   "(16) EC3 End time: " + EC3EndTime.ToString());



        //        }





            
        /// <summary>
        /// 
        /// </summary>
        private void SetActiveNormalECs()
        {
            //set the active ec's
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            if (Properties.Settings.Default.EC1RTP > 0)
            {
                
                AcquisitionControl.SetEC1Enabled(true);
            }
            else
            {
                AcquisitionControl.SetEC1Enabled(false);
            }

            if (Properties.Settings.Default.EC2RTP > 0)
            {
                AcquisitionControl.SetEC2Enabled(true);
            }
            else
            {
                AcquisitionControl.SetEC2Enabled(false);
            }
            if (Properties.Settings.Default.EC3RTP > 0)
            {
                AcquisitionControl.SetEC3Enabled(true);
            }
            else
            {
                AcquisitionControl.SetEC3Enabled(false);
            }
            if (Properties.Settings.Default.EC4RTP > 0)
            {
                AcquisitionControl.SetEC4Enabled(true);
            }
            else
            {
                AcquisitionControl.SetEC4Enabled(false);
            }
        }


        int CheckFileExists(string pathFilename)
        {
            int fileExists = 0;
            if (File.Exists(pathFilename)==true)
            {
                fileExists = 1;
                
            }
            else
            {
                fileExists = 0;
            }
            return fileExists;

        }


        /// <summary>
        /// Used in state 31 to check for the output file 
        /// 
        /// </summary>
        /// <param name="pathFilename"></param>
        /// <returns></returns>
        private int PollFileExists(string pathFilename)
        {
            int timeoutCounter = 0;
            int fileExists = 0;
            try
            {
                do
                {
                    if (File.Exists(pathFilename))
                    {
                        fileExists = 1;
                        break;
                    }
                    Thread.Sleep(500);
                    timeoutCounter++;
                }
                while (timeoutCounter < 20);
                if(fileExists==1)
                {
                    return PASS;
                }
                else
                {
                    return FAIL;
                }

            }
            catch (Exception Ex)
            {
                Logger.WriteErrorFile("Expected output file does not exist.  Filename = " + pathFilename);
                Logger.WriteErrorFile("Expected output file does not exist.  Error = " + Ex.ToString());
                return FAIL;

            }
        }


        /// <summary>
        /// 
        /// </summary>
        private void GetActiveNormalECs(out bool ec1, out bool ec2, out bool ec3, out bool ec4)
        {
            //get the active ec's
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            ec1 = false;
            ec2 = false;
            ec3 = false;
            ec4 = false;

            ec1 = AcquisitionControl.GetEC1Enabled();           
            ec2 = AcquisitionControl.GetEC2Enabled();
            ec3 = AcquisitionControl.GetEC3Enabled();
            ec4 = AcquisitionControl.GetEC4Enabled();

            //Logger.WriteLogFile(   "GetActvieNormalECs:");
            //Logger.WriteLogFile(   "ec1 = " + ec1.ToString());
            //Logger.WriteLogFile(   "ec2 = " + ec2.ToString());
            //Logger.WriteLogFile(   "ec3 = " + ec3.ToString());
            //Logger.WriteLogFile(   "ec4 = " + ec4.ToString());

            //set the active ec's
            //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            //if (Properties.Settings.Default.EC1RTP > 0)
            //{

            //    AcquisitionControl.SetEC1Enabled(true);
            //}
            //else
            //{
            //    AcquisitionControl.SetEC1Enabled(false);
            //}

            //if (Properties.Settings.Default.EC2RTP > 0)
            //{
            //    AcquisitionControl.SetEC2Enabled(true);
            //}
            //else
            //{
            //    AcquisitionControl.SetEC2Enabled(false);
            //}
            //if (Properties.Settings.Default.EC3RTP > 0)
            //{
            //    AcquisitionControl.SetEC3Enabled(true);
            //}
            //else
            //{
            //    AcquisitionControl.SetEC3Enabled(false);
            //}
            //if (Properties.Settings.Default.EC4RTP > 0)
            //{
            //    AcquisitionControl.SetEC4Enabled(true);
            //}
            //else
            //{
            //    AcquisitionControl.SetEC4Enabled(false);
            //}


        }



        //#TODO update for independent connection
        public void CheckDetectorConnection()
        {
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            int retVal = FAIL;
            int count = 0;
            do
            {
                retVal = AcquisitionControl.CheckDetectorConnection();
                count += 1;
            } while (count < 3 && retVal == FAIL);
            if (retVal == FAIL)
            {
                Halt("Unable to connect to detector.");
                AcquisitionControl.SetAlarmValue(110);
                WriteAlarmToModbus(110);

            }





        }

        //start time calc 21 ***************************************************************************//


        public void TimeCalc21AfterUpscale(int state, DateTime AcquisitionStartTime, int SampleTime = -1)
        {


            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            int localSampleTime = 0;

            if (SampleTime == -1)
            {
                SampleTime = AcquisitionControl.GetSamplePeriod();
            }

            if (SampleTime ==15 || SampleTime ==77)
            {
                localSampleTime = 15;
            }
            else if(SampleTime==5)
            {
                localSampleTime = 5;
            }
            else if(SampleTime==30 || SampleTime ==60)
            {
                localSampleTime = 30;
            }
            else //SampleTime==120 || SampleTime==180 || SampleTime==240
            {
                localSampleTime = SampleTime - 30;
            }
            SampleTime = localSampleTime;



            Logger.WriteLogFile(   "Adjust TimeCalc after Upscale, state = " + state.ToString());



            double EC1p = AcquisitionControl.GetEC1Percent() / 100.0;
            double EC2p = AcquisitionControl.GetEC2Percent() / 100.0;
            double EC3p = AcquisitionControl.GetEC3Percent() / 100.0;
            double EC4p = AcquisitionControl.GetEC4Percent() / 100.0;

            int EC1enabled, EC2enabled, EC3enabled, EC4enabled, totalEnabled;
            int highestEnabled = 0;

            totalEnabled = 0;
            if (EC1p == 0)
            {
                EC1enabled = 0;
                highestEnabled = 0;
            }
            else
            {
                EC1enabled = 1;
                highestEnabled = 1;
                totalEnabled++;
            }
            if (EC2p == 0)
            {
                EC2enabled = 0;
            }
            else
            {
                EC2enabled = 1;
                highestEnabled = 2;
                totalEnabled++;
            }
            if (EC3p == 0)
            {
                EC3enabled = 0;
            }
            else
            {
                EC3enabled = 1;
                highestEnabled = 3;
                totalEnabled++;
            }
            if (EC4p == 0)
            {
                EC4enabled = 0;
            }
            else
            {
                EC4enabled = 1;
                highestEnabled = 4;
                totalEnabled++;
            }





            double timeAdjust = 30;
            double timeAdjustSplit = 0;
            int alFilter = 0;

            if (Properties.Settings.Default.EC1Filter == "Al" && EC1enabled ==1)
            {
                
                alFilter = 1;
            }
            else if (Properties.Settings.Default.EC2Filter == "Al" && EC2enabled == 1)
            {
                alFilter = 2;
            }
            else if (Properties.Settings.Default.EC3Filter == "Al" && EC3enabled == 1)
            {
                alFilter = 3;
            }
            else if (Properties.Settings.Default.EC4Filter == "Al" && EC4enabled == 1)
            {
                alFilter = 4;
            }





            try
            {

                Logger.WriteLogFile(   "TimeCalc after upscale: Adjusted SampleTime = " + SampleTime.ToString());


                if (SampleTime == 5 || SampleTime == 15 || SampleTime == 77 || SampleTime == 30 || SampleTime == 60 || SampleTime == 120 || SampleTime == 180 || SampleTime == 240 || localSampleTime != 0)//The last term catches adjustments made in  2 and 4 hr mode 
                {

                    int iSampleTime = SampleTime;
                    if (SampleTime == 77)
                    {
                        iSampleTime = 15;
                    }

                    if (SampleTime != 5)
                    {
                        if (alFilter > 0 && totalEnabled == 4)
                        {
                            timeAdjust = 30;  //was 80 for slower older code
                            timeAdjustSplit = timeAdjust / 3.0;
                        }

                        else if (alFilter > 0 && totalEnabled == 3)
                        {
                            timeAdjust = 30; //was 80 for slower older code
                            timeAdjustSplit = timeAdjust / 2.0;
                        }
                        else if (alFilter > 0 && totalEnabled == 2)
                        {
                            timeAdjust = 30; //was 80 for slower older code
                            timeAdjustSplit = timeAdjust;
                        }
                        else if (alFilter > 0 && totalEnabled == 1)
                        {

                            timeAdjust = 0;
                            timeAdjustSplit = 0;
                        }
                        else
                        {
                            timeAdjust = 0;
                            timeAdjustSplit = 0;
                        }
                    }
                    //five min mode 1.2.0.1  
                    else   // raise from 29 to 36
                    {
                        if (alFilter > 0 && totalEnabled == 4)
                        {
                            timeAdjust = 36;
                            timeAdjustSplit = timeAdjust / 3.0;
                        }

                        else if (alFilter > 0 && totalEnabled == 3)
                        {
                            timeAdjust = 36;
                            timeAdjustSplit = timeAdjust / 2.0;
                        }
                        else if (alFilter > 0 && totalEnabled == 2)
                        {
                            timeAdjust = 36;
                            timeAdjustSplit = timeAdjust;
                        }
                        else if (alFilter > 0 && totalEnabled == 1)
                        {
                            //only Al
                            timeAdjust = 0;
                            timeAdjustSplit = 0;
                        }
                        else
                        {
                            timeAdjust = 0;
                            timeAdjustSplit = 0;
                        }


                    }


                    double timeValue1s = ((iSampleTime * EC1p * 60));
                    if (alFilter == 1 && EC1enabled == 1)
                    {
                        timeValue1s += timeAdjust;
                    }
                    if (alFilter != 1 && EC1enabled == 1)
                    {
                        timeValue1s = timeValue1s - timeAdjustSplit;
                    }
                    int itimeValue1s = Convert.ToInt32(timeValue1s);


                    AcquisitionControl.SetEC1Time(itimeValue1s);


                    double timeValue2s = ((iSampleTime * EC2p * 60));
                    if (alFilter == 2 && EC2enabled == 1)
                    {
                        timeValue2s += timeAdjust;
                    }
                    if (alFilter != 2 && EC2enabled == 1)
                    {
                        timeValue2s = timeValue2s - timeAdjustSplit;
                    }
                    int itimeValue2s = Convert.ToInt32(timeValue2s);
                    AcquisitionControl.SetEC2Time(itimeValue2s);

                    double timeValue3s = ((iSampleTime * EC3p * 60));
                    if (alFilter == 3 && EC3enabled == 1)
                    {
                        timeValue3s += timeAdjust;
                    }
                    if (alFilter != 3 && EC3enabled == 1)
                    {
                        timeValue3s = timeValue3s - timeAdjustSplit;
                    }
                    int itimeValue3s = Convert.ToInt32(timeValue3s);
                    AcquisitionControl.SetEC3Time(itimeValue3s);



                    double timeValue4s = ((iSampleTime * EC4p * 60));
                    if (alFilter == 4 && EC4enabled == 1)
                    {
                        timeValue4s += timeAdjust;
                    }
                    if (alFilter != 4 && EC4enabled == 1)
                    {
                        timeValue4s = timeValue4s - timeAdjustSplit;
                    }
                    int itimeValue4s = Convert.ToInt32(timeValue4s);
                    AcquisitionControl.SetEC4Time(itimeValue4s);


                    Logger.WriteLogFile(   "state = " + state.ToString() + " time EC1: " + itimeValue1s.ToString());
                    Logger.WriteLogFile(   "state = " + state.ToString() + " time EC2: " + itimeValue2s.ToString());
                    Logger.WriteLogFile(   "state = " + state.ToString() + " time EC3: " + itimeValue3s.ToString());
                    Logger.WriteLogFile(   "state = " + state.ToString() + " time EC4: " + itimeValue4s.ToString());

                    DateTime AcqStartTime = AcquisitionStartTime;

                    DateTime tempEC1EndTime = AcqStartTime.AddSeconds(timeValue1s);
                    DateTime EC1EndTime;

                    if (highestEnabled == 1)
                    {
                        Logger.WriteLogFile(   "tempEC1EndTime.Second = " + tempEC1EndTime.Second.ToString());
                        DateTime MinuteAdjustment = AcquisitionControl.AdjMin(AcqStartTime, tempEC1EndTime, iSampleTime);
                        if (MinuteAdjustment.Second != 0)
                        {
                            EC1EndTime = MinuteAdjustment.AddSeconds((-1 * MinuteAdjustment.Second));
                        }
                        else
                        {
                            EC1EndTime = MinuteAdjustment;
                        }
                        Logger.WriteLogFile(   "EC1EndTime.Second after adjust = " + EC1EndTime.Second.ToString());

                    }
                    else
                    {
                        EC1EndTime = AcqStartTime.AddSeconds(timeValue1s);

                    }
                    AcquisitionControl.SetEC1EndTime(EC1EndTime);




                    DateTime tempEC2EndTime = EC1EndTime.AddSeconds(timeValue2s);
                    DateTime EC2EndTime;

                    if (highestEnabled == 2)
                    {
                        Logger.WriteLogFile(   "tempEC2EndTime.Second = " + tempEC2EndTime.Second.ToString());
                        DateTime MinuteAdjustment = AcquisitionControl.AdjMin(AcqStartTime, tempEC2EndTime, iSampleTime);
                        if (MinuteAdjustment.Second != 0)
                        {
                            EC2EndTime = MinuteAdjustment.AddSeconds((-1 * MinuteAdjustment.Second));
                        }
                        else
                        {
                            EC2EndTime = MinuteAdjustment;
                        }
                        Logger.WriteLogFile(   "EC2EndTime.Second after adjust = " + EC2EndTime.Second.ToString());

                    }
                    else
                    {
                        EC2EndTime = EC1EndTime.AddSeconds(timeValue2s);

                    }
                    AcquisitionControl.SetEC2EndTime(EC2EndTime);



                    DateTime tempEC3EndTime = EC2EndTime.AddSeconds(timeValue3s);
                    DateTime EC3EndTime;
                    if (highestEnabled == 3)
                    {
                        Logger.WriteLogFile(   "tempEC3EndTime.Second = " + tempEC3EndTime.Second.ToString());
                        DateTime MinuteAdjustment = AcquisitionControl.AdjMin(AcqStartTime, tempEC3EndTime, iSampleTime);
                        if (MinuteAdjustment.Second != 0)
                        {
                            EC3EndTime = MinuteAdjustment.AddSeconds((-1 * MinuteAdjustment.Second));
                        }
                        else
                        {
                            EC3EndTime = MinuteAdjustment;
                        }
                        Logger.WriteLogFile(   "EC3EndTime.Second after adjust = " + EC3EndTime.Second.ToString());

                    }
                    else
                    {
                        EC3EndTime = EC2EndTime.AddSeconds(timeValue3s);

                    }
                    AcquisitionControl.SetEC3EndTime(EC3EndTime);



                    DateTime tempEC4EndTime = EC3EndTime.AddSeconds(timeValue4s);
                    DateTime EC4EndTime;
                    if (highestEnabled == 4)
                    {
                        Logger.WriteLogFile(   "tempEC4EndTime.Second = " + tempEC4EndTime.Second.ToString());
                        DateTime MinuteAdjustment = AcquisitionControl.AdjMin(AcqStartTime, tempEC4EndTime, iSampleTime);
                        if (MinuteAdjustment.Second != 0)
                        {
                            EC4EndTime = MinuteAdjustment.AddSeconds((-1 * MinuteAdjustment.Second));
                        }
                        else
                        {
                            EC4EndTime = MinuteAdjustment;
                        }
                        Logger.WriteLogFile(   "EC4EndTime.Second after adjust = " + EC4EndTime.Second.ToString());

                    }
                    else
                    {
                        EC4EndTime = EC3EndTime.AddSeconds(timeValue4s);

                    }
                    AcquisitionControl.SetEC4EndTime(EC4EndTime);


                    Logger.WriteLogFile(   "state = " + state.ToString() + " EC1 End time: " + EC1EndTime.ToString());
                    Logger.WriteLogFile(   "state = " + state.ToString() + " EC2 End time: " + EC2EndTime.ToString());
                    Logger.WriteLogFile(   "state = " + state.ToString() + " EC3 End time: " + EC3EndTime.ToString());
                    Logger.WriteLogFile(   "state = " + state.ToString() + " EC4 End time: " + EC4EndTime.ToString());


                }

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error in TimeCalc21 routine.  Ex = " + Ex.ToString());

            }



        }

        // end time calc 21 ********************************************************************************************* //








        // *********************************************************************** //

        public void TimeCalc(int state, DateTime AcquisitionStartTime,int SampleTime=-1)
        {
            

            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            if(SampleTime==-1)
            {
                SampleTime = AcquisitionControl.GetSamplePeriod();
            }

            Logger.WriteLogFile(   "TimeCalc, state = " + state.ToString());



            double EC1p = AcquisitionControl.GetEC1Percent() / 100.0;
            double EC2p = AcquisitionControl.GetEC2Percent() / 100.0;
            double EC3p = AcquisitionControl.GetEC3Percent() / 100.0;
            double EC4p = AcquisitionControl.GetEC4Percent() / 100.0;

            int EC1enabled, EC2enabled, EC3enabled, EC4enabled, totalEnabled;
            int highestEnabled = 0;

            totalEnabled = 0;
            if (EC1p == 0)
            {
                EC1enabled = 0;
                highestEnabled = 0;
            }
            else
            {
                EC1enabled = 1;
                highestEnabled = 1;
                totalEnabled++;
            }
            if (EC2p == 0)
            {
                EC2enabled = 0;
            }
            else
            {
                EC2enabled = 1;
                highestEnabled = 2; 
                totalEnabled++;
            }
            if (EC3p == 0)
            {
                EC3enabled = 0;
            }
            else
            {
                EC3enabled = 1;
                highestEnabled = 3;
                totalEnabled++;
            }
            if (EC4p == 0)
            {
                EC4enabled = 0;
            }
            else
            {
                EC4enabled = 1;
                highestEnabled = 4;
                totalEnabled++;
            }





            double timeAdjust = 27;
            double timeAdjustSplit = 0;
            int alFilter = 0;

            //if (EC2enabled == 1 && EC3enabled == 1 && EC1enabled == 1)
            //    timeAdjustSplit = timeAdjust / 2;
            //else
            ///    timeAdjustSplit = timeAdjust;

            //find Al filter
            if(Properties.Settings.Default.EC1Filter=="Al" && EC1enabled == 1)
            {
                alFilter = 1;
            }
            else if(Properties.Settings.Default.EC2Filter == "Al" && EC2enabled == 1)
            {
                alFilter = 2;
            }
            else if (Properties.Settings.Default.EC3Filter == "Al" && EC3enabled == 1)
            {
                alFilter = 3;
            }
            else if (Properties.Settings.Default.EC4Filter == "Al" && EC4enabled == 1)
            {
                alFilter = 4;
            }





            try
            {
  
                Logger.WriteLogFile(   "TimeCalc: sampleTime = " + SampleTime.ToString());
                

                if (SampleTime ==5 || SampleTime == 15 || SampleTime == 77 || SampleTime==30 || SampleTime==60 || SampleTime ==120 || SampleTime==180 || SampleTime==240)
                {

                    int iSampleTime = SampleTime;
                    if(SampleTime ==77)
                    {
                        iSampleTime = 15;
                    }

                    if (SampleTime != 5)
                    { //upddate from 27 to 29


                        if (alFilter > 0 && totalEnabled == 4)
                        {
                            timeAdjust = 30;  //was 80 adjusted down from the slower response timing of earlier version
                            timeAdjustSplit = timeAdjust / 3.0;
                        }

                        else if (alFilter > 0 && totalEnabled == 3)
                        {
                            timeAdjust = 30;  //was 80 see above
                            timeAdjustSplit = timeAdjust / 2.0;
                        }
                        else if (alFilter > 0 && totalEnabled == 2)
                        {
                            timeAdjust = 30;  //was 80 see above
                            timeAdjustSplit = timeAdjust;
                        }
                        else if (alFilter > 0 && totalEnabled == 1)
                        {
                            //only Al
                            timeAdjust = 0;
                            timeAdjustSplit = 0;
                        }
                        else
                        {
                            timeAdjust = 0;
                            timeAdjustSplit = 0;
                        }
                    }
                    else 
                    { //five min mode

                        //from 30 to 36
                        if (alFilter > 0 && totalEnabled == 4)
                        {
                            timeAdjust = 36;
                            timeAdjustSplit = timeAdjust / 3.0;
                        }

                        else if (alFilter > 0 && totalEnabled == 3)
                        {
                            timeAdjust = 36;
                            timeAdjustSplit = timeAdjust / 2.0;
                        }
                        else if (alFilter > 0 && totalEnabled == 2)
                        {
                            timeAdjust = 36;
                            timeAdjustSplit = timeAdjust;
                        }
                        else if (alFilter > 0 && totalEnabled == 1)
                        {
                            //only Al
                            timeAdjust = 0;
                            timeAdjustSplit = 0;
                        }
                        else
                        {
                            timeAdjust = 0;
                            timeAdjustSplit = 0;
                        }

                    }



                    double timeValue1s = ((iSampleTime * EC1p * 60));
                    if(alFilter==1 && EC1enabled==1)
                    {
                        timeValue1s+= timeAdjust;
                    }
                    if(alFilter!=1 && EC1enabled==1)
                    {
                        timeValue1s = timeValue1s - timeAdjustSplit;
                    }                   
                    int itimeValue1s = Convert.ToInt32(timeValue1s);


                    AcquisitionControl.SetEC1Time(itimeValue1s);
                    

                    double timeValue2s = ((iSampleTime * EC2p * 60));
                    if(alFilter==2 && EC2enabled == 1)
                    {
                        timeValue2s += timeAdjust;
                    }
                    if (alFilter != 2 && EC2enabled == 1)
                    {
                        timeValue2s = timeValue2s - timeAdjustSplit;
                    }
                    int itimeValue2s = Convert.ToInt32(timeValue2s);
                    AcquisitionControl.SetEC2Time(itimeValue2s);

                    double timeValue3s = ((iSampleTime * EC3p * 60));
                    if (alFilter==3 && EC3enabled==1)
                    {
                        timeValue3s += timeAdjust;
                    }
                    if (alFilter != 3 && EC3enabled == 1)
                    {
                        timeValue3s = timeValue3s - timeAdjustSplit;
                    }
                    int itimeValue3s = Convert.ToInt32(timeValue3s);
                    AcquisitionControl.SetEC3Time(itimeValue3s);



                    double timeValue4s = ((iSampleTime * EC4p * 60));
                    if(alFilter==4 && EC4enabled==1)
                    {
                        timeValue4s += timeAdjust;
                    }
                    if (alFilter != 4 && EC4enabled == 1)
                    {
                        timeValue4s = timeValue4s - timeAdjustSplit;
                    }
                    int itimeValue4s = Convert.ToInt32(timeValue4s);
                    AcquisitionControl.SetEC4Time(itimeValue4s);


                    Logger.WriteLogFile(   "state = " + state.ToString() + " time EC1: " + itimeValue1s.ToString());
                    Logger.WriteLogFile(   "state = " + state.ToString() + " time EC2: " + itimeValue2s.ToString());
                    Logger.WriteLogFile(   "state = " + state.ToString() + " time EC3: " + itimeValue3s.ToString());
                    Logger.WriteLogFile(   "state = " + state.ToString() + " time EC4: " + itimeValue4s.ToString());

                    DateTime AcqStartTime = AcquisitionStartTime;

                    DateTime tempEC1EndTime = AcqStartTime.AddSeconds(timeValue1s);
                    DateTime EC1EndTime;

                    if (highestEnabled == 1)
                    {
                        Logger.WriteLogFile(   "tempEC1EndTime.Second = " + tempEC1EndTime.Second.ToString());
                        DateTime MinuteAdjustment = AcquisitionControl.AdjMin(AcqStartTime,tempEC1EndTime, iSampleTime);
                        if (MinuteAdjustment.Second != 0)
                        {
                            EC1EndTime = MinuteAdjustment.AddSeconds((-1 * MinuteAdjustment.Second));
                        }
                        else
                        {
                            EC1EndTime = MinuteAdjustment;
                        }
                        Logger.WriteLogFile(   "EC1EndTime.Second after adjust = " + EC1EndTime.Second.ToString());

                    }
                    else
                    {
                        EC1EndTime = AcqStartTime.AddSeconds(timeValue1s);

                    }
                    AcquisitionControl.SetEC1EndTime(EC1EndTime);

                    DateTime tempEC2EndTime = EC1EndTime.AddSeconds(timeValue2s);
                    DateTime EC2EndTime;

                    if (highestEnabled == 2)
                    {
                        Logger.WriteLogFile(   "tempEC2EndTime.Second = " + tempEC2EndTime.Second.ToString());
                        DateTime MinuteAdjustment = AcquisitionControl.AdjMin(AcqStartTime,tempEC2EndTime, iSampleTime);
                        if (MinuteAdjustment.Second != 0)
                        {
                            EC2EndTime = MinuteAdjustment.AddSeconds((-1 * MinuteAdjustment.Second));
                        }
                        else
                        {
                            EC2EndTime = MinuteAdjustment;
                        }
                        Logger.WriteLogFile(   "EC2EndTime.Second after adjust = " + EC2EndTime.Second.ToString());

                    }
                    else
                    {
                        EC2EndTime = EC1EndTime.AddSeconds(timeValue2s);
                    }
                    AcquisitionControl.SetEC2EndTime(EC2EndTime);



                    DateTime tempEC3EndTime = EC2EndTime.AddSeconds(timeValue3s);
                    DateTime EC3EndTime;
                    if (highestEnabled == 3)
                    {
                        Logger.WriteLogFile(   "tempEC3EndTime.Second = " + tempEC3EndTime.Second.ToString());
                        DateTime MinuteAdjustment = AcquisitionControl.AdjMin(AcqStartTime, tempEC3EndTime, iSampleTime);
                        if (MinuteAdjustment.Second != 0)
                        {
                            EC3EndTime = MinuteAdjustment.AddSeconds((-1 * MinuteAdjustment.Second));
                        }
                        else
                        {
                            EC3EndTime = MinuteAdjustment;
                        }
                        Logger.WriteLogFile(   "EC3EndTime.Second after adjust = " + EC3EndTime.Second.ToString());

                    }
                    else
                    {
                        EC3EndTime = EC2EndTime.AddSeconds(timeValue3s);
                    }
                    AcquisitionControl.SetEC3EndTime(EC3EndTime);



                    DateTime tempEC4EndTime = EC3EndTime.AddSeconds(timeValue4s);
                    DateTime EC4EndTime;
                    if (highestEnabled == 4)
                    {
                        Logger.WriteLogFile(   "tempEC4EndTime.Second = " + tempEC4EndTime.Second.ToString());
                        DateTime MinuteAdjustment = AcquisitionControl.AdjMin(AcqStartTime, tempEC4EndTime, iSampleTime);
                        if (MinuteAdjustment.Second != 0)
                        {
                            EC4EndTime = MinuteAdjustment.AddSeconds((-1 * MinuteAdjustment.Second));
                        }
                        else
                        {
                            EC4EndTime = MinuteAdjustment;
                        }
                        Logger.WriteLogFile(   "EC4EndTime.Second after adjust = " + EC4EndTime.Second.ToString());

                    }
                    else
                    {
                        EC4EndTime = EC3EndTime.AddSeconds(timeValue4s);

                    }
                    AcquisitionControl.SetEC4EndTime(EC4EndTime);


                    Logger.WriteLogFile(   "state = " +state.ToString() + " EC1 End time: " + EC1EndTime.ToString());
                    Logger.WriteLogFile(   "state = " +state.ToString() + " EC2 End time: " + EC2EndTime.ToString());
                    Logger.WriteLogFile(   "state = " +state.ToString() + " EC3 End time: " + EC3EndTime.ToString());
                    Logger.WriteLogFile(   "state = " +state.ToString() + " EC4 End time: " + EC4EndTime.ToString());


                }

        }
            catch (Exception Ex)
            {
                Logger.WriteErrorFile("Error in TimeCalc routine.  Ex = " + Ex.ToString());
                Logger.WriteLogFile("Error in TimeCalc routine.  Ex = " + Ex.ToString());

            }



        }

        // ********************************************************************************************* //



        public int CleanProcessData(string pathName="C:/process_data/")
        {

            string fileName="data";
            try
            {
                

                for (int a=1; a <= 4; a++)
                {
                    System.IO.File.Delete(pathName + fileName + a.ToString() + ".txt");
                }

                return PASS;
            }


            catch(Exception Ex)
            {
                Logger.WriteInternalLogFile("Error:  unable to Clean Process Data.  Ex = " + Ex.ToString());
                Logger.WriteLogFile("Error:  unable to Clean Process Data.  Ex = " + Ex.ToString());
                return FAIL;
            }
        }



        public void processInputVoltage(string value)
        {

            //identify the contents of the return string
            //identify if the reponse is from a specific command
            //parse the return string for the expected values
            //add timeout if problem waiting for the expected value

            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processInputVoltage), new object[] { value });
                return;
            }

            mtbIOActualkV.Text = value;
            //receivedValue = value;
            mtbActualkV.Text = value;   //maint screen
            //need to save the returned value to check it...

        }

        public void processInputCurrent(string value)
        {

            //identify the contents of the return string
            //identify if the reponse is from a specific command
            //parse the return string for the expected values
            //add timeout if problem waiting for the expected value

            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processInputCurrent), new object[] { value });
                return;
            }

            mtbIOActualuA.Text = value;
            mtbActualuA.Text = value;   //maint screen
            //receivedValue = value;

            //need to save the returned value to check it...

        }

        void ReadTubeTemp()
        {
            double tubeTempVoltage = 0;
            double degreesC = 0;

            //TTCounter++;
            //if (TTCounter >= 1)
            //{
            //   TTCounter = 0;


            tubeTempVoltage = ReadTubeTempVoltage(5);
            //convert to C
            degreesC = (-1.6783 * (Math.Pow(tubeTempVoltage, 3))) + (13.9192 * (Math.Pow(tubeTempVoltage, 2))) - (56.1915 * tubeTempVoltage) + 104.5623;
            tubeTempStatic = Math.Round(degreesC, 2, MidpointRounding.AwayFromZero);
            //round tube input data
            //tubeTempVoltage = Math.Round(tubeTempVoltage, 2, MidpointRounding.AwayFromZero);
            //degreesC = Math.Round(degreesC, 2, MidpointRounding.AwayFromZero);



            //Logger.WriteLogFile("c:\\temp\\TubeTempMon.txt", "input V = " + tubeTempVoltage.ToString());
            //Logger.WriteLogFile("c:\\temp\\TubeTempMon.txt", "degrees C = " + degreesC.ToString());

            //display tube data
            processReadValue(degreesC.ToString("F2"));

            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            //take action
            TTCounter++;
            if (TTCounter >= 10)
            {
                TTCounter = 0;
                if (degreesC > Properties.Settings.Default.TubeTempWarningTrigger && degreesC < Properties.Settings.Default.TubeTempErrorTrigger)
                {
                    //generate warning
                    //set background to yellow
                    AcquisitionControl.SetWarning("Tube temp = " + degreesC.ToString("F2") + "  Tube temp > " + Properties.Settings.Default.TubeTempWarningTrigger.ToString("F1") + " C and < " + Properties.Settings.Default.TubeTempErrorTrigger.ToString("F1") + " C ");

                    tbMetroTubeTemp.BackColor = Color.Yellow;
                    tbMetroTubeTemp.Refresh();

                    Warning("Tube temp = " + degreesC.ToString("F2") + "  Tube temp > " + Properties.Settings.Default.TubeTempWarningTrigger.ToString("F1") + " C and < " + Properties.Settings.Default.TubeTempErrorTrigger.ToString("F1") + " C ");
                    WriteAlarmToModbus(212);
                }
                else if (degreesC >= Properties.Settings.Default.TubeTempErrorTrigger)
                {


                    Logger.WriteErrorFile("Error:  Tube Temp > = " + Properties.Settings.Default.TubeTempErrorTrigger.ToString("F2") + " C");
                    Logger.WriteLogFile("Error:  Tube Temp > = " + Properties.Settings.Default.TubeTempErrorTrigger.ToString("F2") + " C");

                    AcquisitionControl.SetError("Tube Temp >= " + Properties.Settings.Default.TubeTempErrorTrigger.ToString("F2") + " C");
                    AcquisitionControl.SetAlarmValue(102);
                    this.WriteAlarmToModbus(102);

                    Halt("Tube Temp > " + Properties.Settings.Default.TubeTempErrorTrigger.ToString("F2") + " C.  Tube Temp = " + degreesC.ToString("F2"));
                    //stop system
                    if (BackgroundManager.m_oWorkerAcq.IsBusy)
                    {
                        BackgroundManager.m_oWorkerAcq.CancelAsync();
                    }

                    if (m_oWorkerRamp.IsBusy)
                    {
                        m_oWorkerRamp.CancelAsync();
                    }

                    //generate error--if running stop and ramp down
                    //perform error tasks of log and inform
                    if (tbMetroTubeTemp.BackColor == Color.Red)
                    {
                        tbMetroTubeTemp.BackColor = Color.White;
                        tbMetroTubeTemp.Refresh();
                    }
                    else //if (tbTubeTemperature.BackColor==Color.Transparent)
                    {
                        tbMetroTubeTemp.BackColor = Color.Red;
                        tbMetroTubeTemp.Refresh();
                    }


                }
                else
                {

                    tbMetroTubeTemp.BackColor = Color.White;
                    tbMetroTubeTemp.Refresh();
                }
            }
            //}

        }

        void ReadEnclosureTemp()
        {
            double enclosureTempVoltage = 0;


            enclosureTempVoltage = ReadEnclosureTempVoltage(5);

            //double enclosureTemp = (enclosureTempVoltage * 55.55) - 86.38;
            double degreesC = (-1.6783 * (Math.Pow(enclosureTempVoltage, 3))) + (13.9192 * (Math.Pow(enclosureTempVoltage, 2))) - (56.1915 * enclosureTempVoltage) + 104.5623;

            enclosureTempStatic = Math.Round(degreesC, 2, MidpointRounding.AwayFromZero);

            //round data
            //degreesC = Math.Round(degreesC, 2, MidpointRounding.AwayFromZero);
            //log data
            //Logger.WriteLogFile("c:\\temp\\EnclosureTempMon.txt", "input V = " + enclosureTempVoltage.ToString());

            //display data

            processEnclosureTempValue(degreesC.ToString("F2"));

            //////take action

            if (degreesC > 40)
            {
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                AcquisitionControl.SetAlarmValue(103);
                this.WriteAlarmToModbus(103);

                Halt("Enclosure Temp > 40 C.  Enclosure Temp = " + degreesC.ToString("F2"));
                //stop system
                //BackgroundManager.m_oWorkerAcq.CancelAsync();
                //m_oWorkerRamp.CancelAsync();
            }


        }

        void ReadAmbientTemp()
        {
            double ambientTempVoltage = 0;
            //double degreesC = 0;


            ambientTempVoltage = ReadAmbientTempVoltage(100);   //50 .05

            //degreesC = (-1.6783 * (Math.Pow(tubeTempVoltage, 3))) + (13.9192 * (Math.Pow(tubeTempVoltage, 2))) - (56.1915 * tubeTempVoltage) + 104.5623;

            double ambientTemp = 0.0;
            if (Properties.Settings.Default.TemperatureSensorType.Contains("110S"))
            {
                ambientTemp = (ambientTempVoltage * 55.55) - 86.38;
            }
            else if (Properties.Settings.Default.TemperatureSensorType.Contains("T60"))
            {
                //      Temperature(°C) = (Voltage x 44.74364) -40.85555 °C
                //greater than 4.6 m:  Temperature(°C) = (Voltage x 44.74364) -(40.85555 - .18233 ) °C
                //for 67m:           Temperature(°C) = (Voltage x 44.74364) -(40.67322) °C

                ambientTemp = (ambientTempVoltage * 44.74364) - 40.67322;

                //Note: Transfer function above applies to 4.6 - meter cable.For sensors with cable lengths longer than 4.6 meters, subtract 0.002922 °C  per additional meter from the transfer function offset. 
                //67.0-4.6 = 62.4 * .002922 = .18233
            }


            //display data

            double TnistCalAdjVal = Properties.Settings.Default.TnistCalAdj;
            ambientTemp = (ambientTemp - TnistCalAdjVal);       //was '-' 9.15.2016

            ambientTempStatic = Math.Round(ambientTemp,2,MidpointRounding.AwayFromZero); 


            processAmbientTempValue(ambientTemp.ToString("F2"));


        }

        double ReadSampleTemp()
        {
            double sampleTempVoltage = 0;


            sampleTempVoltage = ReadSampleTempVoltage(2);

            //double sampleTemp = (sampleTempVoltage * 55.55) - 86.38;

            double degreesC = (-1.6783 * (Math.Pow(sampleTempVoltage, 3))) + (13.9192 * (Math.Pow(sampleTempVoltage, 2))) - (56.1915 * sampleTempVoltage) + 104.5623;

            //round data
            //degreesC = Math.Round(degreesC, 2, MidpointRounding.AwayFromZero);
            //log data
            //Logger.WriteLogFile("c:\\temp\\sampleTempMon.txt", "input V = " + sampleTempVoltage.ToString());


            //display data
            processSampleTempValue(degreesC.ToString("F2"));
            degreesC = Math.Round(degreesC, 2, MidpointRounding.AwayFromZero);
            //ambientTempStatic = degreesC;
            sampleTempStatic = degreesC;
            return degreesC;
        }


        void ReadAtmPress()
        {
            //double atmPressVoltage = 0;
            //double degreesC = 0;

            double ambientPressureValue;
            //tapePressureValue = TapePressureInputAveraging();
            ambientPressureValue = AmbientPressureInputAveraging();


            ////atmPressVoltage = ReadAtmPressVoltage(10);

            //////round data
            //ambientPressureValue = Math.Round(ambientPressureValue, 2, MidpointRounding.AwayFromZero);
            //////log data
            ////Logger.WriteLogFile("c:\\temp\\sampleTempMon.txt", "input V = " + atmPressVoltage.ToString());

            //display data
            double atmValue = Properties.Settings.Default.PnistCalAdj;

            ambientPressureValue = (ambientPressureValue - Properties.Settings.Default.PnistCalAdj);  //updated from '-' 9.15.2016

            ambientPressureStatic = Math.Round(ambientPressureValue, 2, MidpointRounding.AwayFromZero);

            processAtmPressValue(ambientPressureValue.ToString("F2"));

            //////take action
   
        }


        void ReadFilamentMonitor()
        {
            double filamentMonitorVoltage = 0;
            //double degreesC = 0;

            filamentMonitorVoltage = ReadFilamentMonitorVoltage(5);

            //round data
            //filamentMonitorVoltage = Math.Round(filamentMonitorVoltage, 2, MidpointRounding.AwayFromZero);
            //log data
            //Logger.WriteLogFile("c:/temp/filamentmonitor.txt", "input V = " + filamentMonitorVoltage.ToString());

            //display data

            //filamentMonitorStatic = filamentMonitorVoltage;
            filamentMonitorStatic = Math.Round(filamentMonitorVoltage, 2, MidpointRounding.AwayFromZero);

            processFilamentMonitorValue(filamentMonitorVoltage.ToString("F2"));

            //////take action
            ////if (degreesC > 35 && degreesC < 40)
            ////{
            ////    //generate warning
            ////    //set background to yellow
            ////    //

            ////    tbTubeTemp.BackColor = Color.Yellow;
            ////}
            ////else if (degreesC >= 40)
            ////{

            ////    //generate error--if running stop and ramp down
            ////    //perform error tasks of log and inform
            ////    if (tbTubeTemp.BackColor == Color.Red)
            ////        tbTubeTemp.BackColor = Color.White;
            ////    else //if (tbTubeTemperature.BackColor==Color.Transparent)
            ////        tbTubeTemp.BackColor = Color.Red;


            ////}
            ////else
            ////{
            ////    tbTubeTemp.BackColor = Color.Transparent;
            ////}

        }


        double ReadRelativeHumidity()
        {
            double relativeHumidityVoltage = 0;
            //double degreesC = 0;


            relativeHumidityVoltage = ReadRelativeHumidityVoltage(5);

            //round data
            relativeHumidityVoltage = Math.Round(relativeHumidityVoltage, 2, MidpointRounding.AwayFromZero);
            //log data
//            Logger.WriteLogFile("c:\\temp\\RelativeHumidityMonVoltage.txt", "input V = " + relativeHumidityVoltage.ToString());


            return relativeHumidityVoltage;

            //////take action
            ////if (degreesC > 35 && degreesC < 40)
            ////{
            ////    //generate warning
            ////    //set background to yellow
            ////    //

            ////    tbTubeTemp.BackColor = Color.Yellow;
            ////}
            ////else if (degreesC >= 40)
            ////{

            ////    //generate error--if running stop and ramp down
            ////    //perform error tasks of log and inform
            ////    if (tbTubeTemp.BackColor == Color.Red)
            ////        tbTubeTemp.BackColor = Color.White;
            ////    else //if (tbTubeTemperature.BackColor==Color.Transparent)
            ////        tbTubeTemp.BackColor = Color.Red;


            ////}
            ////else
            ////{
            ////    tbTubeTemp.BackColor = Color.Transparent;
            ////}

        }

        void ReadSamplePressure()
        {

            double samplePressureValueAdjusted = 0;
            double samplePressureValueUnadjusted=0;

            samplePressureValueUnadjusted = TapePressureInputAveraging();

            double adjValue = Properties.Settings.Default.PSnistCalAdj;

            samplePressureValueAdjusted = (samplePressureValueUnadjusted - adjValue);  // apply the same offset as the AtmPressure sensor receives.

            samplePressureStatic = Math.Round(samplePressureValueAdjusted, 2, MidpointRounding.AwayFromZero);

            //display data
            //Logger.WriteLogFile( "double stat BEFORE RawTapePressure static = " + samplePressureStatic.ToString("F2"), "c:/temp/TapePressureRaw.txt");
            //Logger.WriteLogFile( "double BEFORE RawTapePressureUnadjusted = " + samplePressureValueUnadjusted.ToString("F2"), "c:/temp/TapePressureRaw.txt");
            //Logger.WriteLogFile( "double BEFORE RawTapePressureAdjusted = " + samplePressureValueAdjusted.ToString("F2"), "c:/temp/TapePressureRaw.txt");

            processSamplePressureValue(samplePressureValueAdjusted.ToString("F2"));


        }


        
        /// <summary>
        /// Called only by leak check
        /// </summary>
        /// <returns></returns>
        double ReadOnlySamplePressure()
        {
            double samplePressureValue = 0;


            samplePressureValue = TapePressureInputAveraging();
            //round data
            //samplePressureValue = Math.Round(samplePressureValue, 2, MidpointRounding.AwayFromZero);
            //log data
            //Logger.WriteLogFile("c:\\temp\\SamplePressureMon.txt", "input V = " + samplePressureValue.ToString());
            double value = Properties.Settings.Default.PSnistCalAdj;
            samplePressureValue = (samplePressureValue - Properties.Settings.Default.PSnistCalAdj);  // apply the same offset as the AtmPressure sensor receives.


            return samplePressureValue;

        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public void processRelativeHumidityValue(string value)
        {

            //identify the contents of the return string
            //identify if the reponse is from a specific command
            //parse the return string for the expected values
            //add timeout if problem waiting for the expected value

            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            AcquisitionControl.SetRelativeHumidity(Convert.ToDouble(value));


            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processRelativeHumidityValue), new object[] { value });
                return;
            }

            tbMetroRelativeHumidity.Text = value;
            //receivedValue = value;

            //need to save the returned value to check it...

        }

        /// <summary>
        /// Read SDD temp (TECMonitor)
        /// </summary>
        double ReadSDDTemp()
        {
            try
            {

                //test logic for com interface to xrsfp and spectra x

                myxrsfp = new cMTFFPX();

                //var response = myxrsfp.Connect_MCA;


                float fretVal;
                fretVal = myxrsfp.Get_TECMonitor;
                return fretVal;

            }
            catch (Exception eX)
            {
                //int error = 1;
                eX.ToString();
                return 0.01;   //dummy value
            }



        }


        /// <summary>
        /// Read DDP temp
        /// </summary>
        double ReadDPPTemp()
        {
            try
            {

                //test logic for com interface to xrsfp and spectra x

                myxrsfp = new cMTFFPX();
                float fretVal;
                fretVal = myxrsfp.Get_BoardTemp;
                return fretVal;

            }
            catch (Exception eX)
            {
                //int error = 1;
                eX.ToString();
                return 0.01;   //dummy value
            }

            //return 2.34;

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public void processSDDTempValue(string value)
        {

            //identify the contents of the return string
            //identify if the reponse is from a specific command
            //parse the return string for the expected values
            //add timeout if problem waiting for the expected value
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            AcquisitionControl.SetSDDTemp(Convert.ToDouble(value));


            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processSDDTempValue), new object[] { value });
                return;
            }

            tbMetroSDDTemp.Text = value;
            //receivedValue = value;

            //need to save the returned value to check it...

        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public void processDPPTempValue(string value)
        {

            //identify the contents of the return string
            //identify if the reponse is from a specific command
            //parse the return string for the expected values
            //add timeout if problem waiting for the expected value

            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            AcquisitionControl.SetDPPTemp(Convert.ToDouble(value));

            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processDPPTempValue), new object[] { value });
                return;
            }

            tbMetroDDPTemp.Text = value;
            //receivedValue = value;

            //need to save the returned value to check it...


        }

        public void processVolumeTempValue(string value)
        {


            //identify the contents of the return string
            //identify if the reponse is from a specific command
            //parse the return string for the expected values
            //add timeout if problem waiting for the expected value


            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processDPPTempValue), new object[] { value });
                return;
            }

            tbMetroVolume.Text = value;
            //receivedValue = value;

            //need to save the returned value to check it...


        }





        /// <summary>
        /// called from IO thread
        /// 
        /// </summary>
        /// <param name="NumberOfReadsToAverage"></param>
        /// <returns></returns>
        private static double ReadTubeTempVoltage(int NumberOfReadsToAverage)
        {
            double avgVoltage = 3.01;
            int readOk = 0;
            int counter = 0;

            do
            {

                try
                {

#if TURNON_NIHARDWARE

                    reader = new AnalogMultiChannelReader(InputReadValue.Stream);
                    InputTubeTempData = reader.ReadWaveform(NumberOfReadsToAverage);


                    readOk = 1;
                    double sum = 0.0;
                    string stringValue;


                    // Iterate over channels
                    int NumberOfReads = 0;
                    foreach (AnalogWaveform<double> waveform in InputTubeTempData)
                    {
                        for (int sample = 0; sample < waveform.Samples.Count; ++sample)
                        {
                            sum = sum + waveform.Samples[sample].Value;
                            NumberOfReads++;
                            stringValue = waveform.Samples[sample].Value.ToString();

                            //TubeTempMon01.WriteLine(stringValue);   //this does a file write (may be a real time restriction here!)


                        }
                    }
                    if (NumberOfReads > 0)
                    {
                        avgVoltage = sum / NumberOfReads;
                        break;
                    }

                    //TubeTempMon01.WriteLine(" *** AVG=, {0}", avgVoltage);

#else
                    //avgVoltage = 2.456;

                    readOk = 1;
#endif
                }
                catch (Exception Ex)
                {
                    //string msg;

                    //msg = "Tube temp read ex= " + e.ToString();
                    //Logger.WriteErrorFile(msg);
                    //msg = "Tube temp error counter= " + counter.ToString();
                    Logger.WriteInternalLogFile("Exception in read tube temp.  Ex = "+Ex.ToString());
                    counter += 1;
                }

            } while (readOk == 0 && counter < 10);

            if (counter >= 10)
            {
                string msg;

                msg = "Error:  Tube temp read.";
                Logger.WriteInternalLogFile(msg);
                //msg = "Tube temp error counter= " + counter.ToString();
                //Logger.WriteErrorFile(msg);
                //counter += 1;
            }
            return avgVoltage;

        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public void processReadValue(string value)
        {

            //identify the contents of the return string
            //identify if the reponse is from a specific command
            //parse the return string for the expected values
            //add timeout if problem waiting for the expected value
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            AcquisitionControl.SetTubeTemp(Convert.ToDouble(value));


            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processReadValue), new object[] { value });
                return;
            }

            tbMetroTubeTemp.Text = value;
            //receivedValue = value;

            //need to save the returned value to check it...

        }


        /// <summary>
        /// called from IO thread
        /// 
        /// </summary>
        /// <param name="NumberOfReadsToAverage"></param>
        /// <returns></returns>
        private static double ReadEnclosureTempVoltage(int NumberOfReadsToAverage)
        {
            double avgVoltage = 2.246;
            int readOk = 0;
            int counter = 0;

            do
            {

                try
                {
#if TURNON_NIHARDWARE

                    reader = new AnalogMultiChannelReader(InputReadEnclosureTemp.Stream);
                    InputEnclosureTempData = reader.ReadWaveform(NumberOfReadsToAverage);


                    readOk = 1;
                    double sum = 0.0;
                    string stringValue;


                    // Iterate over channels
                    int NumberOfReads = 0;
                    foreach (AnalogWaveform<double> waveform in InputEnclosureTempData)
                    {
                        for (int sample = 0; sample < waveform.Samples.Count; ++sample)
                        {
                            sum = sum + waveform.Samples[sample].Value;
                            NumberOfReads++;
                            stringValue = waveform.Samples[sample].Value.ToString();

                            //EnclosureTempMon01.WriteLine(stringValue);   //this does a file write (may be a real time restriction here!)


                        }
                    }
                    if (NumberOfReads > 0)
                    {
                        avgVoltage = sum / NumberOfReads;
                        break;
                    }

                    //TubeTempMon01.WriteLine(" *** AVG=, {0}", avgVoltage);

#else


                    readOk = 1;
#endif
                }
                catch (Exception Ex)
                {
                    //string msg;

                    //msg = "Enclosure temp read ex= " + e.ToString();
                    //Logger.WriteErrorFile(msg);
                    //msg = "Enclosure temp error counter= " + counter.ToString();
                    Logger.WriteInternalLogFile("Exception in read enclosure temp  Ex = "+Ex.ToString() );
                    counter += 1;
                }

            } while (readOk == 0 && counter < 10);
            if (counter >= 10)
            {
                string msg;

                msg = "Error:  Enclosure temp read.";
                Logger.WriteInternalLogFile(msg);
            }


            return avgVoltage;

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public void processEnclosureTempValue(string value)
        {

            //identify the contents of the return string
            //identify if the reponse is from a specific command
            //parse the return string for the expected values
            //add timeout if problem waiting for the expected value

            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            AcquisitionControl.SetEnclosureTemp(Convert.ToDouble(value));


            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processEnclosureTempValue), new object[] { value });
                return;
            }

            tbMetroEnclosureTemp.Text = value;
            //receivedValue = value;

            //need to save the returned value to check it...

        }

        /// <summary>
        /// called from IO thread
        /// 
        /// </summary>
        /// <param name="NumberOfReadsToAverage"></param>
        /// <returns></returns>
        private static double ReadAmbientTempVoltage(int NumberOfReadsToAverage)
        {
            double avgVoltage = 0.025;
            int readOk = 0;
            int counter = 0;

            do
            {

                try
                {
#if TURNON_NIHARDWARE

                    reader = new AnalogMultiChannelReader(InputReadAmbientTemp.Stream);
                    InputAmbientTempData = reader.ReadWaveform(NumberOfReadsToAverage);


                    readOk = 1;
                    double sum = 0.0;
                    string stringValue;


                    // Iterate over channels
                    int NumberOfReads = 0;
                    foreach (AnalogWaveform<double> waveform in InputAmbientTempData)
                    {
                        for (int sample = 0; sample < waveform.Samples.Count; ++sample)
                        {
                            sum = sum + waveform.Samples[sample].Value;
                            NumberOfReads++;
                            stringValue = waveform.Samples[sample].Value.ToString();

                            //EnclosureTempMon01.WriteLine(stringValue);   //this does a file write (may be a real time restriction here!)


                        }
                    }
                    if (NumberOfReads > 0)
                    {
                        avgVoltage = sum / NumberOfReads;
                        break;
                    }
                    //TubeTempMon01.WriteLine(" *** AVG=, {0}", avgVoltage);

#else
                    avgVoltage = 2.3579;

                    readOk = 1;
#endif
                }
                catch (Exception Ex)
                {
                    //string msg;

                    //msg = "Enclosure temp read ex= " + e.ToString();
                    //Logger.WriteErrorFile(msg);
                    //msg = "Enclosure temp error counter= " + counter.ToString();
                    Logger.WriteInternalLogFile("Exception in input ambient data  Ex = "+Ex.ToString());
                    counter += 1;
                }

            } while (readOk == 0 && counter < 10);
            if (counter >= 10)
            {
                string msg;

                msg = "Error:  Ambient temp read.";
                Logger.WriteInternalLogFile(msg);
                //msg = "Enclosure temp error counter= " + counter.ToString();
                //Logger.WriteErrorFile(msg);
                //counter += 1;
            }



            return avgVoltage;

        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public void processAmbientTempValue(string value)
        {

            //identify the contents of the return string
            //identify if the reponse is from a specific command
            //parse the return string for the expected values
            //add timeout if problem waiting for the expected value


            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            AcquisitionControl.SetAmbientTemp(Convert.ToDouble(value));


            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processAmbientTempValue), new object[] { value });
                return;
            }

            tbMetroAmbientTemp.Text = value;
            //receivedValue = value;



            tbMetroAmbientTempCal.Text = value;
        }


        /// <summary>
        /// called from IO thread
        /// 
        /// </summary>
        /// <param name="NumberOfReadsToAverage"></param>
        /// <returns></returns>
        private static double ReadSampleTempVoltage(int NumberOfReadsToAverage)
        {
            double avgVoltage = 1.2345;
            int readOk = 0;
            int counter = 0;

            do
            {

                try
                {
#if TURNON_NIHARDWARE

                    reader = new AnalogMultiChannelReader(InputReadSampleTemp.Stream);
                    InputSampleTempData = reader.ReadWaveform(NumberOfReadsToAverage);


                    readOk = 1;
                    double sum = 0.0;
                    string stringValue;


                    // Iterate over channels
                    int NumberOfReads = 0;
                    foreach (AnalogWaveform<double> waveform in InputSampleTempData)
                    {
                        for (int sample = 0; sample < waveform.Samples.Count; ++sample)
                        {
                            sum = sum + waveform.Samples[sample].Value;
                            NumberOfReads++;
                            stringValue = waveform.Samples[sample].Value.ToString();



                        }
                    }
                    if (NumberOfReads > 0)
                    {
                        avgVoltage = sum / NumberOfReads;
                        break;
                    }


#else

                    readOk = 1;
#endif
                }
                catch (Exception Ex)
                {
                    //string msg;

                    //msg = "Sample temp read ex= " + e.ToString();
                    //Logger.WriteErrorFile(msg);
                    //msg = "Sample temp error counter= " + counter.ToString();
                    Logger.WriteInternalLogFile("Exception in input sample data   Ex = "+Ex.ToString());
                    counter += 1;
                }

            } while (readOk == 0 && counter < 10);

            if (counter >= 10)
            {
                string msg;

                msg = "Error:  Sample temp read.";
                Logger.WriteInternalLogFile(msg);
                //msg = "Sample temp error counter= " + counter.ToString();
                //Logger.WriteErrorFile(msg);
                //counter += 1;
            }
            return avgVoltage;

        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public void processSampleTempValue(string value)
        {

            //identify the contents of the return string
            //identify if the reponse is from a specific command
            //parse the return string for the expected values
            //add timeout if problem waiting for the expected value
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            AcquisitionControl.SetSampleTemp(Convert.ToDouble(value));


            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processSampleTempValue), new object[] { value });
                return;
            }

            tbMetroSampleTemp.Text = value;
            //receivedValue = value;

            //need to save the returned value to check it...

        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        static double AmbientPressureInputAveraging()
        {
            int readOk = 0;
            int counter = 0;
           
            AnalogWaveform<double>[] dataLocal=null;

            //string timeStampValue;

            do
            {
                try
                {
#if TURNON_NIHARDWARE
                    //reader = new AnalogMultiChannelReader(AmbientPressureSensorInput.Stream);
                    readerAtmPressure = new AnalogMultiChannelReader(InputReadAtmPressure.Stream);


                    dataLocal = readerAtmPressure.ReadWaveform(10);
#endif

                    readOk = 1;
                    break;
                }
                catch (Exception Ex)
                {
                    //string msg;
                    counter++;

                    //msg = "Ambient Pressure Input Averaging ex= " + ex.ToString();
                    //Logger.WriteErrorFile(msg);

                    //counter += 1;
                    //msg = "Ambient error counter= " + counter.ToString();
                    //Logger.WriteErrorFile(msg);
                    Logger.WriteInternalLogFile("Ambient pressure input.  Ex = " + Ex.ToString());

                }
            } while (readOk == 0 && counter < 10);
            if (counter >= 10)
            {
                string msg = "Error:  Ambient Pressure Input Averaging.";
                Logger.WriteInternalLogFile(msg);

                //counter += 1;
                //msg = "Ambient error counter= " + counter.ToString();
                //Logger.WriteErrorFile(msg);
            }



            double sum = 0.0;
            double sumhg = 0.0;
            double avg = 0.034;
            double avghg = 0.033;
            double rawPressureValue = 0.0;
            double outputmmHg = 0.0;
            //string outputmmHgstringValue;
            //string stringValue;

            // Iterate over channels
            int currentLineIndex = 0;
            try
            {

#if TURNON_NIHARDWARE
                foreach (AnalogWaveform<double> waveform in dataLocal)
                {
                    for (int sample = 0; sample < waveform.Samples.Count; ++sample)
                    {
                        rawPressureValue = waveform.Samples[sample].Value;

                        outputmmHg = ((rawPressureValue - (0.100 * 5.00)) / (0.80 * 5.00)) * 760.0;   //775.72399;  //changed from 760

                        sum = sum + rawPressureValue;

                        sumhg = sumhg + outputmmHg;

                        currentLineIndex++;
                        //stringValue = waveform.Samples[sample].Value.ToString();
                        //outputmmHgstringValue = outputmmHg.ToString();

                        //string stringout;
                        //stringout = stringValue + "," + outputmmHgstringValue;

                        //dataFile3.WriteLine(stringout);   //this does a file write (may be a real time restriction here!)
                    }
                }
                avg = sum / currentLineIndex;
                avghg = sumhg / currentLineIndex;


                avghg = (avghg + atmPressureOld) / 2;

#else
                avghg = 767.77;

#endif


                //dataFile3.WriteLine("** raw  Ambient AVG=,,, {0}", avg);

                //dataFile3.WriteLine("** mmHg Ambient AVG=,,,, {0}", avghg);

                string stringAmbientValue = avghg.ToString();

                //timeStampValue = GetTimeStampStr();

                //ambientPressureFile.WriteLine("TIME: {0}, ambientPressureValue: {1:F04}, ", timeStampValue, stringAmbientValue);

                //Logger.WriteLogFile("c:\\temp\\pressure.txt", "Ambient Pressure (avg) mmhg = " + stringAmbientValue);
            }
            catch
            {
                //avg = 0.003;
                avghg = 0.004;

            }
            atmPressureOld = avghg;
            return avghg;

        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public void processAtmPressValue(string value)
        {

            //identify the contents of the return string
            //identify if the reponse is from a specific command
            //parse the return string for the expected values
            //add timeout if problem waiting for the expected value

            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            AcquisitionControl.SetAtmPress(Convert.ToDouble(value));

            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processAtmPressValue), new object[] { value });
                return;
            }

            tbMetroAtmPressure.Text = value;
            //receivedValue = value;

            //need to save the returned value to check it...
            tbMetroAtmPressureCal.Text = value;
        }


        /// <summary>
        /// called from IO thread
        /// 
        /// </summary>
        /// <param name="NumberOfReadsToAverage"></param>
        /// <returns></returns>
        private static double ReadFilamentMonitorVoltage(int NumberOfReadsToAverage)
        {
            double avgVoltage = 0.073;
            int readOk = 0;
            int counter = 0;

            do
            {

                try
                {
#if TURNON_NIHARDWARE

                    reader = new AnalogMultiChannelReader(InputReadFilamentMonitor.Stream);
                    InputFilamentMonitorData = reader.ReadWaveform(NumberOfReadsToAverage);


                    readOk = 1;
                    double sum = 0.0;
                    string stringValue;


                    // Iterate over channels
                    int NumberOfReads = 0;
                    foreach (AnalogWaveform<double> waveform in InputFilamentMonitorData)
                    {
                        for (int sample = 0; sample < waveform.Samples.Count; ++sample)
                        {
                            sum = sum + waveform.Samples[sample].Value;
                            NumberOfReads++;
                            stringValue = waveform.Samples[sample].Value.ToString();

                            //EnclosureTempMon01.WriteLine(stringValue);   //this does a file write (may be a real time restriction here!)


                        }
                    }
                    if (NumberOfReads > 0)
                    {
                        avgVoltage = sum / NumberOfReads;
                        break;
                    }
                    //FilamentMon01.WriteLine(" *** AVG=, {0}", avgVoltage);

#else
                    //avgVoltage = 2.456;

                    readOk = 1;
#endif
                }
                catch (Exception Ex)
                {
                    //string msg;

                    //msg = "ATM press read ex= " + e.ToString();
                    //Logger.WriteErrorFile(msg);
                    //msg = "ATM press error counter= " + counter.ToString();
                    Logger.WriteInternalLogFile("Exception in read filament monitor  Ex = "+Ex.ToString());
                    counter += 1;
                }

            } while (readOk == 0 && counter < 10);
            if (counter >= 10)
            {
                string msg;

                msg = "Error:  ATM press read.";
                Logger.WriteInternalLogFile(msg);
                //msg = "ATM press error counter= " + counter.ToString();
                //Logger.WriteErrorFile(msg);
                //counter += 1;
            }

            return avgVoltage;


        }




        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public void processFilamentMonitorValue(string value)
        {

            //identify the contents of the return string
            //identify if the reponse is from a specific command
            //parse the return string for the expected values
            //add timeout if problem waiting for the expected value

            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            AcquisitionControl.SetFilamentMonitor(Convert.ToDouble(value));

            if (InvokeRequired)
            {
                this.Invoke(new Action<string>(processFilamentMonitorValue), new object[] { value });
                return;
            }

            tbMetroFilamentMonitor.Text = value;
            //receivedValue = value;

            //need to save the returned value to check it...

        }


        /// <summary>
        /// called from IO thread
        /// 
        /// </summary>
        /// <param name="NumberOfReadsToAverage"></param>
        /// <returns></returns>
        private static double ReadRelativeHumidityVoltage(int NumberOfReadsToAverage)
        {
            double avgVoltage = 0.08;
            int readOk = 0;
            int counter = 0;

            do
            {

                try
                {
#if TURNON_NIHARDWARE

                    reader = new AnalogMultiChannelReader(InputReadRelativeHumidity.Stream);
                    InputRelativeHumidityData = reader.ReadWaveform(NumberOfReadsToAverage);


                    readOk = 1;
                    double sum = 0.0;
                    string stringValue;


                    // Iterate over channels
                    int NumberOfReads = 0;
                    foreach (AnalogWaveform<double> waveform in InputRelativeHumidityData)
                    {
                        for (int sample = 0; sample < waveform.Samples.Count; ++sample)
                        {
                            sum = sum + waveform.Samples[sample].Value;
                            NumberOfReads++;
                            stringValue = waveform.Samples[sample].Value.ToString();

                            //RelativeHumdidityMon01.WriteLine(stringValue);   //this does a file write (may be a real time restriction here!)


                        }
                    }
                    if (NumberOfReads > 0)
                    {
                        avgVoltage = sum / NumberOfReads;
                        break;
                    }
                    //RelativeHumidityMon01.WriteLine(" *** AVG=, {0}", avgVoltage);

#else
                    //avgVoltage = 2.456;

                    readOk = 1;
#endif
                }
                catch (Exception Ex)
                {
                    //string msg;

                    //msg = "Relative Humidity read ex= " + e.ToString();
                    //Logger.WriteErrorFile(msg);
                    //msg = "Relative Humidity error counter= " + counter.ToString();
                    Logger.WriteInternalLogFile("Exception in read relative humidity  Ex = "+Ex.ToString());
                    counter += 1;
                }

            } while (readOk == 0 && counter < 10);
            if (counter >= 10)
            {
                string msg;

                msg = "Error: read Relative Humidity.";
                Logger.WriteInternalLogFile(msg);
                //msg = "Relative Humidity error counter= " + counter.ToString();
                //Logger.WriteErrorFile(msg);
                //counter += 1;
            }



            return avgVoltage;

        }



        /// <summary>
        /// read the tape pressure sensor 
        /// </summary>
        /// <returns></returns>
        static double TapePressureInputAveraging()
        {
            int readOk = 0;
            int counter = 0;
            double avg=0;
            double avghg = 0.0;

            double sum = 0.0;
            double sumhg = 0.0;
            double rawPressureValue = 0.0;
            double outputmmHg = 0.0;

            AnalogWaveform<double>[] dataTapePressure;
            //string outputmmHgstringValue;
            //string stringValue;

#if TURNON_NIHARDWARE

            do
            {

                try
                {

                    readerSamplePressure = new AnalogMultiChannelReader(InputReadSamplePressure.Stream);


                    //data = readerTapePressure.ReadWaveform(pressureSamplesPerChannel);
                    dataTapePressure = readerSamplePressure.ReadWaveform(pressureSamplesPerChannel);
                    readOk = 1;


                    if (readOk == 1)
                    {
                        // Iterate over channels
                        int currentLineIndex = 0;
                        foreach (AnalogWaveform<double> waveform in dataTapePressure)
                        {
                            for (int sample = 0; sample < waveform.Samples.Count; ++sample)
                            {
                                rawPressureValue = waveform.Samples[sample].Value;

                                // line updated 1.1.0.74
                                outputmmHg = ((rawPressureValue - (0.100 * 5.00)) / (0.80 * 5.00)) * 760.0; //775.72399;  //changed from 760
                                                                                                            //below is the line used by atm pressure sensor
                                                                                                            //                      outputmmHg = ((rawPressureValue - (0.100 * 5.00)) / (0.80 * 5.00)) * 760.0;   //775.72399;  //changed from 760

                                sum = sum + rawPressureValue;

                                sumhg = sumhg + outputmmHg;

                                currentLineIndex++;
                                //stringValue = waveform.Samples[sample].Value.ToString();
                                //outputmmHgstringValue = outputmmHg.ToString();

                                //string stringout;
                                //stringout = stringValue + "," + outputmmHgstringValue;

                                //dataFile3.WriteLine(stringout);   //this does a file write (may be a real time restriction here!)
                            }
                        }

                        if (currentLineIndex > 0)
                        {
                            avg = sum / currentLineIndex;
                            avghg = sumhg / currentLineIndex;
                            break;
                        }
                    }

                }
                catch (Exception ex)
                {
                    string msg;
                    msg = "Error:  Sample Pressure Input Averaging. Ex = " + ex.ToString();
                    //WriteErrorFile(msg);
                    Logger.WriteInternalLogFile(msg);
                    msg = "Error: Sample Pressure Input counter. Ex = " + counter.ToString();
                    //WriteErrorFile(msg);
                    Logger.WriteInternalLogFile(msg);
                    counter += 1;
                    avghg = 0;
                }




            } while (readOk == 0 && counter < 10);

#else
            //avg = 7.89;
            avghg = 567.890;
#endif
            //dataFile3.WriteLine("* pressure ********** raw  AVG=,,, {0}", avg);

            //dataFile3.WriteLine("* pressure ******* mmHg AVG=,,,, {0}", avghg);
            //Logger.WriteLogFile("c:/temp/tapepressure.txt", "tape pressure mmhg (avg) = " + avghg.ToString());


            return avghg;

        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        public void processSamplePressureValue(string value)
        {

            //identify the contents of the return string
            //identify if the reponse is from a specific command
            //parse the return string for the expected values
            //add timeout if problem waiting for the expected value

            //Logger.WriteLogFile( "string RawTapePressure (PSPV) = " + value, "c:/temp/TapePressureRaw.txt");

            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            double dvalue = 0;
            try
            {
                dvalue = Convert.ToDouble(value);
            }
            catch(Exception Ex)
            {
                Logger.WriteInternalLogFile("Error:  in process Sample Pressure.  Ex = "+Ex.ToString());
                Logger.WriteLogFile("Error:  in process Sample Pressure.  Ex = " + Ex.ToString());


            }
            //Logger.WriteLogFile( "double ***RawTapePressure*** = " + dvalue.ToString("F2"), "c:/temp/TapePressureRaw.txt");

            AcquisitionControl.SetTapePress(dvalue);




            tbMetroSamplePressure.Text = value;
            //receivedValue = value;

            //need to save the returned value to check it...
            tbMetroSamplePressureCal.Text = value;

            // .Text = value;
            if (InvokeRequired)
            {

                //display data
                //Logger.WriteLogFile("invoke str  value = " + value, "c:/temp/TapePressureRaw.txt");
                //Logger.WriteLogFile("invoke double BEFORE RawTapePressureUnadjusted = " + samplePressureValueUnadjusted.ToString("F2"), "c:/temp/TapePressureRaw.txt");
                //Logger.WriteLogFile("invoke double BEFORE RawTapePressureAdjusted = " + samplePressureValueAdjusted.ToString("F2"), "c:/temp/TapePressureRaw.txt");

                this.Invoke(new Action<string>(processSamplePressureValue), new object[] { value });
                return;
            }

        }


        private static void OutputCalc(double setPointValue, double Kp, double Ki, double Kd, int startCounter, out double errorValue, out double flowValue, out double outputVoltageValue, out double processValue)
        {
            double TotalOutput = 0;
            double scaleSP = 0;
            scaleSP = setPointValue;

            setPointValueNew = setPointValue;


            PumpOutputOld = PumpOutputNew;
            //store the previous value





            double ProcessValue = flowSensorVoltage; 


            processValue = ProcessValue;

            int writeOk = 0;
            int counter = 0;

            Error = scaleSP - ProcessValue; //setPointValue - ProcessValue;

            //**
            errorValue = Error;  //set this for return and display
            flowValue = ProcessValue;
            //**

            deltaTime = TIMER_VALUE;

            double PID;

            if (startCounter <= 3)
            {
                Error = 0.00842;
                integral = -8.1526;
                derivative = 0.00161;
                PID = (errorValue * Kp) + (integral * Ki) + (derivative * Kd);
                TotalOutput = 0.915;

            }

            else
            {
                integral = (integral + (Error * deltaTime));
                if (integral >20)
                {
                    integral = 20;
                }
                if (integral <-20)
                {
                    integral = -20;
                }
                //derivative = (Error - Error_1) / deltaTime;
                derivative = (Error + (3 * Error_1) - (3 * Error_2) - ((1 / 6) * Error_3));

                PID = ((Error * Kp) + (integral * Ki) + (derivative * Kd));
                PumpOutputVoltagePID = scaleSP + PID;//setPointValue + PID;
                TotalOutput = PumpOutputVoltagePID;
            }

            if(setPointValue==0)
            {
               
                integral = 0;
                derivative = 0;
                Error = 0;
                Error_1 = 0;
                Error_2 = 0;
                Error_3 = 0;
                TotalOutput = 0;
            }

            if (setPointValueOld == 0 && setPointValueNew !=0)
            {
                startCounter = 0;
                Error = 0.00842;
                integral = -8.1526;
                derivative = 0.00161;
                PID = (errorValue * Kp) + (integral * Ki) + (derivative * Kd);
                TotalOutput = 0.915;

            }


            if (TotalOutput < 0.00)
            {
                //Console.WriteLine("negative output:  {0:F04}", OutputVoltage);
                TotalOutput = 0.00;
            }
            if (TotalOutput >= 5.0)
            {
                //Console.WriteLine("too high...:  {0:F04}", OutputVoltage);
                TotalOutput = 4.96;
            }

            //}
            Error_3 = Error_2;
            Error_2 = Error_1;
            Error_1 = Error;


            //PumpOutputVoltage_1 = PumpOutputVoltage;
            PumpOutputNew = TotalOutput; //PumpOutputVoltage;



            do
            {
                try
                {
#if TURNON_NIHARDWARE

                    if (PumpIntention == 1)
                    {
                        //Logger.WriteInternalLogFile("Output Calc.  PumpIntention = 1.");
                        AnalogSingleChannelWriter writeron = new AnalogSingleChannelWriter(PumpOutput.Stream);
                        writeron.WriteSingleSample(true, TotalOutput);
                    }
                    else
                    {
                        Logger.WriteInternalLogFile("Output Calc.  PumpIntention = 0.");
                        Logger.WriteInternalLogFile("Pump Intention = 0. Turning pump off.");
                        AnalogSingleChannelWriter writeron = new AnalogSingleChannelWriter(PumpOutput.Stream);
                        writeron.WriteSingleSample(true, 0.0);
                    }
#endif

                    writeOk = 1;
                }
                catch (Exception ex)
                {

                    Logger.WriteInternalLogFile("Write pump voltage Ex = " + ex.ToString());

                    counter += 1;
                }
            } while (writeOk == 0 && counter < 20);

            outputVoltageValue = TotalOutput;

            if (counter >= 20)
            {
                string msg;
                msg = "Error:  Pump output.";
                Logger.WriteInternalLogFile(msg);

            }

            setPointValueOld = setPointValue;


        }

        //end output calc *****************************


        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        static double InputAveraging(int pumpCounter)
        {
            double sum = 0.0;
            double avg = 0.0;
            int readOk = 0;
            int counter = 0;
            //string stringValue;

            do
            {
                try
                {

#if TURNON_NIHARDWARE
                    //reader = new AnalogMultiChannelReader(FlowSensorInput.Stream);
                    data = readerFlowSensor.ReadWaveform(samplesPerChannel);
                    readOk = 1;

                    //stringValue="";

                    // Iterate over channels
                    int currentLineIndex = 0;
                    foreach (AnalogWaveform<double> waveform in data)
                    {
                        for (int sample = 0; sample < waveform.Samples.Count; ++sample)
                        {
                            sum = sum + waveform.Samples[sample].Value;
                            currentLineIndex++;
                            //stringValue = waveform.Samples[sample].Value.ToString();

                            //dataFile2.WriteLine(stringValue);   //this does a file write (many be a real time restriction here!)
                            //Logger.WriteLogFile("C:\temp\flowraw.txt", waveform.Samples[sample].Value.ToString());
                        }
                    }

                    if (currentLineIndex > 0)
                    {
                        avg = sum / currentLineIndex;
                        break;
                    }
                    //Logger.WriteLogFile("C:/temp/flowraw.txt", "************ avg = "+avg.ToString() );
                    //.WriteLine(" *** flow sensor INPUT AVG=, {0}", avg);
                    //Console.WriteLine(" >>>>>>>>>>>>>> flow sensor:  AVG= {0}", avg);

#else

                    readOk = 1;

#endif

                    //Logger.WriteLogFile("c:\\temp\\flow.txt", "flow sensor input (avg) = " + avg.ToString());

                }

                catch (Exception Ex)
                {
                    counter += 1;
                    //if (counter >= 10)
                    //{
                    //    msg = "Flow Sensor ex=  " + ex.ToString();
                    //    Logger.WriteErrorFile(msg);
                    //    msg = "flow sensor read counter= " + counter.ToString();
                    Logger.WriteInternalLogFile("Exception in flow sensor input.  Ex ="+Ex.ToString() );

                    //}

                }

            } while (readOk == 0 && counter < 50);
            string msg;

            if (counter >= 50)
            {
                msg = "Error flow sensor";
                Logger.WriteInternalLogFile(msg);
                msg = "Error flow sensor read counter= " + counter.ToString();
                Logger.WriteInternalLogFile(msg);

            }

            //if (pumpCounter < 8)
            //    alpha = 1.0;
            //else
            //    alpha = 0.15;

            switch (pumpCounter)
            {
                case 0:
                    alpha = 1.0;
                    break;
                case 1:
                    alpha = .95;
                    break;
                case 2:
                    alpha = 0.9;
                    break;
                case 3:
                    alpha = 0.9;
                    break;
                case 4:
                    alpha = 0.8;
                    break;
                case 5:
                    alpha = 0.7;
                    break;
                case 6:
                    alpha = 0.6;
                    break;
                case 7:
                    alpha = 0.5;
                    break;
                case 8:
                    alpha = 0.3;
                    break;
                case 9:
                    alpha = 0.15;
                    break;
                default:
                    alpha = 0.15;
                    break;

            }



            flowInput1 = flowInput0;
            flowInput0 = avg;
            flowInputIndex++;

            if (flowInputIndex >= 2)
            {
                flowInputIndex = 2;

                //perform digital  Filter:
                if (flowInputIndex >= 2)
                {
                    flowOutputIndex++;
                    if (flowOutputIndex >= 2)
                    {
                        flowOutputIndex = 2;
                    }
                    //generate output
                    flowOutput1 = flowOutput0;
                    // HPF flowOutput[0] = (alpha * flowOutput[1]) + (alpha * (flowInput[0] - flowInput[1]));

                    //LPF here:
                    flowOutput0 = (alpha * flowInput0) + ((1 - alpha) * flowOutput1);
                    Logger.WriteLogFile( flowOutput0.ToString(), "C:\temp\filteredflow.txt");
                    return flowOutput0;
                    //y[i] := α * x[i] + (1 - α) * y[i - 1]
                }
            }

            return avg;




        }



        //***********************************************************************************************************
        

        public partial class Background
        {

            public BackgroundWorker m_oWorkerAcq;              //threads for acquision control state machines
            public BackgroundWorker m_oWorkerEcal;
            public BackgroundWorker m_oWorkerUpscale;
            public BackgroundWorker m_oWorkerManualAcq;
            public BackgroundWorker m_oLeakCheck;
            public BackgroundWorker m_oWorkerTubeSeasoning;
            public BackgroundWorker m_oWorkerFiveMinute;      //five minute thread -- used for clearing modbus error after five minutes

        }



        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void metroStatusButton_Click(object sender, EventArgs e)
        {
            //Display Error list from halt function calls
            Color Value = metroStatusButton.BackColor;
            //DataContainer.displayItem = 1;
            

            if (metroStatusButton.BackColor.R == 240 && metroStatusButton.BackColor.G == 240 && metroStatusButton.BackColor.B == 240)
            {
                DataContainer.displayItem = 0;
               
            }
            else if(metroStatusButton.BackColor==Color.Green)
            {
                DataContainer.displayItem = 0;
            }
            else if (metroStatusButton.BackColor == Color.Yellow)
            {
                DataContainer.displayItem = 1;
            }
            else if (metroStatusButton.BackColor == Color.Red)
            {
                DataContainer.displayItem = 2;
            }
            //else
            //{
            //    DataContainer.displayItem = 0;
            //}
            



            Form fstatus = new FormStatus();
            fstatus.ShowDialog();

            //check button state:
            //if red display
            //Display Error list from halt function calls
            //if yellow display most recent warning.txt
            //get the most recent error file from c:/temp
            /*
            int count = 0;

            System.Linq.IOrderedEnumerable<string> fileItems = Directory.GetFiles(@"C:\Upscale_Data", "*.txt").OrderByDescending(d => new FileInfo(d).CreationTime);
            foreach (string item in fileItems)
            {
                count++;
                //ix = 0;
                if (count > fileItems.Count() || count > 1)  //only fill arrays to the 4 most recent upscale files
                {
                    break;

                }
                //read through the file to display error infoline by line

                System.IO.StreamReader sr = new System.IO.StreamReader(item path + value);


                string fText = sr.ReadToEnd();
                rtbData.SelectionStart = 0;  // or wherever you want to insert in this rtb
                rtbData.SelectionLength = 0;
                rtbData.SelectionFont = new System.Drawing.Font("Tahoma", 14);
                rtbData.SelectedText = fText;

                sr.Close();





            }
        */

        }
        private void metroPanel1_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {

        }

        private void metroTabPage4_Click(object sender, EventArgs e)
        {
            //settings tab clicked

            //if (metroTabPage4.Text.Contains("Settings"))
            //{

            //}

        }









        private void metroToggle4_CheckedChanged(object sender, EventArgs e)
        {
            //pump control calibration GUI

        }

        private void metroLabel31_Click(object sender, EventArgs e)
        {

        }

        private void metroLabel33_Click(object sender, EventArgs e)
        {

        }

        private void metroPanel10_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {

        }

        private void metroLabel40_Click(object sender, EventArgs e)
        {

        }

        private void metroTextBox44_Click(object sender, EventArgs e)
        {

        }


        /// <summary>
        /// 
        /// </summary>
        public partial class ErrorClass
        {
            //hold error values and determine action
            public int ErrorCode;

            public int ErrorCounter;


            public string GetTimeStampStr()
            {

                DateTime timeStamp;
                timeStamp = DateTime.Now;
                return timeStamp.ToString("MM/dd/yyyy  HH:mm:ss:ffff ");

            }

        }

        interface ISIO
        {
            void WriteSerialPort(string message);
            //string GetResponse();

            void ClrWaitResponse();
            int GetWaitResponse();

            void CloseSerialPort();
            void OpenSerialPort();
            string GetResponseString();
            


        }

        //class for serial port function: EZ4axis
        public class SerialIO : ISIO
        {

            public string returnValue;
            public int responseVariable = 0;
            public SerialPort serialCommPort;
            public ReaderWriterLockSlim _SerialIOLock = new ReaderWriterLockSlim();
            public string serialResponseString;

            public string GetResponseString()
            {
                return serialResponseString;


            }
            public void ClrWaitResponse()
            {
                responseVariable = 0;

            }

            public int GetWaitResponse()
            {

                return responseVariable;

            }


            public void initSerialIO()
            {

                try
                {
                    serialCommPort = new SerialPort();

                    ////serial port set up
                    serialCommPort.PortName = "COM" + Properties.Settings.Default.MotorComPort.ToString();
                    serialCommPort.BaudRate = 9600;  //use properties
                    serialCommPort.StopBits = StopBits.One;
                    serialCommPort.Parity = Parity.None;
                    serialCommPort.DataBits = 8;
                    serialCommPort.Handshake = Handshake.None;

                    //serialCommPort.RtsEnable = true;

                    serialCommPort.Open();
                    serialCommPort.DataReceived += new SerialDataReceivedEventHandler(SerialDataReceivedHandler);
                    //mySerialPort.DataReceived += new SerialDataReceivedEventHandler(DataReceivedHandler);

                }
                catch (Exception ex)
                {
                    string msg;
                    msg = "serial port: ex= " + ex.ToString();
                    //WriteErrorFile(msg);
                    Logger.WriteInternalLogFile(msg);
                }

            }

            public void Dispose()
            {
                serialCommPort.Dispose();
            }

            /// <summary>
            ///  this implements thread safe file write
            /// 
            /// </summary>
            /// <param name="errorMessage"></param>
            public void WriteSerialPort(string message)
            {

                try
                {
                    _SerialIOLock.EnterWriteLock();
                    serialCommPort.Write(message);

                }
                catch (Exception ex)
                {
                    string msg;
                    msg = "serial port: Write Serial Port ex= " + ex.ToString();
                    //WriteErrorFile(msg);
                    Logger.WriteInternalLogFile(msg);
                }


                finally
                {
                    _SerialIOLock.ExitWriteLock();
                }
            }


            /// <summary>
            /// 
            /// </summary>
            /// <param name="sender"></param>
            /// <param name="e"></param>
            /// 
            //public static void DataReceivedHandler(object sender, SerialDataReceivedEventArgs e)
            public void SerialDataReceivedHandler(
                                object sender,
                                SerialDataReceivedEventArgs e)
            {
                //working example:
                //SerialPort sp = (SerialPort)sender;
                //string indata = sp.ReadExisting();
                //Console.WriteLine("Data Received:");
                //Console.Write(indata);



                byte[] bytes;

                SerialPort sp = (SerialPort)sender;
                string value = sp.ReadExisting();
                //Logger.WriteLogFile("EZ4 Serial Port response string = " + value);


                serialResponseString = value;
                returnValue = value;

                responseVariable = 1;
                bytes = Encoding.ASCII.GetBytes(value);



            }
            public void ClearSerialResponseString()
            {
                serialResponseString = "";
            }


            public string GetResponse()
            {
                string value = "default";
                return value;
            }


            public void CloseSerialPort()
            {
                try
                {

                    if (serialCommPort.IsOpen)
                    {
                        serialCommPort.Close();
                    }

                }
                catch (Exception ex)
                {
                    string msg;
                    msg = "Error serial port: ex= " + ex.ToString();
                    //WriteErrorFile(msg);
                    Logger.WriteInternalLogFile(msg);
                }

            }

            public void OpenSerialPort()
            {
                try
                {

                    if (!serialCommPort.IsOpen)
                    {
                        serialCommPort.Open();
                    }

                }
                catch (Exception ex)
                {
                    string msg;
                    msg = "serial port: ex= " + ex.ToString();
                    //WriteErrorFile(msg);
                    Logger.WriteInternalLogFile(msg);
                }
            }
        }






        interface ISIOControlLines
        {
            void WriteSerialPort(string message);
            string GetResponse();

            void ClrWaitResponse();
            int GetWaitResponse();

            void CloseSerialPort();
            void OpenSerialPort();
            string GetResponseString();

            void ClrOutputPin7();
            bool GetOutputPin7();
            void SetOutputPin4();
            bool GetOutputPin4();
            void ClrOutputPin4();
                



        }

        //class for serial port function: 
        //the main purpose is to control IO pins on 
        //RS232 pins 7 and 4 are possible

        public class SerialControlLinesIO : ISIOControlLines
        {

            public string returnValue;
            public int responseVariable = 0;
            public SerialPort serialCommPort;
            public ReaderWriterLockSlim _SerialIOLock = new ReaderWriterLockSlim();
            public string serialResponseString;
            
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            public string GetResponseString()
            {
                return serialResponseString;


            }
            /// <summary>
            /// 
            /// </summary>
            public void ClrWaitResponse()
            {
                responseVariable = 0;

            }
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            public int GetWaitResponse()
            {

                return responseVariable;

            }

            /// <summary>
            /// 
            /// </summary>
            public void initSerialIO()  //control lines
            {

                try
                {
                    if (serialCommPort== null)
                    {

                        serialCommPort = new SerialPort();

                    }
                    else
                    {

                        serialCommPort.Dispose();
                        int count = 0;
                        while (serialCommPort==null && count <= 5)
                        {

                            count++;
                            Thread.Sleep(500);
                        }
                        serialCommPort = new SerialPort();

                    }
                    ////serial port set up
                    serialCommPort.PortName = "COM" + Properties.Settings.Default.ModbusComPort.ToString();
                    serialCommPort.BaudRate = 9600;  //use properties
                    serialCommPort.StopBits = StopBits.One;
                    serialCommPort.Parity = Parity.None;
                    serialCommPort.DataBits = 8;
                    serialCommPort.Handshake = Handshake.None;

                    serialCommPort.Close();    

                    serialCommPort.Open();

                    //serialCommPort.RtsEnable = true;
                    serialCommPort.DataReceived += new SerialDataReceivedEventHandler(SerialDataReceivedHandler);


                }
                catch (Exception ex)
                {
                    string msg;
                    msg = "serial port: ex= " + ex.ToString();
                    //WriteErrorFile(msg);
                    Logger.WriteInternalLogFile(msg);
                }

            }
            public void Dispose()
            {
                serialCommPort.Dispose();
            }

            public void SetOutputPin7()
            {
                serialCommPort.RtsEnable = true;     //does enable =true == logic hi

            }
            public void ClrOutputPin7()
            {
                serialCommPort.RtsEnable = false;    

            }

            public bool GetOutputPin7()
            {
                return serialCommPort.RtsEnable;
            }

            public void SetOutputPin4()
            {
                serialCommPort.DtrEnable = true;     
            }

            public bool GetOutputPin4()
            {
                return serialCommPort.DtrEnable;
            }

            public void ClrOutputPin4()
            {
                serialCommPort.DtrEnable = false;
            }




            /// <summary>
            ///  this implements thread safe file write
            /// 
            /// </summary>
            /// <param name="errorMessage"></param>
            public void WriteSerialPort(string message)
            {

                try
                {
                    _SerialIOLock.EnterWriteLock();
                    serialCommPort.Write(message);

                }
                catch (Exception ex)
                {
                    string msg;
                    msg = "serial port: Write Serial Port ex= " + ex.ToString();
                    //WriteErrorFile(msg);
                    Logger.WriteInternalLogFile(msg);
                }


                finally
                {
                    _SerialIOLock.ExitWriteLock();
                }
            }


            /// <summary>
            /// 
            /// </summary>
            /// <param name="sender"></param>
            /// <param name="e"></param>
            public void SerialDataReceivedHandler(
                                object sender,
                                SerialDataReceivedEventArgs e)
            {
                byte[] bytes;
                SerialPort sp = (SerialPort)sender;
                string value = sp.ReadExisting();

                serialResponseString = value;
                returnValue = value;

                responseVariable = 1;
                bytes = Encoding.ASCII.GetBytes(value);



            }


            public string GetResponse()
            {
                string value = "default";
                return value;
            }


            public void CloseSerialPort()
            {
                try
                {

                    if (serialCommPort.IsOpen)
                    {
                        serialCommPort.Close();
                    }

                }
                catch (Exception ex)
                {
                    string msg;
                    msg = "Error serial port: ex= " + ex.ToString();
                    //WriteErrorFile(msg);
                    Logger.WriteInternalLogFile(msg);
                }

            }

            public void OpenSerialPort()
            {
                try
                {

                    if (!serialCommPort.IsOpen)
                    {
                        serialCommPort.Open();
                    }

                }
                catch (Exception ex)
                {
                    string msg;
                    msg = "serial port: ex= " + ex.ToString();
                    //WriteErrorFile(msg);
                    Logger.WriteInternalLogFile(msg);
                }
            }
        }





        //class for serial port functions:
        //since there are only two added second class for communicating with the wind speed sensor
        /// <summary>
        /// 
        /// </summary>
        public class SerialWindSpeedandDirIO
        {


            public string returnValue;
            public int responseVariable = 0;
            public SerialPort serialCommPort;
            public ReaderWriterLockSlim _SerialIOLockWS = new ReaderWriterLockSlim();
            public string serialResponseString;

            public void ClrResponseString()
            {
                serialResponseString = "";
            }

            public string GetResponseString()
            {
                return serialResponseString;


            }
            public void ClrWaitResponse()
            {
                responseVariable = 0;

            }

            public int GetWaitResponse()
            {

                return responseVariable;

            }


            public void initSerialIO()
            {

                try
                {
                    serialCommPort = new SerialPort();

                    ////serial port set up
                    serialCommPort.PortName = "COM" + Properties.Settings.Default.WindComPort.ToString();    //read baud rate from settings parameters
                    serialCommPort.BaudRate = 9600;  //may need to add this to settings screen

                    serialCommPort.StopBits = StopBits.One;
                    serialCommPort.Parity = Parity.None;
                    serialCommPort.DataBits = 8;
                    serialCommPort.Handshake = Handshake.None;

                    serialCommPort.RtsEnable = false;  //for wind speed this needs to be false

                    if (serialCommPort.IsOpen == true)
                    {
                        serialCommPort.Close();
                    }
                    else
                    {
                        serialCommPort.Open();
                    }
                    serialCommPort.DataReceived += new SerialDataReceivedEventHandler(WindSpeedSerialDataReceivedHandler);

                }
                catch (Exception ex)
                {
                    string msg;
                    msg = "Error:  wind speed and dir serial port: Ex = " + ex.ToString();
                    //WriteErrorFile(msg);
                    Logger.WriteInternalLogFile(msg);
                }

            }

            public void Dispose()
            {
                serialCommPort.Dispose();
            }


            /// <summary>
            ///  
            /// 
            /// </summary>
            /// <param name="errorMessage"></param>
            public void WriteSerialPort(string message)
            {

                try
                {
                    _SerialIOLockWS.EnterWriteLock();
                    serialCommPort.Write(message);


                }
                catch (Exception ex)
                {
                    string msg;
                    msg = "Error: Wind Speed and Dir serial port: Write Serial Port. Ex = " + ex.ToString();
                    //WriteErrorFile(msg);
                    Logger.WriteErrorFile(msg);

                }


                finally
                {
                    _SerialIOLockWS.ExitWriteLock();
                }
            }


            /// <summary>
            /// 
            /// </summary>
            /// <param name="sender"></param>
            /// <param name="e"></param>
            public void WindSpeedSerialDataReceivedHandler(
                                object sender,
                                SerialDataReceivedEventArgs e)
            {
                SerialPort port = (SerialPort)sender;
                byte[] bufferBytes = new byte[port.BytesToRead];


                string dataString = "";
                try
                {
                    port.Read(bufferBytes, 0, bufferBytes.Length);
                    dataString = Encoding.ASCII.GetString(bufferBytes);

                }
                catch (TimeoutException)
                {
                    //Console.WriteLine("TimeoutException: Failed to talk to sensor");
                    Logger.WriteInternalLogFile("Error:  Timeout Exception.  Failed to talk to wind sensor.");
                    dataString = "no data";
                }
                serialResponseString += dataString;

                //check for complete serial response string....

                // if complete, parse it out 
                //   set data complete via:  responseVariable = 1;



                //Console.WriteLine(dataString);
                //windData.Add(dataString);
                //TextWriter windFile = new StreamWriter(@"C:\Users\BrianC\Desktop\rawWind.txt", true);
                //windFile.WriteLine(dataString);
                //windFile.Close();
                //port.Write("!");
                //Thread.Sleep(500);
                //index++;




                //string value = sp.ReadExisting();

                //sp.Read()
                //serialResponseString = value;
                //returnValue = value;

                //bytes = Encoding.ASCII.GetBytes(value);
                //tbMetroCalPrompt.Text = returnValue;

                //processValue(value);



            }




            public string GetResponse()
            {
                string value = "default";
                return value;
            }

            ////public static byte[] StringToByteArray(String hex)
            ////{
            ////    int NumberChars = hex.Length;
            ////    byte[] bytes = new byte[NumberChars / 2];
            ////    for (int i = 0; i < NumberChars; i += 2)
            ////        bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
            ////    return bytes;
            ////}




            public void CloseSerialPort()
            {
                try
                {

                    if (serialCommPort.IsOpen)
                    {
                        serialCommPort.Close();
                    }

                }
                catch (Exception ex)
                {
                    string msg;
                    msg = "serial port: ex= " + ex.ToString();
                    //WriteErrorFile(msg);
                    Logger.WriteErrorFile(msg);
                }

            }

            public void OpenSerialPort()
            {
                try
                {

                    if (!serialCommPort.IsOpen)
                    {
                        serialCommPort.Open();
                    }

                }
                catch (Exception ex)
                {
                    string msg;
                    msg = "serial port: ex= " + ex.ToString();
                    //WriteErrorFile(msg);
                    Logger.WriteErrorFile(msg);
                }

            }


        }
        // *** end of Wind Speed and Direction Serial Port logic










        /// <summary>
        /// Functions to read/write ini file
        /// </summary>
        public static class IniFile
        {
            [DllImport("kernel32")]
            private static extern long WritePrivateProfileString(string section, string key, string val, string filePath);
            [DllImport("kernel32")]
            private static extern int GetPrivateProfileString(string section, string key, string def, StringBuilder retVal, int size, string filePath);

            public static void WriteValue(string path, string Section, string Key, string Value)
            {
                WritePrivateProfileString(Section, Key, Value, path);
            }

            public static string ReadValue(string path, string Section, string Key)
            {
                StringBuilder temp = new StringBuilder(255);
                int i = GetPrivateProfileString(Section, Key, "", temp, 255, path);
                return temp.ToString();
            }
        }








        /*
        interface IAL
        {
            double GetRemainingTime();
            void SetStartTime(double startTime);
            void SetSamplePeriod(int samplePeriodValue);
            int GetSamplePeriod();
            int MoveTapeFull(SerialIO SerialManager, Form1 f);     //add serial port logic here
            int MoveTapeHalf(SerialIO SerialManager, Form1 f); //

            int MoveRodHome(SerialIO SerialManager, Form1 f);
            int MoveFWHome(SerialIO SerialManager, Form1 f);
            int NozzleDown(SerialIO SerialManager, Form1 f);
            int NozzleUp(SerialIO SerialManager, Form1 f );


            void SetAcquireStartTime(DateTime StartAcquire);
            DateTime GetAcquireStartTime();
            DateTime GetAcquireEndTime(DateTime DTNow);
            int GetState();
            void SetState(int State);
            int PumpOn(BackgroundWorker m_oWorkerPump);
            int PumpOff(BackgroundWorker m_oWorkerPump);

            void SetSerialWait(int wait);
            int GetSerialWait();
            //string GetSerialResponse();

            void SetCounter(int counter);
            void IncCounter();
            int GetCounter();

            void IncTimerCounter();
            int GetTimerCounter();
            void ClrTimerCounter();

            void Test(SerialIO SerialManager);

            void SetEnergyCondition(int energyConditionValue);
            int GetEnergyCondition();

            void SetFilterWheelPosition(int fwPosition);
            int GetFilterWheelPosition();

            List<double> GetRampVoltageValues();
            List<double> GetRampCurrentValues();

            //int RampXrays(double Voltage, double Current, BackgroundWorker m_oWorkerRamp);
            int RampXrays(double presentV, double presentI, double targetVoltage, double targetCurrent, BackgroundWorker m_oWorkerRamp, List<double> VoltageValues, List<double> CurrentValues, Form1 f);
            int AutoAnalyze();

            bool GetEC1Done();
            bool GetEC2Done();
            bool GetEC3Done();

            void SetEC1Done(bool ec1Done);
            void SetEC2Done(bool ec2Done);
            void SetEC3Done(bool ec3Done);



        }
        //class AcquisitionLogic : IAL
        */

        public class AcquisitionLogic //: IAL
        {
            static readonly AcquisitionLogic _instance = new AcquisitionLogic();
            public static AcquisitionLogic Instance
            {
                get
                {
                    //Logger.WriteInternalLogFile("returning acquisition control instance.");
                    return _instance;

                }
            }
            public AcquisitionLogic()
            {
                //Logger.WriteInternalLogFile("1");

                InterlockOutput = new NationalInstruments.DAQmx.Task();
                //Logger.WriteInternalLogFile("2");
                InputVoltage = new NationalInstruments.DAQmx.Task();
                //Logger.WriteInternalLogFile("3");
                InputCurrent = new NationalInstruments.DAQmx.Task();
                //Logger.WriteInternalLogFile("4");
                PumpOutputOffAcq = new NationalInstruments.DAQmx.Task();
                //Logger.WriteInternalLogFile("5");
                //define the pump output

#if TURNON_NIHARDWARE

                //define the interlock output
                InterlockOutput.DOChannels.CreateChannel("Dev1/port0/line0", "doChannel0", ChannelLineGrouping.OneChannelForEachLine);
                PumpOutputOffAcq.AOChannels.CreateVoltageChannel("Dev1/ao3", "aoChannel", 0.000, 4.999, AOVoltageUnits.Volts);

                //Logger.WriteInternalLogFile("6");

#endif
            }

            DateTime errorFileStartDateTime;

            int ECALProcess;
            int UpscaleProcess;

            double minValueStart; //= AcquisitionStartTime.Minute;

            double secValue1, secValue2, secValue3, secValue4;


            const int PASS = 1;
            const int FAIL = 0;
            const int FAIL_NOZZLE = 2;


            static private NationalInstruments.DAQmx.Task PumpOutputOffAcq;




            int fwEC1Pos = Properties.Settings.Default.FWEC1;  //add read from Settings.Default.FWEC1   //assign the settings filter for EC1 -- i.e. read settings Al, Pd, Cu + other
            int fwEC2Pos = Properties.Settings.Default.FWEC2;                                           //assign the settings filter for EC2 -- i.e. read settings Al, Pd, Cu + other
            int fwEC3Pos = Properties.Settings.Default.FWEC3;
            int fwEC4Pos = Properties.Settings.Default.FWEC4;
            //assign the settings filter for EC3 -- i.e. read settings Al, Pd, Cu + other

            double EC1Percent = Properties.Settings.Default.EC1RTP;
            double EC2Percent = Properties.Settings.Default.EC2RTP;
            double EC3Percent = Properties.Settings.Default.EC3RTP;
            double EC4Percent = Properties.Settings.Default.EC4RTP;

            DateTime EC1EndTime;
            DateTime EC2EndTime;
            DateTime EC3EndTime;
            DateTime EC4EndTime;

            DateTime PumpTime;
            DateTime PumpTimePrevious;

            bool EC1Enabled = false;
            bool EC2Enabled = false;
            bool EC3Enabled = false;
            bool EC4Enabled = false;

            bool EC1Done = false;
            bool EC2Done = false;
            bool EC3Done = false;
            bool EC4Done = false;


            static private NationalInstruments.DAQmx.Task InterlockOutput; // digital output for interlock ssr

            static private NationalInstruments.DAQmx.Task InputCurrent;
            static private NationalInstruments.DAQmx.Task InputVoltage;
            static public AnalogWaveform<double>[] InputVoltageData;
            static public AnalogWaveform<double>[] InputCurrentData;



            double timeValue = 9;
            double actualStartTime;
            DateTime StartAcquireTime;
            int samplePeriod = 15;
            int stateControl;
            int stateControlTS;
            //private object m_oWorkerPump;
            //static Thread serialthread;
            //int waitVariable;
            int waitSerialVariable;

            //normal/manual acquisition counter variable
            static int counterVariable;
            static int counterVariableTS;
            static int pumpLockCounterVariable;

            //separate pump thread counter from normal acquisition counter
            static int pumpCounterVariable;
            static int pumpLeakCheckVariable = 0;


            // string getSerialResponseString;

            int timerCounter = 0;
            int energyCondition;
            int previousEnergyCondition;

            int filterWheelCurrentPosition;

            List<double> RampCurrentValues;
            List<double> RampVoltageValues;


            double FlowVolumeValue;
            double SavedFlowVolumeForAnalysis;

            double Item;

            //*** wind speed and direction

            List<double> WindSpeed1 = new List<double>();
            List<double> WindDirection1 = new List<double>();
            List<string> WindData1 = new List<string>();

            double AvgSpeed1;
            double AvgDirection1;

            List<double> WindSpeed2 = new List<double>();
            List<double> WindDirection2 = new List<double>();
            List<string> WindData2 = new List<string>();

            double AvgSpeed2;
            double AvgDirection2;

            //DateTime ErrorFileStart;
            //DateTime LogFileStart;




            //*** end wind speed and direction variables


            //bhcop
            //operation parameters:
            List<double> TubeTemp1 = new List<double>();
            List<double> TubeTemp2 = new List<double>();
            List<double> EnclosureTemp1 = new List<double>();
            List<double> EnclosureTemp2 = new List<double>();
            ushort[] Time1 = new ushort[6];
            ushort[] Time2 = new ushort[6];
            List<double> AmbientTemp1 = new List<double>();
            List<double> AmbientTemp2 = new List<double>();
            List<double> SampleTemp1 = new List<double>();
            List<double> SampleTemp2 = new List<double>();
            List<double> AtmPress1 = new List<double>();
            List<double> AtmPress2 = new List<double>();
            List<double> TapePress1 = new List<double>();
            List<double> TapePress2 = new List<double>();
            List<double> FilamentMonitor1 = new List<double>();
            List<double> FilamentMonitor2 = new List<double>();
            List<double> FlowAct1 = new List<double>();
            List<double> FlowAct2 = new List<double>();
            List<double> FlowStd1 = new List<double>();


            List<double> FlowStd60s = new List<double>();
            List<double> FlowAct60s = new List<double>();


            List<double> FlowStd2 = new List<double>();
            List<double> Flow251 = new List<double>();
            List<double> Flow252 = new List<double>();
            List<double> Volume1 = new List<double>();
            List<double> Volume2 = new List<double>();
            List<double> RelativeHumidity1 = new List<double>();
            List<double> RelativeHumidity2 = new List<double>();
            List<double> SDDTemp1 = new List<double>();
            List<double> SDDTemp2 = new List<double>();
            List<double> DPPTemp1 = new List<double>();
            List<double> DPPTemp2 = new List<double>();
            List<string> Error1 = new List<string>();
            List<string> Error2 = new List<string>();
            List<string> Warning1 = new List<string>();
            List<string> Warning2 = new List<string>();

            int Alarm1;
            //int Alarm2;  // bhc alarms, being immediate, are logged when they occur.  Maybe a way to save and recall a list of alarms is better......


            static public bool Pin7OutputState1;   //to be added to the output files
            static public bool Pin7OutputState2;   //to be added to the output files

            static public DateTime DateTime1Start;
            static public DateTime DateTime2Start;


            /// <summary>
            /// 
            /// </summary>
            static int dataSet = 1;    //valid = 1 or 2  //default =1 


            /// <summary>
            /// Clear the average speed 
            /// </summary>
            public void ClrAvgSpeed()
            {
                if (GetDataSet() == 1)
                {
                    AvgSpeed1 = 0;
                    WindSpeed1.Clear();

                }
                else
                {
                    AvgSpeed2 = 0;
                    WindSpeed2.Clear();
                }

            }


            public void ClrAlarmValue()
            {
                if (GetDataSet() == 1)
                {
                    Alarm1 = 0;

                }
                else
                {
                    Alarm1 = 0;
                }

            }

            public double GetAlarmValue()
            {
                if (GetDataSet() == 1)
                {
                    return Alarm1;
                }
                else
                {
                    return Alarm1;
                }

            }




            /// <summary>
            /// Access the average wind speeed result
            /// </summary>
            /// <returns></returns>
            public double GetAvgSpeed()
            {
                if (GetDataSet() == 1)
                {
                    return AvgSpeed1;
                }
                else
                {
                    return AvgSpeed2;
                }

            }
            public void SetAlarmValue(int alarmValue)
            {
                if (GetDataSet() == 1)
                {
                    Alarm1 = alarmValue;
                }
                else
                {
                    Alarm1 = alarmValue;
                }

            }



            /// <summary>
            /// Set the average wind speed
            /// </summary>
            /// <param name="AverageSpeed"></param>
            public void SetAvgSpeed(float AverageSpeed)
            {
                if (GetDataSet() == 1)
                {
                    AvgSpeed1 = AverageSpeed;
                }
                else
                {
                    AvgSpeed2 = AverageSpeed;
                }

            }

            /// <summary>
            /// Access the Avg wind direction result
            /// </summary>
            /// <returns></returns>
            public double GetAvgDirection()
            {
                if (GetDataSet() == 1)
                {
                    return AvgDirection1;
                }
                else
                {
                    return AvgDirection2;
                }
            }


            /// <summary>
            /// Sets the average direction 
            /// </summary>
            /// <param name="AverageDirection"></param>
            public void SetAvgDirection(float AverageDirection)
            {
                if (GetDataSet() == 1)
                {
                    AvgDirection1 = AverageDirection;
                }
                else
                {
                    AvgDirection2 = AverageDirection;
                }
            }


            /// <summary>
            /// Clear the average direction
            /// </summary>
            public void ClrAvgDirection()
            {
                if (GetDataSet() == 1)
                {
                    AvgDirection1 = 0;
                    WindDirection1.Clear();
                }
                else
                {
                    AvgDirection2 = 0;
                    WindDirection2.Clear();
                }
            }


            // modbus DataStore
            public static DataStore xactHoldingRegisters;

            public DataStore getDataStore()
            {
                try
                {
                    Logger.WriteLogFile("XactHoldingRegs = " + xactHoldingRegisters.ToString(), "C:/temp/modbus_Logging_Data.txt");
                }
                catch
                {

                }
//                Logger.WriteLogFile("Set Data Store (XactHoldingRegs) = " + d.ToString(), "C:/temp/modbus_Logging_Data.txt");
                return xactHoldingRegisters;
            }

            public void setDataStore(DataStore d)
            {

                Logger.WriteLogFile("Set Data Store (XactHoldingRegs) = "+d.ToString(), "C:/temp/modbus_Logging_Data.txt");
                xactHoldingRegisters = d;
            }

            //List<double>TubeTemp1= new List<double>(); 

            //            errorString = new List<string>(); // static List<string> errorString;  //list of errors, times, ect.




            public void SetAcquisitionOpStartDateTime()
            {
                int DataSet = GetDataSet();
                if (DataSet == 1)
                {

                    DateTime1Start = DateTime.Now;
                    Logger.WriteLogFile("DS1 Set Acq Op Start time:  " + DateTime.Now.ToString());
                }
                else if (DataSet == 2)
                {
                    DateTime2Start = DateTime.Now;
                    Logger.WriteLogFile("DS2 Set Acq Op Start time:  " + DateTime.Now.ToString());
                }
            }
            public DateTime GetAcquisitionOpStartDateTime()
            {
                int DataSet = GetDataSet();
                if (DataSet == 1)
                {
                    return DateTime1Start;

                }
                else  //(DataSet == 2)
                {
                    return DateTime2Start;

                }

            }

            /// <summary>
            /// 
            /// </summary>
            public void ClrOperatingData()  //clears the dataset that is set
            {
                Logger.WriteLogFile("Clearing Data Set:  " + GetDataSet().ToString() + " operating data.");

                ClrTubeTemp();       //1
                ClrEnclosureTemp();
                ClrAmbientTemp();
                ClrSampleTemp();
                ClrAtmPress();       //5
                ClrFilamentMonitor();
                ClrRelativeHumidity();
                ClrSDDTemp();
                ClrDPPTemp();
                ClrFlowAct(); //10
                ClrVolume();
                ClrFlow25();
                ClrFlowStd();
                ClrError();
                ClrWarning(); //15
                ClrRelativeHumidity();
                ClrAvgSpeed();
                ClrAvgDirection();
                ClrAlarmValue();
                ClrTapePress();


            }




            //operation parameters
            //bhcop



            /// <summary>
            /// 
            /// </summary>
            /// <param name="WindSpeed"></param>
            public void SetWindSpeed(double WindSpeed)
            {
                try
                {
                    windSpeedStatic = WindSpeed;
                    if (runState == 1)
                    {

                        int dataSet = GetDataSet();
                        if (dataSet == 1)
                        {
                            WindSpeed1.Add(WindSpeed);
                            //double avg = WindSpeed1.Average();
                            //avg = (avg + WindSpeed / 2.0);
                            //WindSpeed1.Clear();
                            //WindSpeed1.Add(avg);

                        }
                        else
                        {
                            WindSpeed2.Add(WindSpeed);
                            //double avg = WindSpeed2.Average();
                            //avg = (avg + WindSpeed / 2.0);
                            //WindSpeed2.Clear();
                            //WindSpeed2.Add(avg);
                        }
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Can not add WindSpeed = " + WindSpeed.ToString() + " Ex = " + Ex.ToString());
                }
            }
            public void ClrWindSpeed()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    WindSpeed1.Clear();
                }
                else
                {
                    WindSpeed2.Clear();
                }

            }
            public List<double> GetWindSpeed()
            {
                int ldataSet = GetDataSet();
                if (ldataSet == 1)
                {
                    return WindSpeed1;
                }
                else
                {
                    return WindSpeed2;
                }
            }


            /// <summary>
            /// 
            /// </summary>
            /// <param name="WindDirection"></param>
            public void SetWindDirection(double WindDirection)
            {
                try
                {
                    windDirStatic = WindDirection;
                    if (runState == 1)
                    {

                        int dataSet = GetDataSet();
                        if (dataSet == 1)
                        {
                            //get the average
                            //double avg = WindDirection1.Average();
                            //avg = (avg + WindDirection / 2.0);
                            //WindDirection1.Clear();
                            //WindDirection1.Add(avg);
                            //clear the array
                            //save the average

                            WindDirection1.Add(WindDirection);

                        }
                        else
                        {
                            WindDirection2.Add(WindDirection);
                            //double avg = WindDirection2.Average();
                            //avg = (avg + WindDirection / 2.0);
                            //WindDirection2.Clear();
                            //WindDirection2.Add(avg);

                        }
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Can not add WindDirection = " + WindDirection.ToString() + " Ex = " + Ex.ToString());
                }
            }
            public void ClrWindDirection()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    WindDirection1.Clear();
                }
                else
                {
                    WindDirection2.Clear();
                }

            }
            public List<double> GetWindDirection()
            {
                int ldataSet = GetDataSet();
                if (ldataSet == 1)
                {
                    return WindDirection1;
                }
                else
                {
                    return WindDirection2;
                }
            }



            public int GetWindSpeedandDirectionAvg(out double WindAvg, out double DirAvg)
            {
                WindAvg = 0;
                DirAvg = 0;

                List<double> x = new List<double>();
                List<double> y = new List<double>();

                int ldataSet = GetDataSet();
                if (ldataSet == 1)
                {

                    try
                    {

                        for (int i = 0; i < WindSpeed1.Count; i++)
                        {

                            x.Add(WindSpeed1[i] * Math.Cos((Math.PI / 180) * WindDirection1[i]));
                            y.Add(WindSpeed1[i] * Math.Sin((Math.PI / 180) * WindDirection1[i]));
                        }

                        double x_ave = x.Average();
                        double y_ave = y.Average();



                        double speed_ave = Math.Sqrt(x_ave * x_ave + y_ave * y_ave);
                        double dir_ave = (180 / Math.PI) * Math.Atan2(y_ave, x_ave);
                        if (dir_ave < 0)
                        {
                            dir_ave += 360;
                        }


                        WindAvg = speed_ave;
                        DirAvg = dir_ave;

                        Logger.WriteLogFile("(d1)Wind Speed (avg) = " + WindAvg.ToString("F2"));
                        Logger.WriteLogFile("(d1)Wind Dir (avg) = " + DirAvg.ToString("F2"));

                        //Console.WriteLine("Average Speed: " + speed_ave);
                        //Console.WriteLine("Average Direction: " + dir_ave);

                        //string path = @"C:\Users\ces\Desktop\windLog.txt";
                        //TextWriter logFile = new StreamWriter(path, true);
                        //logFile.WriteLine("Speed: {0}, Dir: {1}", speed_ave, dir_ave);
                        //logFile.Close();


                        return PASS;
                    }
                    catch (Exception Ex)
                    {
                        Logger.WriteInternalLogFile("Ex in GetWindSpeedandDirectionAvg (dataset1). Ex = " + Ex.ToString());
                        WindAvg = 0;
                        DirAvg = 0;
                        return FAIL;
                    }
                }
                else
                {

                    try
                    {

                        for (int i = 0; i < WindSpeed2.Count; i++)
                        {

                            x.Add(WindSpeed2[i] * Math.Cos((Math.PI / 180) * WindDirection2[i]));
                            y.Add(WindSpeed2[i] * Math.Sin((Math.PI / 180) * WindDirection2[i]));
                        }

                        double x_ave = x.Average();
                        double y_ave = y.Average();



                        double speed_ave = Math.Sqrt(x_ave * x_ave + y_ave * y_ave);
                        double dir_ave = (180 / Math.PI) * Math.Atan2(y_ave, x_ave);
                        if (dir_ave < 0)
                        {
                            dir_ave += 360;
                        }


                        WindAvg = speed_ave;
                        DirAvg = dir_ave;

                        Logger.WriteLogFile("(d2)Wind Speed (avg) = " + WindAvg.ToString("F2"));
                        Logger.WriteLogFile("(d2)Wind Dir (avg) = " + DirAvg.ToString("F2"));

                        //Console.WriteLine("Average Speed: " + speed_ave);
                        //Console.WriteLine("Average Direction: " + dir_ave);

                        //string path = @"C:\Users\BrianC\Desktop\windLog.txt";
                        //TextWriter logFile = new StreamWriter(path, true);
                        //logFile.WriteLine("Speed: {0}, Dir: {1}", speed_ave, dir_ave);
                        //logFile.Close();
                        return PASS;

                    }
                    catch (Exception Ex)
                    {
                        Logger.WriteInternalLogFile("Ex in GetWindSpeedandDirectionAvg (dataset 2). Ex = " + Ex.ToString());
                        WindAvg = 0;
                        DirAvg = 0;

                        return FAIL;
                    }

                }
            }






            /// <summary>
            /// 
            /// </summary>
            /// <param name="Volume"></param>
            public void SetVolume(double Volume)
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {

                    Volume1.Add(Volume);

                }
                else
                {
                    Volume2.Add(Volume);
                }
            }
            public void ClrVolume()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    Volume1.Clear();
                }
                else
                {
                    Volume2.Clear();
                }

            }
            public double GetVolume()
            {
                int ldataSet = 0;
                try
                {
                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return Volume1.Average();
                    }
                    else
                    {
                        return Volume2.Average();
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in get Volume avg.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return 1.234;
                }

            }


            /// <summary>
            /// tracks the output file state for pin7 for each sample time
            /// </summary>
            /// <param name="Pin7OutputState"></param>
            public void SetPin7OutputStateDataset(bool outputState)
            {
                try
                {
                    int dataSet = GetDataSet();
                    if (dataSet == 1)
                    {
                        Pin7OutputState1 = outputState;

                    }
                    else
                    {
                        Pin7OutputState2 = outputState;
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in Set OutputPin7Output.  DataSet = " + AcquisitionLogic.dataSet.ToString() + " Ex= " + Ex.ToString());
                    //return false;
                }

            }
            public void ClrPin7OutputStateDataset()
            {
                try
                {
                    int dataSet = GetDataSet();
                    if (dataSet == 1)
                    {
                        Pin7OutputState1 = false;
                    }
                    else
                    {
                        Pin7OutputState2 = false;
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in Clr OutputPin7Output.  DataSet = " + AcquisitionLogic.dataSet.ToString() + " Ex= " + Ex.ToString());
                    //return false;
                }

            }
            public bool GetPin7OutputStateDataset()
            {
                int ldataSet = 0;
                try
                {
                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return Pin7OutputState1;
                    }
                    else
                    {
                        return Pin7OutputState2;
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in get OutputPin7Output.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return false;
                }

            }

            //
            //60 second averaging flow logic for Std and Act flow 
            //used to trigger warning and errors
            //
            public void SetFlowStd60s(double FlowStd)
            {
                FlowStd60s.Add(FlowStd);
            }
            public void SetFlowAct60s(double FlowAct)
            {
                FlowAct60s.Add(FlowAct);
            }

            public void ClrFlowStd60s()
            {
                FlowStd60s.Clear();
            }
            public void ClrFlowAct60s()
            {
                FlowAct60s.Clear();
            }
            public double GetFlowStd60s()
            {
                try
                {
                    return FlowStd60s.Average();
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in get flow Std 60s  Ex= " + Ex.ToString());
                    return -1;
                }

            }



            public double GetFlowAct60s()
            {
                try
                {
                    return FlowAct60s.Average();
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in get flow avg Act 60s  Ex= " + Ex.ToString());
                    return -1;
                }

            }




            /// <summary>
            /// 
            /// </summary>
            /// <param name="FlowStd"></param>
            public void SetFlowStd(double FlowStd)
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    FlowStd1.Add(FlowStd);

                }
                else
                {
                    FlowStd2.Add(FlowStd);
                }
            }
            public void ClrFlowStd()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    FlowStd1.Clear();
                }
                else
                {
                    FlowStd2.Clear();
                }

            }
            public double GetFlowStd()
            {
                int ldataSet = 0;
                try
                {
                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return FlowStd1.Average();
                    }
                    else
                    {
                        return FlowStd2.Average();
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in get flow 25 std.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return 1.234;
                }

            }



            /// <summary>
            /// 
            /// </summary>
            /// <param name="FlowAct"></param>
            public void SetFlowAct(double FlowAct)
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    FlowAct1.Add(FlowAct);

                }
                else
                {
                    FlowAct2.Add(FlowAct);
                }
            }
            public void ClrFlowAct()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    FlowAct1.Clear();
                }
                else
                {
                    FlowAct2.Clear();
                }

            }
            public double GetFlowAct()
            {
                int ldataSet = 0;
                try
                {
                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return FlowAct1.Average();
                    }
                    else
                    {
                        return FlowAct2.Average();
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in get flow act average.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return 1.234;
                }

            }



            /// <summary>
            /// 
            /// </summary>
            /// <param name="Flow25"></param>
            public void SetFlow25(double Flow25)
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    Flow251.Add(Flow25);

                }
                else
                {
                    Flow252.Add(Flow25);
                }
            }
            public void ClrFlow25()
            {
                int dataSet = 0;

                dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    Flow251.Clear();
                }
                else
                {
                    Flow252.Clear();
                }




            }
            public double GetFlow25()
            {
                int ldataSet = 0;
                try
                {
                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return Flow251.Average();
                    }
                    else
                    {
                        return Flow252.Average();
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in get flow 25 average.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return 1.234;
                }
            }


            /// <summary>
            /// 
            /// </summary>
            /// <param name="TubeTemp"></param>
            public void SetTubeTemp(double TubeTemp)
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    TubeTemp1.Add(TubeTemp);
                }
                else
                {
                    TubeTemp2.Add(TubeTemp);
                }
            }
            public void ClrTubeTemp()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    TubeTemp1.Clear();
                }
                else
                {
                    TubeTemp2.Clear();
                }

            }
            public double GetTubeTemp()
            {
                int ldataSet = 0;
                try
                {

                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return TubeTemp1.Average();
                    }
                    else
                    {
                        return TubeTemp2.Average();
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in get tube temp.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return 1.234;
                }

            }
            /// <summary>
            /// 
            /// </summary>
            /// <param name="EnclosureTemp"></param>
            public void SetEnclosureTemp(double EnclosureTemp)
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    EnclosureTemp1.Add(EnclosureTemp);
                }
                else
                {
                    EnclosureTemp2.Add(EnclosureTemp);
                }
            }
            public void ClrEnclosureTemp()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    EnclosureTemp1.Clear();
                }
                else
                {
                    EnclosureTemp2.Clear();
                }
            }

            public double GetEnclosureTemp()
            {
                int ldataSet = 0;
                try
                {
                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return EnclosureTemp1.Average();
                    }
                    else
                    {
                        return EnclosureTemp2.Average();
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in get enclosure temp.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return 1.234;
                }

            }

            /// <summary>
            /// 
            /// </summary>
            /// <param name="AmbientTemp"></param>
            public void SetAmbientTemp(double AmbientTemp)
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    AmbientTemp1.Add(AmbientTemp);
                }
                else
                {
                    AmbientTemp2.Add(AmbientTemp);
                }
            }
            public void ClrAmbientTemp()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    AmbientTemp1.Clear();
                }
                else
                {
                    AmbientTemp2.Clear();
                }
            }

            public double GetAmbientTemp()
            {
                int ldataSet = 0;
                try
                {
                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return AmbientTemp1.Average();
                    }
                    else
                    {
                        return AmbientTemp2.Average();
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in get ambient temp.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return 1.234;
                }

            }

            /////////////////////////////////////
            //pump start time
            /// <summary>
            /// 
            /// </summary>
            /// <param name="pump start time"></param>
            public void SetPumpStartTime(ushort [] time)
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    for (int i = 0; i <= 5; i++)
                    {
                        Time1[i] = time[i];
                    }
                }

                else
                {
                    for (int i = 0; i <= 5; i++)
                    {
                        Time2[i] = time[i];
                    }
                }
            }
            public void ClrPumpStartTime()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    for (int i = 0; i <= 5; i++)
                    {
                        Time1[i] =0;
                    }
                }
                else
                {
                    for (int i = 0; i <= 5; i++)
                    {
                        Time2[i] = 0;
                    }
                }
            }

            public ushort [] GetPumpStartTime()
            {
                int ldataSet = 0;
                try
                {
                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return Time1;
                    }
                    else
                    {
                        return Time2;
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in get Pump Start Time.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    ushort[] timeDefault = {0,1,2,3,4,5};
                    return timeDefault;
                }

            }



            /////////////////////////////////////
            /// <summary>
            /// 
            /// </summary>
            /// <param name="SampleTemp"></param>
            public void SetSampleTemp(double SampleTemp)
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    SampleTemp1.Add(SampleTemp);
                }
                else
                {
                    SampleTemp2.Add(SampleTemp);
                }
            }
            public void ClrSampleTemp()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    SampleTemp1.Clear();
                }
                else
                {
                    SampleTemp2.Clear();
                }
            }

            public double GetSampleTemp()
            {
                int ldataSet = 0;
                try
                {
                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return SampleTemp1.Average();
                    }
                    else
                    {
                        return SampleTemp2.Average();
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in get sample temp.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return 1.234;
                }

            }

            /// <summary>
            /// 
            /// </summary>
            /// <param name="AtmPress"></param>
            public void SetAtmPress(double AtmPress)
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    AtmPress1.Add(AtmPress);
                }
                else
                {
                    AtmPress2.Add(AtmPress);
                }
            }
            public void ClrAtmPress()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    AtmPress1.Clear();
                }
                else
                {
                    AtmPress2.Clear();
                }
            }

            public double GetAtmPress()
            {
                int ldataSet = 0;
                try
                {
                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return AtmPress1.Average();
                    }
                    else
                    {
                        return AtmPress2.Average();
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in get atmospheric pressure.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return 1.234;
                }

            }


            /// <summary>
            /// 
            /// </summary>
            /// <param name="TapePress"></param>
            public void SetTapePress(double TapePress)
            {
                try
                {
                    int dataSet = GetDataSet();
                    //Logger.WriteLogFile("dataSet = " + dataSet.ToString(), "c:/temp/TapePressureRaw.txt");
                    if (dataSet == 1)
                    {
                        //Logger.WriteLogFile("TAPE PRESS DS1, " + TapePress.ToString("F2"), "c:/temp/TapePressureRaw.txt");
                        TapePress1.Add(TapePress);
                    }
                    else
                    {
                        //Logger.WriteLogFile("TAPE PRESS DS2, " + TapePress.ToString("F2"), "c:/temp/TapePressureRaw.txt");
                        TapePress2.Add(TapePress);
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in set tape pressure.  DataSet = " + AcquisitionLogic.dataSet.ToString() + " Ex= " + Ex.ToString());

                }
            }
            public void ClrTapePress()
            {
                try
                {
                    int dataSet = GetDataSet();
                    if (dataSet == 1)
                    {
                        TapePress1.Clear();
                        //Logger.WriteLogFile("CLEAR SET 1", "c:/temp/TapePressureRaw.txt");
                        //Logger.WriteLogFile("count 1 = " + TapePress1.Count().ToString(), "c:/temp/TapePressureRaw.txt");
                        //Logger.WriteLogFile("count 2 = " + TapePress2.Count().ToString(), "c:/temp/TapePressureRaw.txt");
                    }
                    else
                    {
                        TapePress2.Clear();
                        //Logger.WriteLogFile("CLEAR SET 2", "c:/temp/TapePressureRaw.txt");
                        //Logger.WriteLogFile("count set 1 = " + TapePress1.Count().ToString(), "c:/temp/TapePressureRaw.txt");
                        //Logger.WriteLogFile("count set 2 = " + TapePress2.Count().ToString(), "c:/temp/TapePressureRaw.txt");
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in Clr tape pressure.  DataSet = " + dataSet.ToString() + " Ex= " + Ex.ToString());

                }
            }

            public double GetTapePress()
            {
                int ldataSet = 0;
                try
                {

                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        //Logger.WriteLogFile("Count = ," + TapePress1.Count().ToString(), "c:/temp/TapePressureRaw.txt");
                        //Logger.WriteLogFile("AVG   = ," + TapePress1.Average().ToString("F2"), "c:/temp/TapePressureRaw.txt");
                        return TapePress1.Average();

                    }
                    else
                    {
                        //Logger.WriteLogFile(", Count = ," + TapePress1.Count().ToString(), "c:/temp/TapePressureRaw.txt");
                        //Logger.WriteLogFile(", AVG   = ," + TapePress2.Average().ToString("F2"), "c:/temp/TapePressureRaw.txt");
                        return TapePress2.Average();
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in get tape pressure.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return 1.234;
                }

            }




            /// <summary>
            /// 
            /// </summary>
            /// <param name="FilamentMonitor"></param>
            public void SetFilamentMonitor(double FilamentMonitor)
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    FilamentMonitor1.Add(FilamentMonitor);
                }
                else
                {
                    FilamentMonitor2.Add(FilamentMonitor);
                }
            }
            public void ClrFilamentMonitor()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    FilamentMonitor1.Clear();
                }
                else
                {
                    FilamentMonitor2.Clear();
                }
            }

            public double GetFilamentMonitor()
            {
                int ldataSet = 0;
                try
                {
                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return FilamentMonitor1.Average();
                    }
                    else
                    {
                        return FilamentMonitor2.Average();
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in get filament monitor.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return 1.234;
                }

            }
            /// <summary>
            /// 
            /// </summary>
            /// <param name="RelativeHumidity"></param>
            public void SetRelativeHumidity(double RelativeHumidity)
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    RelativeHumidity1.Add(RelativeHumidity);
                }
                else
                {
                    RelativeHumidity2.Add(RelativeHumidity);
                }
            }
            public void ClrRelativeHumidity()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    RelativeHumidity1.Clear();
                }
                else
                {
                    RelativeHumidity2.Clear();
                }
            }

            public double GetRelativeHumidity()
            {
                int ldataSet = 0;
                try
                {
                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return RelativeHumidity1.Average();
                    }
                    else
                    {
                        return RelativeHumidity2.Average();
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in get relative humidity.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return 1.234;
                }

            }

            /// <summary>
            /// 
            /// </summary>
            /// <param name="SDDTemp"></param>
            public void SetSDDTemp(double SDDTemp)
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    SDDTemp1.Add(SDDTemp);
                }
                else
                {
                    SDDTemp2.Add(SDDTemp);
                }
            }
            public void ClrSDDTemp()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    SDDTemp1.Clear();
                }
                else
                {
                    SDDTemp2.Clear();
                }
            }

            public double GetSDDTemp()
            {
                int ldataSet = 0;
                try
                {

                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return SDDTemp1.Average();
                    }
                    else
                    {
                        return SDDTemp2.Average();
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in get SDD temp.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return 1.234;
                }

            }
            /// <summary>
            /// 
            /// </summary>
            /// <param name="DPPTemp"></param>
            public void SetDPPTemp(double DDPTemp)
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    DPPTemp1.Add(DDPTemp);
                }
                else
                {
                    DPPTemp2.Add(DDPTemp);
                }
            }
            public void ClrDPPTemp()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    DPPTemp1.Clear();
                }
                else
                {
                    DPPTemp2.Clear();
                }
            }

            public double GetDPPTemp()
            {
                int ldataSet = 0;
                try
                {
                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return DPPTemp1.Average();
                    }
                    else
                    {
                        return DPPTemp2.Average();
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in get DPP temp.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return 1.234;
                }

            }
            /// <summary>
            /// 
            /// </summary>
            /// <param name="Error"></param>
            public void SetError(string Error)
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    Error1.Add(Error);
                }
                else
                {
                    Error2.Add(Error);
                }
            }
            public void ClrError()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    Error1.Clear();
                }
                else
                {
                    Error2.Clear();
                }
            }

            public string GetError()
            {
                int ldataSet = 0;
                try
                {
                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return Error1.First();
                    }
                    else
                    {
                        return Error2.First();
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in get error during acquisition.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return "1.234";
                }
            }
            /// <summary>
            /// 
            /// </summary>
            /// <param name="Warning"></param>
            public void SetWarning(string Warning)
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    Warning1.Add(Warning);
                }
                else
                {
                    Warning2.Add(Warning);
                }
            }
            public void ClrWarning()
            {
                int dataSet = GetDataSet();
                if (dataSet == 1)
                {
                    Warning1.Clear();
                }
                else
                {
                    Warning2.Clear();
                }
            }

            //public void WriteAlarmToModbus(int code)
            //{
            //    ushort[] oneValue = new ushort[1] { (ushort)code };
            //    nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, oneValue, 800); // sends alarm

            //}

            public string GetWarning()
            {
                int ldataSet = 0;
                try
                {
                    ldataSet = GetDataSet();
                    if (ldataSet == 1)
                    {
                        return Warning1.First();
                    }
                    else
                    {
                        return Warning2.First();
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in get warning during acquisition.  DataSet = " + ldataSet.ToString() + " Ex= " + Ex.ToString());
                    return "1.234";
                }

            }



            // ************************************************************* //
            public bool Maximize()
            {

                //var ret21 = myacq_xrsfp.Connect_MCA;
                cMTFFPX myxrsfp = new cMTFFPX();  //create one at the beginning?
                                                  //bool ret20; //myxrsfp.SetupFPForm_Show;
                                                  //myxrsfp.SetupFPForm_Show = true;
                                                  //myxrsfp.ProcessingForm_Show = true;  //spectrum processing parameters
                myxrsfp.SpectraX_Show = true;  //spectrum processing parameters


                bool retval = myxrsfp.Show_Spectrum;

                //if (ret20 == true)
                return true;
                //else
                //    return FAIL;


            }

            public bool ShowLive()
            {
                //var ret21 = myacq_xrsfp.Connect_MCA;
                cMTFFPX myxrsfp = new cMTFFPX();  //create one at the beginning?
                                                  //bool ret20; //myxrsfp.SetupFPForm_Show;
                                                  //myxrsfp.SetupFPForm_Show = false;

                bool retb = myxrsfp.Show_Spectrum;



                //myxrsfp.Show_Spectrum = 1;

                //            var response = myxrsfp.Show_Spectrum;

                //spectrum processing parameters
                //if (ret20 == true)
                return retb;
                //else
                //    return FAIL;


            }



            public bool SetPresetMode()
            {
                cMTFFPX myxrsfp = new cMTFFPX();

                bool retb = myxrsfp.Send_Preset_Mode[2];

                return retb;


            }

            public bool SaveCESSpectrum()
            {

                //cMTFFPX myxrsfp = new cMTFFPX();


                //bool filesavesuccess = myxrsfp.Save_CES_Spectrum_File[tbSpectrumPathFilename.Text];
                return true;
            }

            public bool SpecturmDisplayON()
            {
                //var ret21 = myacq_xrsfp.Connect_MCA;
                cMTFFPX myxrsfp = new cMTFFPX();  //create one at the beginning?
                                                  //bool ret20; //myxrsfp.SetupFPForm_Show;
                                                  //myxrsfp.SetupFPForm_Show = false;

                //myxrsfp
                //if (ret20 == true)
                return true;
                //else
                //    return FAIL;


            }
            public bool Minimize()
            {

                //var ret21 = myacq_xrsfp.Connect_MCA;
                cMTFFPX myxrsfp = new cMTFFPX();  //create one at the beginning?
                                                  //bool ret20; //myxrsfp.SetupFPForm_Show;
                                                  //myxrsfp.SetupFPForm_Show = false;
                myxrsfp.SpectraX_Show = false;  //spectrum processing parameters
                                                //if (ret20 == true)
                return true;
                //else
                //    return FAIL;


            }

            public int SaveCESSpectrum(string path, string Filename, int EC)
            {
                try
                {


                    cMTFFPX myxrsfp = new cMTFFPX();  //create one at the beginning?
                    string fileToSave = path + "/" + Filename + "_EC_" + EC.ToString() + ".ces";

                    DateTime timeStamp;
                    timeStamp = DateTime.Now;
                    string dateTimeNow = timeStamp.ToString("MM_dd_yyyy_HH_mm_ss");

                    string destFileToSave = path + "/archive/" + Filename + "_EC_" + EC.ToString() + "_" + dateTimeNow + ".ces";

                    bool ret = myxrsfp.Save_CES_Spectrum_File[fileToSave];
                    if (ret == true)
                    {
                        Logger.WriteLogFile("save CES spectrum returned TRUE.");


                        //save a copy of the file in the archive directory.
                        try
                        {
                            System.IO.File.Copy(fileToSave, destFileToSave, true);


                        }
                        catch (Exception Ex)
                        {
                            Logger.WriteErrorFile("Error in copy ces spectrum file.  Ex = " + Ex.ToString());
                        }


                        return PASS;
                    }
                    else
                    {
                        Logger.WriteLogFile("Save CES spectrum returned FALSE.");

                        return FAIL;
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in save CES spectrum call:  Ex = " + Ex.ToString());
                    return FAIL;
                }
            }



            public int SaveCESSpectrumRaw(string path, string Filename, int EC)
            {
                try
                {
                    //this is a delay added to prevent saving spectra before cross is complete
                    Logger.WriteLogFile("Waiting 2 seconds before saving raw spectra.");
                    Thread.Sleep(2000);
                    Logger.WriteLogFile("Done waiting 2 seconds before saving raw spectra.");

                    cMTFFPX myxrsfp = new cMTFFPX();  //create one at the beginning?
                    string fileToSave = path + "/" + Filename + "_EC_" + EC.ToString() + ".ces";

                    DateTime timeStamp;
                    timeStamp = DateTime.Now;
                    string dateTimeNow = timeStamp.ToString("MM_dd_yyyy_HH_mm_ss");

                    string destFileToSave = path + "/archive/" + Filename + "_EC_" + EC.ToString() + "_" + dateTimeNow + ".ces";

                    bool ret = myxrsfp.Save_CES_Spectrum_File[fileToSave];
                    if (ret == true)
                    {
                        Logger.WriteLogFile("save RAW CES spectrum returned TRUE.");


                        //save a copy of the file in the archive directory.
                        try
                        {
                            System.IO.File.Copy(fileToSave, destFileToSave, true);


                        }
                        catch (Exception Ex)
                        {
                            Logger.WriteErrorFile("Error in copy ces RAW pectrum file: Ex = " + Ex.ToString());
                        }


                        return PASS;
                    }
                    else
                    {
                        Logger.WriteLogFile("Save CES RAW spectrum returned FALSE.");

                        return FAIL;
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in save CES spectrum call:  Ex = " + Ex.ToString());
                    return FAIL;
                }
            }



            public int SaveCESSpectrumFile(string pathFilename)
            {
                try
                {


                    cMTFFPX myxrsfp = new cMTFFPX();  //create one at the beginning?
                    string fileToSave = pathFilename;

                    //DateTime timeStamp;
                    //timeStamp = DateTime.Now;
                    //string dateTimeNow = timeStamp.ToString("MM_dd_yyyy_HH_mm_ss");

                    //string destFileToSave = path + "/archive/" + Filename + "_EC_" + EC.ToString() + "_" + dateTimeNow + ".ces";

                    bool ret = myxrsfp.Save_CES_Spectrum_File[fileToSave];
                    if (ret == true)
                    {


                        return PASS;
                    }
                    else
                    {
                        Logger.WriteErrorFile("Error Save CES spectrum returned FALSE.");

                        return FAIL;
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in save CES spectrum call: Ex = " + Ex.ToString());
                    return FAIL;
                }
            }






            public int LoadCESSpectrum(string path, string Filename, int EC)
            {
                try
                {



                    cMTFFPX myxrsfp = new cMTFFPX();  //create one at the beginning?
                    string fileToLoad = path + "/" + Filename + "_EC_" + EC.ToString() + ".ces";
                    bool ret = myxrsfp.Open_File[fileToLoad];
                    if (ret == true)
                    {
                        Logger.WriteLogFile("Load CES spectrum returned TRUE.");
                        return PASS;
                    }
                    else
                    {
                        Logger.WriteLogFile("Load CES spectrum returned FALSE.");

                        return FAIL;
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in Load CES spectrum call:  Ex = " + Ex.ToString());
                    Logger.WriteLogFile("Error in Load CES spectrum call:  Ex = " + Ex.ToString());
                    return FAIL;
                }
            }

            public int CheckDLR()
            {
                int returnVal = FAIL;

                try
                {

                    DateTime now = DateTime.Now;
                    DateTime dt = new DateTime(now.Year, now.Month, now.Day, now.Hour, now.Minute, now.Second);
                    IniFile.WriteValue("C:/XactControl/XRD.ini", "Tube", "LastRun", dt.ToString());


                    string lastRunValue = IniFile.ReadValue("C:/XactControl/XRD.ini", "Tube", "LastRun");
                    DateTime dtLRV = DateTime.Parse(lastRunValue);

                    TimeSpan span = now.Subtract(dtLRV);
                    double days = span.TotalDays;

                    if (days <= 21.0)
                    {
                        returnVal = PASS;
                    }
                    else
                    {
                        returnVal = FAIL;
                    }
                    return returnVal;
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in Date of Last Run.  Ex = " + Ex.ToString());
                    return returnVal;
                }


            }





            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            public int AdjustSpectrum()
            {
                try
                {

                    //var ret21 = myacq_xrsfp.Connect_MCA;
                    cMTFFPX myxrsfp = new cMTFFPX();  //create one at the beginning?
                    bool ret20 = myxrsfp.Adjust_Spectrum;
                    if (ret20 == true)
                    {
                        Logger.WriteLogFile("adjust spectrum returned TRUE.");
                        return PASS;
                    }
                    else
                    {
                        Logger.WriteLogFile("adjust spectrum returned FALSE.");

                        return FAIL;
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in adjust spectrum call: Ex = " + Ex.ToString());
                    Logger.WriteLogFile("Error in adjust spectrum call: Ex = " + Ex.ToString());

                    return FAIL;
                }
            }



            //public bool PerformManualEcal(Form1 f)
            //{

            //    cMTFFPX myxrsfp = new cMTFFPX();


            //    float FOffset = 0;
            //    float FOffsetBefore = 0;
            //    float FGain = 0;
            //    float FGainBefore = 0;
            //    float FfMnFWHM = 0;
            //    float FintegralLow = 0;
            //    float FintegralHigh = 0;



            //    var r3 = myxrsfp.Get_Calibrate_Spectrum_Results[ref FOffsetBefore, ref FGainBefore, ref FfMnFWHM, ref FintegralLow, ref FintegralHigh];
            //    Logger.WriteLogFile("c:/temp/ManualEcal.txt", "Calibrate_Spectrum_Results (before) return = " + r3.ToString());
            //    Logger.WriteLogFile("c:/temp/ManualEcal.txt", "Gain (before) = " + FGainBefore.ToString() + " Offset (before) = " + FOffsetBefore.ToString());



            //    bool result = myxrsfp.Calibrate_Spectrum;
            //    Thread.Sleep(2000);  //appears to be necessary

            //    Logger.WriteLogFile("c:/temp/ManualEcal.txt", "Calibrate_Spectrum return = " + result.ToString());


            //    var r4 = myxrsfp.Get_Calibrate_Spectrum_Results[ref FOffset, ref FGain, ref FfMnFWHM, ref FintegralLow, ref FintegralHigh];
            //    Logger.WriteLogFile("c:/temp/ManualEcal.txt", "Calibrate_Spectrum_Results return = " + r4.ToString());
            //    Logger.WriteLogFile("c:/temp/ManualEcal.txt", "Gain (after) = " + FGain.ToString() + " Offset (after) = " + FOffset.ToString());




            //    myxrsfp.Set_Gain = FGain;
            //    myxrsfp.Set_Offset = FOffset;



            //    //IniFile.WriteValue("C:/CrossRoads Scientific/XRS-FP/xrs-fp.ini", "Calibration", "Spectrum_Gain", FGain.ToString());
            //    IniFile.WriteValue("C:/CrossRoads Scientific/XRS-FP/xrs-fp.ini", "Calibration", "SpectrumGain", FGain.ToString());
            //    IniFile.WriteValue("C:/CrossRoads Scientific/XRS-FP/xrs-fp.ini", "Calibration", "SpectrumOffset", FOffset.ToString());

            //    Logger.WriteLogFile(   "Ecal Gain = " + FGain.ToString());
            //    Logger.WriteLogFile(   "Ecal Offset = " + FOffset.ToString());


            //    //               "Verify Ecal",
            //    //               MessageBoxButtons.OK);
            //    f.UpdateMaintCheckMessage("Gain=" + FGain.ToString("F3") + " Offset=" + FOffset.ToString("F3"));


            //    //Logger.WriteLogFile(   "Performing spectrum adjust." + FOffset.ToString());

            //    //bool result2 = myxrsfp.Adjust_Spectrum;

            //    //r3 = myxrsfp.Get_Calibrate_Spectrum_Results[ref FOffset, ref FGain, ref FfMnFWHM, ref FintegralLow, ref FintegralHigh];
            //    //write to the xrsfp ini file here

            //    return result;
            //}



            public bool PerformEcal(out float FGainReturn, out float FOffsetReturn, string logFile)
            {

                cMTFFPX myxrsfp = new cMTFFPX();

                FGainReturn = 0f;
                FOffsetReturn = 0f;
                float FOffset = 0f;
                float FGain = 0f;
                float FfMnFWHM = 0;
                float FintegralLow = 0;
                float FintegralHigh = 0;





                bool result = myxrsfp.Calibrate_Spectrum;
                Thread.Sleep(2000);  //appears to be necessary

                Logger.WriteLogFile("Calibrate_Spectrum return = " + result.ToString(), logFile);


                var r3 = myxrsfp.Get_Calibrate_Spectrum_Results[ref FOffset, ref FGain, ref FfMnFWHM, ref FintegralLow, ref FintegralHigh];
                Logger.WriteLogFile("Calibrate_Spectrum_Results return = " + r3.ToString(), logFile);


                //DialogResult result1 = MessageBox.Show("Do you wish to use the new Gain values",
                //               "Verify Ecal",
                //               MessageBoxButtons.YesNo);


                Logger.WriteLogFile("Found Ecal Gain = " + FGain.ToString(), logFile);
                Logger.WriteLogFile("Found Ecal Offset = " + FOffset.ToString(), logFile);

                //check the gains to limits is done on function return




                myxrsfp.Set_Gain = FGain;
                myxrsfp.Set_Offset = FOffset;





                //IniFile.WriteValue("C:/CrossRoads Scientific/XRS-FP/xrs-fp.ini", "Calibration", "Spectrum_Gain", FGain.ToString());
                IniFile.WriteValue("C:/CrossRoads Scientific/XRS-FP/xrs-fp.ini", "Calibration", "SpectrumGain", FGain.ToString());
                IniFile.WriteValue("C:/CrossRoads Scientific/XRS-FP/xrs-fp.ini", "Calibration", "SpectrumOffset", FOffset.ToString());

                Logger.WriteLogFile("Ecal Gain = " + FGain.ToString(), logFile);
                Logger.WriteLogFile("Ecal Offset = " + FOffset.ToString(), logFile);
                //Logger.WriteLogFile(   "Performing spectrum adjust." + FOffset.ToString());

                //bool result2 = myxrsfp.Adjust_Spectrum;

                //r3 = myxrsfp.Get_Calibrate_Spectrum_Results[ref FOffset, ref FGain, ref FfMnFWHM, ref FintegralLow, ref FintegralHigh];
                //write to the xrsfp ini file here

                FGainReturn = FGain;
                FOffsetReturn = FOffset;


                return result;
            }

            /// <summary>
            /// A function to all Cross Get_FWHM for Mn
            /// A future version may be able to return FWHM for Nb and Cr
            /// tested 1.0.0.51
            /// </summary>
            /// <param name="Fcr"></param>
            /// <param name="Fnb"></param>
            /// <returns></returns>
            //public float ReadFWHM(out float Fcr, out float Fnb)
            //{
            //    float returnVal = 0.0f;
            //    Fcr = 0.0f;
            //    Fnb = 0.0f;
            //    cMTFFPX myxrsfp = new cMTFFPX();
            //    returnVal = myxrsfp.Get_FWHM;
            //    return returnVal;

            //}

            public void DefaultGainAndOffset()
            {
                cMTFFPX myxrsfp = new cMTFFPX();

                float fGain = 20.0f;
                float fOffset = -23.0f;

                myxrsfp.Set_Gain = fGain;
                myxrsfp.Set_Offset = fOffset;

                IniFile.WriteValue("C:/CrossRoads Scientific/XRS-FP/xrs-fp.ini", "Calibration", "SpectrumGain", fGain.ToString());
                IniFile.WriteValue("C:/CrossRoads Scientific/XRS-FP/xrs-fp.ini", "Calibration", "SpectrumOffset", fOffset.ToString());

                Logger.WriteLogFile("Default Ecal Gain = " + fGain.ToString());
                Logger.WriteLogFile("Default Ecal Offset = " + fOffset.ToString());

            }




            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            public int GetECAL()
            {
                return ECALProcess;

            }
            public void SetECAL(int value)
            {
                ECALProcess = value;
            }

            public int GetUpscale()
            {
                return UpscaleProcess;

            }
            public void SetUpscale(int value)
            {
                UpscaleProcess = value;
            }

            public int AutoAnalyze()
            {
                try
                {

                    //var ret21 = myacq_xrsfp.Connect_MCA;
                    cMTFFPX myxrsfp = new cMTFFPX();  //create one at the beginning?
                    bool ret20 = myxrsfp.AutoAnalyze;
                    if (ret20 == true)
                    {
                        Logger.WriteLogFile("auto analyze returned TRUE.");
                        return PASS;
                    }
                    else
                    {
                        Logger.WriteLogFile("auto analyze returned FALSE.");

                        return FAIL;
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in autoanalyze call: Ex = " + Ex.ToString());
                    return FAIL;
                }
            }

            public List<double> GetRampCurrentValues()
            {
                return RampCurrentValues;
            }
            public List<double> GetRampVoltageValues()
            {
                return RampVoltageValues;
            }



            /// <summary>
            /// 
            /// </summary>
            /// <param name="targetVoltage"></param>
            /// <param name="targetCurrent"></param>
            /// <returns></returns>
            public int RampXrays(double presentV, double presentI, double targetVoltage, double targetCurrent, BackgroundWorker m_oWorkerRamp, List<double> VoltageValues, List<double> CurrentValues, Form1 f)
            {
                /*
                try
                {
                    xrayOnCommandCounter = 0;
                    xrayRampCommandActive = 1;


                    //presentV, presentI, destinationV, destinationI, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent
                    if (targetVoltage > 50.0)
                    {
                        targetVoltage = 25.0;
                    }
                    if (targetCurrent > 2000.0)
                    {
                        targetCurrent = 1000.0;
                    }


                    if (presentV < 0)
                        presentV = 0.0;
                    if (presentI < 0)
                        presentI = 0.0;


                    int time;

                    if (targetVoltage < (presentV * 1.03) && targetVoltage > (presentV * .97))
                    {
                        xrayOnCommand = 1;
                        time = 1;
                    }

                    else if (targetVoltage == 0 && targetCurrent == 0)
                    {
                        xrayOnCommand = 0;
                        //
                        //if (presentI > 1200)
                        //{
                        //    time = 12;
                        //}
                        //else
                        //{
                        //    time = 8;
                        //}
                        //
                        time = 5;
                    }
                    else if (presentV > 24.0 && targetVoltage > 24.0)
                    {
                        xrayOnCommand = 1;
                        time = 5;
                    }
                    else
                    {
                        xrayOnCommand = 1;
                        time = 15;
                    }



                    int powerCheck = 1;
                    int powerCount = 0;
                    do
                    {

                        calcLinearRampVoltage(presentV, targetVoltage, time, 1.0, VoltageValues);   //present v, target v, time to transition, output rate per second
                        calcLinearRampCurrent(presentI, targetCurrent, time, 1.0, CurrentValues);   //present i, target i, time to transition, output rate per second

                        powerCheck = CheckTubeOutPower(VoltageValues, CurrentValues);
                        powerCount++;

                    } while (powerCheck == 1 && powerCount < 1);




                    if (powerCheck == 0)
                    {

                        Thread.Sleep(1100);  //wait for the toggle timer to shut off

                        InterlockClose(f);


                        //if (mtbInterLockStatus.InvokeRequired)
                        //{
                        //    mtbInterlockStatus (new MethodInvoker(delegate { mtbInterlockStatus.Text = "CLOSED"; }));

                        //}
                        //else
                        //{
                        //    mtbInterlockStatus.Text="CLOSED";

                        //}

                        Thread.Sleep(100); //allow the interlock relay time to close and the HVPS electronics time to ready itself for input voltages 

                        //perform ramps on bgw thread
                        RampVoltageValues = VoltageValues;
                        RampCurrentValues = CurrentValues;


                        if (f.mtbStatusXrayStatus.InvokeRequired)
                        {
                            if (targetVoltage > 0 || targetCurrent > 0)
                            {
                                xrayOnCommand = 1;
                                f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Text = "ON"; }));
                                f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Refresh(); }));
                            }
                            else
                            {
                                if (targetVoltage == 0 && targetCurrent == 0)
                                {
                                    xrayOnCommand = 0;
                                    f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Text = "RAMP DOWN"; }));
                                    f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Refresh(); }));
                                }
                            }

                        }
                        else
                        {
                            if (targetVoltage > 0 || targetCurrent > 0)
                            {
                                xrayOnCommand = 1;
                                f.mtbStatusXrayStatus.Text = "ON";
                                f.mtbStatusXrayStatus.Refresh();
                            }
                            else
                            {
                                if (targetVoltage == 0 && targetCurrent == 0)
                                {
                                    xrayOnCommand = 0;
                                    f.mtbStatusXrayStatus.Text = "RAMP DOWN";
                                    f.mtbStatusXrayStatus.Refresh();
                                }

                            }

                        }


                        m_oWorkerRamp.RunWorkerAsync();

                        return PASS;

                    }

                    else
                    {

                        if (f.mtbStatusXrayStatus.InvokeRequired)
                        {
                            f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Text = "Error:  target/ramp over 50W"; }));
                            f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Refresh(); }));
                        }
                        else
                        {
                            f.mtbStatusXrayStatus.Text = "Error:  target/ramp over 50W";
                            f.mtbStatusXrayStatus.Refresh();
                        }



                        Logger.WriteErrorFile("Error: target/ramp--over 50W");
                        return FAIL;
                    }
                }
                catch (Exception Ex)
                {

                    if (f.mtbStatusXrayStatus.InvokeRequired)
                    {
                        f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Text = "Error:  Ramp X-rays"; }));
                        f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Refresh(); }));
                    }
                    else
                    {
                        f.mtbStatusXrayStatus.Text = "Error:  Ramp X-rays";
                        f.mtbStatusXrayStatus.Refresh();
                    }


                    Logger.WriteErrorFile("Error in X-ray ramp function.  Ex = " + Ex.ToString());
                    Logger.WriteInternalLogFile("Exception in X-ray ramp function.  Ex = " + Ex.ToString());
                    return FAIL;

                }
                */

                try
                {
                    xrayOnCommandCounter = 0;
                    xrayRampCommandActive = 1;


                    //presentV, presentI, destinationV, destinationI, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent
                    if (targetVoltage > 50.0)
                    {
                        targetVoltage = 25.0;
                    }
                    if (targetCurrent > 2000.0)
                    {
                        targetCurrent = 1000.0;
                    }


                    if (presentV < 0)
                        presentV = 0.0;
                    if (presentI < 0)
                        presentI = 0.0;


                    int time;


                    if (targetVoltage == 0 && targetCurrent == 0)
                    {
                        xrayOnCommand = 0;
                        /*
                        if (presentI > 1200)
                        {
                            time = 12;
                        }
                        else
                        {
                            time = 8;
                        }
                        */
                        time = 4;
                    }
                    else if  ((targetVoltage < (presentV * 1.05) ) && (presentV>0.5) && (targetVoltage > (presentV * .95)))
                    {
                        xrayOnCommand = 1;
                        time = 1;
                    }
                    else if (presentV > 24.0 && targetVoltage > 24.0)
                    {
                        xrayOnCommand = 1;
                        time = 5;
                    }
                    else
                    {
                        xrayOnCommand = 1;
                        time = 15;
                    }



                    int powerCheck = 1;
                    int powerCount = 0;
                    do
                    {

                        calcLinearRampVoltage(presentV, targetVoltage, time, 1.0, VoltageValues);   //present v, target v, time to transition, output rate per second
                        calcLinearRampCurrent(presentI, targetCurrent, time, 1.0, CurrentValues);   //present i, target i, time to transition, output rate per second

                        powerCheck = CheckTubeOutPower(VoltageValues, CurrentValues);
                        powerCount++;

                    } while (powerCheck == 1 && powerCount < 1);




                    if (powerCheck == 0)
                    {

                        Thread.Sleep(1100);  //wait for the toggle timer to shut off

                        InterlockClose(f);


                        //if (mtbInterLockStatus.InvokeRequired)
                        //{
                        //    mtbInterlockStatus (new MethodInvoker(delegate { mtbInterlockStatus.Text = "CLOSED"; }));

                        //}
                        //else
                        //{
                        //    mtbInterlockStatus.Text="CLOSED";

                        //}

                        Thread.Sleep(100); //allow the interlock relay time to close and the HVPS electronics time to ready itself for input voltages 

                        //perform ramps on bgw thread
                        RampVoltageValues = VoltageValues;
                        RampCurrentValues = CurrentValues;


                        if (f.mtbStatusXrayStatus.InvokeRequired)
                        {
                            if (targetVoltage > 0 || targetCurrent > 0)
                            {
                                xrayOnCommand = 1;
                                f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Text = "ON"; }));
                                f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Refresh(); }));
                            }
                            else
                            {
                                if (targetVoltage == 0 && targetCurrent == 0)
                                {
                                    xrayOnCommand = 0;
                                    f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Text = "RAMP DOWN"; }));
                                    f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Refresh(); }));
                                }
                            }

                        }
                        else
                        {
                            if (targetVoltage > 0 || targetCurrent > 0)
                            {
                                xrayOnCommand = 1;
                                f.mtbStatusXrayStatus.Text = "ON";
                                f.mtbStatusXrayStatus.Refresh();
                            }
                            else
                            {
                                if (targetVoltage == 0 && targetCurrent == 0)
                                {
                                    xrayOnCommand = 0;
                                    f.mtbStatusXrayStatus.Text = "RAMP DOWN";
                                    f.mtbStatusXrayStatus.Refresh();
                                }

                            }

                        }

                        try
                        {
                            m_oWorkerRamp.RunWorkerAsync();
                        }
                        catch(Exception Ex)
                        {
                            Logger.WriteInternalLogFile("Error: in Ramp Xrays while calling Run ramp worker. Ex = " + Ex.ToString());
                            return FAIL;
                        }

                        return PASS;

                    }

                    else
                    {

                        if (f.mtbStatusXrayStatus.InvokeRequired)
                        {
                            f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Text = "Error:  target/ramp over 50W"; }));
                            f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Refresh(); }));
                        }
                        else
                        {
                            f.mtbStatusXrayStatus.Text = "Error:  target/ramp over 50W";
                            f.mtbStatusXrayStatus.Refresh();
                        }



                        Logger.WriteErrorFile("Error: target/ramp--over 50W");
                        return FAIL;
                    }
                }
                catch (Exception Ex)
                {

                    if (f.mtbStatusXrayStatus.InvokeRequired)
                    {
                        //f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Text = "Error:  Ramp X-rays"; }));
                        f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Refresh(); }));
                    }
                    else
                    {
                        //f.mtbStatusXrayStatus.Text = "Error:  Ramp X-rays";
                        f.mtbStatusXrayStatus.Refresh();
                    }


                    Logger.WriteErrorFile("Error in X-ray ramp function.  Ex = " + Ex.ToString());
                    Logger.WriteInternalLogFile("Exception in X-ray ramp function.  Ex = " + Ex.ToString());
                    return FAIL;

                }


            }
            //


            private int CheckTubeOutPower(List<double> LinearRampValuesVoltage, List<double> LinearRampValuesCurrent)
            {
                int returnValue = 0;
                double Volts;
                double Amps;
                double Watts;

                int retries = 0;
                int retryOld = 0;
                //int retryNew=0;

                do
                {
                    retryOld = retries;
                    returnValue = 0;
                    for (int index = 0; index < LinearRampValuesVoltage.Count; index++)
                    {
                        // need to properly scale this:
                        Volts = LinearRampValuesVoltage[index] * (50.0 / 10.0);
                        Amps = LinearRampValuesCurrent[index] * (2000 / 10.0) / 1000;

                        Watts = Volts * Amps;
                        /*
                        if (Watts > 50.0)
                        {
                            returnValue = 1;
                            string msg = "invalid wattage " + Watts.ToString() + " at index " + index.ToString();
                            Logger.WriteErrorFile(msg);

                            break;
                        }
                        */
                        if (Watts > 50.0)
                        {
                            returnValue = 1;
                            retries += 1;
                            //attempt to reduce wattage
                            //by reducing the current at each step if over 50W
                            LinearRampValuesCurrent[index] = (49.99 / (LinearRampValuesVoltage[index]));

                            break; //for

                        }

                        /*



                        if (LinearRampValuesCurrent[index + 1] < LinearRampValuesCurrent[index])
                        {
                            if ((index + 1) <= LinearRampValuesCurrent.Count)
                            {
                                LinearRampValuesCurrent[index] = LinearRampValuesCurrent[index + 1];

                            }
                            //index = 0;
                            break; //for
                        }
                        else if (LinearRampValuesCurrent[index]<LinearRampValuesCurrent[index +1])
                        {
                            if ((index) <= LinearRampValuesCurrent.Count)
                            {
                                LinearRampValuesCurrent[index + 1] = LinearRampValuesCurrent[index];
                                if (LinearRampValuesVoltage[index] * LinearRampValuesCurrent[index] <50.0;
                                    LinearRampValuesCurrent[index]
                                //index = 0;
                            }
                            break; //for
                        }
                        */

                        //}

                        //dataFile4.WriteLine("Outuput {0:F04}, Error P {1:F04}", OutputVoltage, Error * Kp);
                        //dataFile4.WriteLine("v out= ,{0:F04}, {1:F04}", rawUPvOut_EC1[index], rawUPaOut_EC1[index]);

                        //dataFile5.WriteLine(stringValue);   //this does a file write 
                    }

                } while (retries != retryOld && retries < 100);

                if (retries <= 100 && returnValue == 0)
                    return 0; //pass
                else
                    return 1;  //this should halt


            }
            /*
            private double ReadInputCurrent()
            {
                double avgCurrent = 0.0;
                int readOk = 0;
                int counter = 0;

                do
                {

                    try
                    {
#if TURNON_NIHARDWARE
                        reader = new AnalogMultiChannelReader(InputCurrent.Stream);
                        InputCurrentData = reader.ReadWaveform(10);

                        readOk = 1;
                        double sum = 0.0;
                        string stringValue;


                        // Iterate over channels
                        int NumberOfReads = 0;
                        foreach (AnalogWaveform<double> waveform in InputCurrentData)
                        {
                            for (int sample = 0; sample < waveform.Samples.Count; ++sample)
                            {
                                sum = sum + waveform.Samples[sample].Value;
                                NumberOfReads++;
                                stringValue = waveform.Samples[sample].Value.ToString();

                                //dataFile2.WriteLine(stringValue);   //this does a file write (many be a real time restriction here!)
                            }
                        }
                        avgCurrent = sum / NumberOfReads;
                        //dataFile2.WriteLine(" *** AVG=, {0}", avg);

#else
                        avgCurrent = 4.567;
                        readOk = 1;
#endif


                    }
                    catch (Exception e)
                    {
                        string msg;

                        msg = "AL hvps CURRENT input read ex= " + e.ToString();
                        Logger.WriteErrorFile(msg);
                        msg = "AL hvps read error counter = " + counter.ToString();
                        Logger.WriteErrorFile(msg);
                        counter += 1;

                    }
                } while (readOk == 0 && counter < 10);

                return avgCurrent;
            }
            */

            //            throw new NotImplementedException();
            //       }

            public int CheckUpscale(string Element, string Value, Form1 f)
            {
                double measuredValue = 0.0;

                try
                {
                    try
                    {
                        Double.TryParse(Value, out measuredValue);
                    }
                    catch
                    {
                        Logger.WriteLogFile("could not parse: " + Value.ToString());
                        measuredValue = 0;
                    }


                    if (Element.Contains("Cr"))
                    {
                        //check the measured value against settings value for Cr
                        if (measuredValue > (Properties.Settings.Default.UpscaleCr * (1.0 + (Properties.Settings.Default.UpscaleAlarmPercent / 100.0))))
                        {
                            f.Warning("Cr upscale value hi.  Cr = " + measuredValue.ToString("F2"));
                            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                            AcquisitionControl.SetAlarmValue(200);
                            f.WriteAlarmToModbus(200);

                        }
                        else if (measuredValue < (Properties.Settings.Default.UpscaleCr * (1.0 - (Properties.Settings.Default.UpscaleAlarmPercent / 100.0))))
                        {
                            f.Warning("Cr upscale value low.  Cr = " + measuredValue.ToString("F2"));
                            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                            AcquisitionControl.SetAlarmValue(200);
                            f.WriteAlarmToModbus(200);

                        }

                        //if fails call warning
                    }
                    else if (Element.Contains("Cd"))
                    {
                        if (measuredValue > (Properties.Settings.Default.UpscaleCd * (1.0 + (Properties.Settings.Default.UpscaleAlarmPercent / 100.0))))
                        {
                            f.Warning("Cd upscale value hi.  Cd = " + measuredValue.ToString("F2"));
                            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                            AcquisitionControl.SetAlarmValue(202);
                            f.WriteAlarmToModbus(202);
                        }
                        else if (measuredValue < (Properties.Settings.Default.UpscaleCd * (1.0 - (Properties.Settings.Default.UpscaleAlarmPercent / 100.0))))
                        {
                            f.Warning("Cd upscale value low.  Cd = " + measuredValue.ToString("F2"));
                            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                            AcquisitionControl.SetAlarmValue(202);
                            f.WriteAlarmToModbus(202);
                        }



                    }
                    else if (Element.Contains("Pb"))
                    {
                        if (measuredValue > (Properties.Settings.Default.UpscalePb * (1.0 + (Properties.Settings.Default.UpscaleAlarmPercent / 100.0))))
                        {
                            f.Warning("Pb upscale value hi.  Pb = " + measuredValue.ToString("F2"));
                            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                            AcquisitionControl.SetAlarmValue(201);
                            f.WriteAlarmToModbus(201);
                        }
                        else if (measuredValue < (Properties.Settings.Default.UpscalePb * (1.0 - (Properties.Settings.Default.UpscaleAlarmPercent / 100.0))))
                        {
                            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                            f.Warning("Pb upscale value low.  Pb = " + measuredValue.ToString("F2"));
                            AcquisitionControl.SetAlarmValue(201);
                            f.WriteAlarmToModbus(201);
                        }


                    }

                    //EC4 needs to be changed to a proper element
                    else if (Element.Contains("EC4"))
                    {
                        if (measuredValue > (Properties.Settings.Default.UpscaleEC4 * (1.0 + (Properties.Settings.Default.UpscaleAlarmPercent / 100.0))))
                        {
                            f.Warning("EC4 upscale value hi.  EC4 = " + measuredValue.ToString("F2"));
                            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                            AcquisitionControl.SetAlarmValue(204);
                            f.WriteAlarmToModbus(204);
                        }
                        else if (measuredValue < (Properties.Settings.Default.UpscaleEC4 * (1.0 - (Properties.Settings.Default.UpscaleAlarmPercent / 100.0))))
                        {
                            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                            f.Warning("EC4 upscale value low.  EC4 = " + measuredValue.ToString("F2"));
                            AcquisitionControl.SetAlarmValue(204);
                            f.WriteAlarmToModbus(204);
                        }


                    }




                    /*
                     *  this needs to be changed to check each Nb occurance in case 31 to the set value
                    else if (Element.Contains("Nb"))
                    {
                        if (measuredValue >= (Properties.Settings.Default.Nb * (1.0 + (Properties.Settings.Default.UpscaleAlarmPercent / 100.0))))
                        {
                            f.Warning("Nb upscale value high.  Nb = " + measuredValue.ToString("F2"));
                            f.SetAlarmValue(203);
                            f.WriteAlarmToModbus(203);
                        }
                        else if (measuredValue <= (Properties.Settings.Default.Nb * (1.0 - (Properties.Settings.Default.UpscaleAlarmPercent / 100.0))))
                        {
                            f.Warning("Nb upscale value low.  Nb = " + measuredValue.ToString("F2"));
                            f.SetAlarmValue(203);
                            f.WriteAlarmToModbus(203);
                        }


                    }
                    */

                    return PASS;
                }

                catch
                {
                    return FAIL;
                }
            }





            public void InterlockClose(Form1 f)
            {

                try
                {
                    DigitalSingleChannelWriter Port00writer = new DigitalSingleChannelWriter(InterlockOutput.Stream);
#if TURNON_NIHARDWARE
                    Port00writer.WriteSingleSampleSingleLine(true, true);
#endif
                    if (f.mtbInterlockStatus.InvokeRequired)
                    {
                        f.mtbInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbInterlockStatus.Text = "Closed"; }));
                        f.mtbInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbInterlockStatus.Refresh(); }));
                    }
                    else
                    {
                        f.mtbInterlockStatus.Text = "Closed";
                        f.mtbInterlockStatus.Refresh();
                    }
                    if (f.mtbMaintInterlockStatus.InvokeRequired)
                    {
                        f.mtbMaintInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbMaintInterlockStatus.Text = "Closed"; }));
                        f.mtbMaintInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbMaintInterlockStatus.Refresh(); }));
                    }
                    else
                    {
                        f.mtbMaintInterlockStatus.Text = "Closed";
                        f.mtbMaintInterlockStatus.Refresh();
                    }



                }
                catch (Exception Ex)
                {
                    if (f.mtbInterlockStatus.InvokeRequired)
                    {
                        f.mtbInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbInterlockStatus.Text = "Error: Closing Interlock"; }));
                        f.mtbInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbInterlockStatus.Refresh(); }));
                    }
                    else
                    {
                        f.mtbInterlockStatus.Text = "Error: Closing Interlock";
                        f.mtbInterlockStatus.Refresh();
                    }

                    if (f.mtbMaintInterlockStatus.InvokeRequired)
                    {
                        f.mtbMaintInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbMaintInterlockStatus.Text = "Error: Closing Interlock"; }));
                        f.mtbMaintInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbMaintInterlockStatus.Refresh(); }));
                    }
                    else
                    {
                        f.mtbMaintInterlockStatus.Text = "Error: Closing Interlock";
                        f.mtbMaintInterlockStatus.Refresh();
                    }

                    Logger.WriteErrorFile("Error: Interlock Close = Ex = " + Ex.ToString());
                    Logger.WriteInternalLogFile("Error: Interlock Close.  Ex = " + Ex.ToString());
                }
            }

            public void InterlockOpen(Form1 f)
            {

                try
                {
                    DigitalSingleChannelWriter Port00writer = new DigitalSingleChannelWriter(InterlockOutput.Stream);
#if TURNON_NIHARDWARE
                    Port00writer.WriteSingleSampleSingleLine(true, false);
#endif

                    if (f.mtbInterlockStatus.InvokeRequired)
                    {
                        f.mtbInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbInterlockStatus.Text = "Open"; }));
                        f.mtbInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbInterlockStatus.Refresh(); }));

                        f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Text = "OFF"; }));
                        f.mtbStatusXrayStatus.Invoke(new MethodInvoker(delegate { f.mtbStatusXrayStatus.Refresh(); }));
                    }
                    else
                    {
                        f.mtbInterlockStatus.Text = "Open";
                        f.mtbInterlockStatus.Refresh();
                        f.mtbStatusXrayStatus.Text = "OFF";
                        f.mtbStatusXrayStatus.Refresh();
                    }

                    if (f.mtbMaintInterlockStatus.InvokeRequired)
                    {
                        f.mtbMaintInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbMaintInterlockStatus.Text = "Open"; }));
                        f.mtbMaintInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbMaintInterlockStatus.Refresh(); }));
                    }
                    else
                    {
                        f.mtbMaintInterlockStatus.Text = "Open";
                        f.mtbMaintInterlockStatus.Refresh();
                    }





                }
                catch (Exception Ex)
                {

                    if (f.mtbInterlockStatus.InvokeRequired)
                    {
                        f.mtbInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbInterlockStatus.Text = "Error:  Open Interlock"; }));
                        f.mtbInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbInterlockStatus.Refresh(); }));
                    }
                    else
                    {
                        f.mtbInterlockStatus.Text = "Error:  Open Interlock";
                        f.mtbInterlockStatus.Refresh();
                    }
                    if (f.mtbMaintInterlockStatus.InvokeRequired)
                    {
                        f.mtbMaintInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbMaintInterlockStatus.Text = "Error:  Open Interlock"; }));
                        f.mtbMaintInterlockStatus.Invoke(new MethodInvoker(delegate { f.mtbMaintInterlockStatus.Refresh(); }));
                    }
                    else
                    {
                        f.mtbMaintInterlockStatus.Text = "Error:  Open Interlock";
                        f.mtbMaintInterlockStatus.Refresh();
                    }


                    Logger.WriteErrorFile("Error:  Interlock Open. Ex = " + Ex.ToString());
                    Logger.WriteLogFile("Error:  Interlock Open. Ex = " + Ex.ToString());
                    Logger.WriteInternalLogFile("Error:  Interlock Open. Ex = " + Ex.ToString());
                    

                }
            }
            //}
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>

            ////static public req
            //static public List<double> LinearRampValuesVoltage = new List<double>();
            //static public List<double> LinearRampValuesCurrent = new List<double>();
            //static public int rampIndex = 0;

            private int CheckPower(List<double> LinearRampValuesVoltage, List<double> LinearRampValuesCurrent)
            {
                int returnValue = 0;
                double Volts;
                double Amps;
                double Watts;

                for (int index = 0; index < LinearRampValuesVoltage.Count; index++)
                {
                    // need to properly scale this:
                    Volts = LinearRampValuesVoltage[index] * (50.0 / 10.0);
                    Amps = LinearRampValuesCurrent[index] * (2000 / 10.0) / 1000;

                    Watts = Volts * Amps;
                    if (Watts > 50.0)
                    {
                        returnValue = 1;
                        string msg = "Error:  invalid wattage " + Watts.ToString() + " at index " + index.ToString();
                        Logger.WriteErrorFile(msg);
                        Logger.WriteInternalLogFile(msg);

                        break;
                    }
                    //dataFile4.WriteLine("Outuput {0:F04}, Error P {1:F04}", OutputVoltage, Error * Kp);
                    //dataFile4.WriteLine("v out= ,{0:F04}, {1:F04}", rawUPvOut_EC1[index], rawUPaOut_EC1[index]);

                    //dataFile5.WriteLine(stringValue);   //this does a file write 
                }

                return returnValue;

            }

            private void calcLinearRampCurrent(double presentI, double targetCurrent, int time, double rate, List<double> LinearRampValuesCurrent)
            {
                LinearRampValuesCurrent.Clear();
                double delta = 0.0;
                double numberOfSteps;

                double scaleI1 = (presentI / 2000) * 9.99;
                double scaleI2 = (targetCurrent / 2000) * 9.99;



                delta = scaleI2 - scaleI1;
                numberOfSteps = (time / rate);
                double stepValue = 0.0;
                stepValue = delta / numberOfSteps;
                double tempValue = 0;

                for (int i = 1; i <= (int)numberOfSteps; i++)
                {
                    tempValue = scaleI1 + (stepValue * i);
                    if (delta > 0.0 && tempValue < 0.36)
                        tempValue = 0.36;
                    LinearRampValuesCurrent.Add(scaleI1 + (stepValue * i));
                }


                string stringValue;
                //dataFile6.WriteLine("START current output data array............................");
                for (int index = 0; index < LinearRampValuesCurrent.Count; index++)
                {

                    stringValue = LinearRampValuesCurrent[index].ToString();

                    //dataFile4.WriteLine("Outuput {0:F04}, Error P {1:F04}", OutputVoltage, Error * Kp);
                    //dataFile4.WriteLine("v out= ,{0:F04}, {1:F04}", rawUPvOut_EC1[index], rawUPaOut_EC1[index]);

                    //dataFile6.WriteLine(stringValue);   //this does a file write 
                    //Logger.WriteLogFile("c:\\temp\\ramp.txt", "linear ramp current = " + stringValue);


                }
                //dataFile6.Close();




            }

            static void calcLinearRampVoltage(double V1, double V2, double timeInSeconds, double rate, List<double> LinearRampValuesVoltage)
            {

                LinearRampValuesVoltage.Clear();
                double delta = 0.0;
                double dnumberOfSteps;
                int numberOfSteps;

                double scaleV1 = (V1 / 50.0) * 9.99;  //NI board can not output 10.0
                double scaleV2 = (V2 / 50.0) * 9.99;  //NI board can not output 10.0

                //break down the load of the list of values in rate second increments

                //0  2000
                //2000 0
                delta = scaleV2 - scaleV1;
                dnumberOfSteps = timeInSeconds / rate;
                numberOfSteps = (int)dnumberOfSteps;

                double stepValue = 0.0;

                stepValue = delta / numberOfSteps;

                // note number of steps may need to be rounded 
                for (int i = 1; i <= numberOfSteps; i++)
                {
                    LinearRampValuesVoltage.Add(scaleV1 + (stepValue * i));
                }

                string stringValue;


                for (int index = 0; index < LinearRampValuesVoltage.Count; index++)
                {
                    stringValue = LinearRampValuesVoltage[index].ToString();
                    //Logger.WriteLogFile("c:\\temp\\ramp.txt", "linear ramp voltage = " + stringValue);

                }

            }



            /// <summary>
            /// 
            /// </summary>
            /// <param name="fwPosValue"></param>
            public void SetFilterWheelPosition(int fwPosValue)
            {
                filterWheelCurrentPosition = fwPosValue;
            }

            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            public int GetFilterWheelPosition()
            {
                return filterWheelCurrentPosition;
            }

            /// <summary>
            /// 
            /// </summary>
            /// <param name="EnergyConditionValue"></param>
            public void SetEnergyCondition(int EnergyConditionValue)
            {
                energyCondition = EnergyConditionValue;
            }
            public void SetEnergyConditionPrevious(int EnergyConditionPreviousValue)
            {
                previousEnergyCondition = EnergyConditionPreviousValue;
            }

            /// <summary>
            /// 
            /// </summary>
            /// <param name="presetTimeInSeconds"></param>
            /// <returns></returns>
            public int SetPreset(int presetTimeInSeconds)
            {
                try
                {

                    _cMTFFPX myxrsfp = new cMTFFPX();



                    bool bReturn = myxrsfp.Send_Preset[presetTimeInSeconds];
                    if (bReturn == true)
                    {
                        int i1 = myxrsfp.Get_Preset;
                        return PASS;
                    }
                    else
                    {
                        return FAIL;
                    }
                    //check return value


                    //string pathFilename = "C:/temp/m1.tfr";


                    //myxrsfp = new cMTFFPX();

                    //var realTime = myxrsfp.Get_Realtime;
                    //var value2 = 600;
                    //var bret = false;




                }
                catch (Exception Ex)
                {
                    //
                    //int error = 1;
                    //tbSetPreset.Text = eX.ToString();
                    Logger.WriteErrorFile("Error:  Setting xrsfp preset:  " + Ex.ToString());
                    return FAIL;

                }
            }

            public int LoadMTFRFile(int EC)
            {
                try
                {
                    _cMTFFPX myxrsfp = new cMTFFPX();

                    string pathFilename;

                    pathFilename = "C:/CrossRoads Scientific/XRS-FP/Master" + EC.ToString() + ".tfr";

                    bool returnVal = myxrsfp.Open_TFR_File[pathFilename];
                    Logger.WriteLogFile("loading tfr file for Energy Condition " + EC.ToString() + " returned: " + returnVal.ToString());

                    var busyRet = true;
                    int count = 0;
                    do
                    {
                        busyRet = myxrsfp.Get_TFROpeningStatus;
                        Thread.Sleep(500);
                        Logger.WriteLogFile("busy count load tfr = " + count.ToString() + " EC = " + EC.ToString() + " busy (init true)= " + busyRet.ToString());
                        count++;

                    } while (busyRet == true && count<30);

                    //Logger.WriteLogFile("c:/temp/busy.txt", "before time wait 15 = " + count.ToString());
                    //Thread.Sleep(12000);  //was 15
                    //Logger.WriteLogFile("c:/temp/busy.txt", "after time wait 15 = " + count.ToString());


                    short code;
                    code = Convert.ToInt16(EC);
                    short ret = myxrsfp.Send_CondCode[code];

                    Logger.WriteLogFile("Send cond code:  " + code.ToString() + " Return: " + ret.ToString());

                    Thread.Sleep(2000);

                    //var response = myxrsfp.Open_File["C:/Xact 630 CALS/630 DEMO/EC2/33_As_35763_EC2.ces"];

                    if (returnVal == true)
                        return PASS;
                    else
                        return FAIL;
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in loading tfr file.  Ex=  " + Ex.ToString());
                    Logger.WriteLogFile("Error in loading tfr file.  Ex=  " + Ex.ToString());
                    return FAIL;
                }

            }


            //            public int RampXrays(double presentV, double presentI, double targetVoltage, double targetCurrent, BackgroundWorker m_oWorkerRamp, List<double> VoltageValues, List<double> CurrentValues, Form1 f)


            /// <summary>
            /// 
            /// </summary>
            /// <param name="actualCurrent"></param>
            /// <param name="actualVoltage"></param>
            /// <param name="m_oWorkerRamp"></param>
            /// <returns></returns>
            public int AutoCurrent(double actualCurrent, double actualVoltage, BackgroundWorker m_oWorkerRamp, List<double> VoltageValues, List<double> CurrentValues, Form1 f)  //in uA and kV
            {
                float deadTime = 0.0F;
                try
                {
                    deadTime = GetDeadTime();


                    //Logger.WriteLogFile("c:/temp/autocurrent.txt", "Before DT = " + deadTime.ToString());
                    //Logger.WriteLogFile("c:/temp/autocurrent.txt", "Before current = " + actualCurrent.ToString("F2"));

                    //deadTime = 90.0F;
                    if (deadTime > 55 || deadTime < 45)
                    {
                        double outputBeamCurrent = 0;


                        CalculateBeamCurrent(deadTime, (actualCurrent), out outputBeamCurrent);
                        //CalculateBeamCurrent(0F, (actualCurrent), out outputBeamCurrent);

                        //check watts
                        if ((outputBeamCurrent * actualVoltage) > 50000.0)
                        {
                            outputBeamCurrent = (50000.0 / actualVoltage);
                            if (outputBeamCurrent > 2000)
                            {
                                outputBeamCurrent = 2000.0;
                            }
                            //Logger.WriteLogFile("c:/temp/autocurrent.txt", "Setting current to max for best DT.");
                        }
                        //Logger.WriteLogFile("c:/temp/autocurrent.txt", "After current = " + outputBeamCurrent.ToString("F2"));



                        RampXrays(actualVoltage, actualCurrent, actualVoltage, outputBeamCurrent, m_oWorkerRamp, VoltageValues, CurrentValues, f);
                        Thread.Sleep(4000);
                        deadTime = GetDeadTime();
                        //Logger.WriteLogFile("c:/temp/autocurrent.txt", "After DT = " + deadTime.ToString("F2"));

                    }
                    else
                    {
                        //Logger.WriteLogFile("c:/temp/autocurrent.txt", "No current adjustment. Current = "+actualCurrent.ToString("F2")+ " Dead Time = " + deadTime.ToString("F2"));

                    }


                    return PASS;
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in AutoCurrent.  Ex = " + Ex.ToString());
                    Logger.WriteInternalLogFile("Error in AutoCurrent.  Ex = " + Ex.ToString());
                    return FAIL;
                }
            }


            public float GetDeadTime()
            {
                try
                {

                    _cMTFFPX myxrsfp = new cMTFFPX();
                    float deadtime = myxrsfp.Get_Deadtime;
                    

                    Logger.WriteLogFile("deadtime = " + deadtime.ToString());
                    //deadTime = AcquisitionControl.GetDeadTime();
                    return deadtime;
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in GetDeadTime.  Ex=  " + Ex.ToString());
                    Logger.WriteLogFile("Error in GetDeadTime.  Ex=  " + Ex.ToString());
                    Logger.WriteInternalLogFile("Error in GetDeadTime.  Ex=  " + Ex.ToString());
                    return 0;
                }



            }

            public int CalculateBeamCurrent(float deadTime, double beamCurrent, out double outputBeamCurrent)
            {

                try
                {
                    //double sglNewBeamCurrent;
                    double dblLogDeadTime;
                    double dblTerm1, dblTerm2, dblTerm3, dblTerm4;

                    double C0, C1, C2, C3;
                    double dblMultCalcDT;
                    int intDesiredPercentDT = 50;

                    //' Auto Current constants
                    double sglC0Coef = 1.0463817828;//     ' Const coefficient values for auto current eq.
                    double sglC1Coef = -0.69609779;//      ' same  as  above
                    double sglC2Coef = 0.1612194167; //
                    double sglC3Coef = -0.012870049;
                    //int intUpperLowerWindow = 5;

                    //C0 = 1.0463817828;       //' sglC0Coef * intDesiredPercentDT
                    //C1 = -0.69609779;       //  ' sglC1Coef * intDesiredPercentDT
                    //C2 = 0.1612194167;  //      ' sglC2Coef * intDesiredPercentDT
                    //C3 = -0.012870049;  //      ' sglC3Coef * intDesiredPercentDT

                    //' setup all 4 coefficients for use below
                    // desired percent = 50

                    C0 = sglC0Coef * intDesiredPercentDT;
                    C1 = sglC1Coef * intDesiredPercentDT;
                    C2 = sglC2Coef * intDesiredPercentDT;
                    C3 = sglC3Coef * intDesiredPercentDT;


                    dblLogDeadTime = Math.Log(deadTime);

                    dblTerm1 = C0;
                    dblTerm2 = C1 * dblLogDeadTime;
                    dblTerm3 = C2 * dblLogDeadTime * dblLogDeadTime;
                    dblTerm4 = C3 * dblLogDeadTime * dblLogDeadTime * dblLogDeadTime;
                    dblMultCalcDT = dblTerm1 + dblTerm2 + dblTerm3 + dblTerm4;


                    //' MsgBox "ln first Calculated Multiplier =  " & dblMultCalcDT
                    //sglNewBeamCurrent = BeamCurrent * dblMultCalcDT
                    outputBeamCurrent = beamCurrent * dblMultCalcDT;

                    //' MsgBox " New beam current needed = " & dblNewBeamCurrent
                    // CalcNewBeamCurrent = sglNewBeamCurrent



                    //Logger.WriteLogFile("c:/temp/autocurrent.txt", "outputBeamCurrent = " + outputBeamCurrent.ToString("F2"));

                    return PASS;
                }
                catch (Exception Ex)
                {
                    outputBeamCurrent = 0;
                    Logger.WriteInternalLogFile("Exception in calculate beam current.  Ex = " + Ex.ToString());

                    return FAIL;
                }
            }

            /*
            /// <summary>
            /// 
            /// </summary>
            /// <param name="actualDT"></param>
            /// <param name="actualuA"></param>
            /// <returns></returns>
            public double CalcNewBeamCurrent(float actualDT, double actualuA)
            {
                try
                {
                    //double newBeamCurrent;
                    double LogDeadTime;
                    double term1;
                    double term2;
                    double term3;
                    double term4;
                    double C0, C1, C2, C3;
                    double dmultCalcDT;
                    double DesiredPercentDT = 50;

                    double C0Coef = 1.0463817828;
                    double C1Coef = -0.69609779;
                    double C2Coef = 0.1612194167;
                    double C3Coef = -0.012870049;



                    C0 = C0Coef * DesiredPercentDT;
                    C1 = C1Coef * DesiredPercentDT;
                    C2 = C2Coef * DesiredPercentDT;
                    C3 = C3Coef * DesiredPercentDT;

                    LogDeadTime = Math.Log(actualDT);

                    term1 = C0;
                    term2 = C1 * LogDeadTime;
                    term3 = C2 * LogDeadTime * LogDeadTime;
                    term4 = C3 * LogDeadTime * LogDeadTime * LogDeadTime;
                    dmultCalcDT = term1 + term2 + term3 + term4;
                    return dmultCalcDT;
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Ex in calc beam current.  Ex = " + Ex.ToString());
                    return -1;
                }
            }
            */
            /*
            Private Function CalcNewBeamCurrent(ByVal dblActualDT As Double, ByVal sglActualBeamCurrent As Single) As Single

    Dim sglNewBeamCurrent As Single
    Dim dblLogDeadTime As Double
    Dim dblTerm1 As Double
    Dim dblTerm2 As Double
    Dim dblTerm3 As Double
    Dim dblTerm4 As Double
    Dim C0 As Double
    Dim C1 As Double
    Dim C2 As Double
    Dim C3 As Double
    Dim dblMultCalcDT As Double
    

    ' setup all 4 coefficients for use below
    C0 = sglC0Coef* intDesiredPercentDT
    C1 = sglC1Coef* intDesiredPercentDT
    C2 = sglC2Coef* intDesiredPercentDT
    C3 = sglC3Coef* intDesiredPercentDT


    dblLogDeadTime = Log(dblActualDT)


    dblTerm1 = C0
    dblTerm2 = C1 * dblLogDeadTime
    dblTerm3 = C2* dblLogDeadTime * dblLogDeadTime
   dblTerm4 = C3 * dblLogDeadTime * dblLogDeadTime * dblLogDeadTime
    dblMultCalcDT = dblTerm1 + dblTerm2 + dblTerm3 + dblTerm4
 
    ' MsgBox "ln first Calculated Multiplier =  " & dblMultCalcDT
    sglNewBeamCurrent = sglActualBeamCurrent* dblMultCalcDT
    ' MsgBox " New beam current needed = " & dblNewBeamCurrent
    CalcNewBeamCurrent = sglNewBeamCurrent

End Function
*/




            public int StartXrsfpAcquisition(int secondsToAcquire)
            {
                try
                {
                    _cMTFFPX myxrsfp = new cMTFFPX();
                    Logger.WriteInternalLogFile("Seconds to Acquire = " + secondsToAcquire.ToString());

                    bool value = myxrsfp.Send_Preset[secondsToAcquire];
                    Logger.WriteLogFile("Send preset result = " + value.ToString());
                    Logger.WriteInternalLogFile("Send preset result = " + value.ToString());

                    int returnVal;

                    returnVal = myxrsfp.Acquire_Start;
                    Logger.WriteLogFile("Start command issued.  retval= " + returnVal.ToString());
                    Logger.WriteInternalLogFile("Start command issued.  retval= " + returnVal.ToString());

                    return returnVal;
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error xrsfp start acquire.  Ex = " + Ex.ToString());
                    Logger.WriteLogFile("Error xrsfp start acquire.  Ex = " + Ex.ToString());

                    return 0;
                }

            }

            public int CheckDetectorConnection()
            {
                try
                {
                    //_cMTFFPX myxrsfp = new cMTFFPX();
                    int fReturn = FAIL;

                    var returnVal = 0;
                    int failCounter = 0;

                    do
                    {


                        _cMTFFPX myxrsfp = new cMTFFPX();

                        returnVal = myxrsfp.Connect_MCA;
                        Logger.WriteLogFile("Checking for detector connection = " + returnVal.ToString());
                        Logger.WriteInternalLogFile("Checking for detector connection = " + returnVal.ToString());

                        if (returnVal == 1)
                        {
                            fReturn = PASS;
                            break;
                        }
                        else
                        {
                            failCounter++;
                        }

                        if (failCounter >= 5)
                        {
                            fReturn = FAIL;
                            break;
                        }
                    } while (failCounter < 10);
                    return fReturn;
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error: in Check Detector Connection.  Ex= " + Ex.ToString());
                    Logger.WriteLogFile("Error: in Check Detector Connection.  Ex= " + Ex.ToString());

                    return FAIL;
                }


            }


            public int StopXrsfpAcquisition()
            {
                try
                {
                    _cMTFFPX myxrsfp = new cMTFFPX();
                    //string pathFilename;

                    //C:\Program Files\CrossRoads Scientific\XRS - FP

                    //pathFilename = "C:/Program Files/CrossRoads Scientific/XRS-FP/Master" + EC.ToString() + ".tfr";
                    //pathFilename = "C:/Xact630CALS/630DEMO/EC" + EC.ToString() + "/Master" + EC.ToString() + ".tfr";
                    //bool ret20 = myxrsfp.AutoAnalyze;
                    //bool val = myxrsfp.Acquire_Spectrum;

                    int returnVal = myxrsfp.Acquire_Stop;
                    //if (returnVal == true)
                    //    return PASS;
                    //else
                    //    return FAIL;
                    Logger.WriteLogFile("acq stop sent -- return value = " + returnVal.ToString());
                    return PASS;
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in xrsfp stop acquire.  Ex=  " + Ex.ToString());
                    return 0;
                }

            }



            public bool GetEC1Done()
            {
                return EC1Done;
            }
            public bool GetEC2Done()
            {
                return EC2Done;
            }
            public bool GetEC3Done()
            {
                return EC3Done;
            }
            public bool GetEC4Done()
            {
                return EC4Done;
            }

            public void SetEC1Done(bool ec1Done)
            {
                EC1Done = ec1Done;
            }
            public void SetEC2Done(bool ec2Done)
            {
                EC2Done = ec2Done;
            }
            public void SetEC3Done(bool ec3Done)
            {
                EC3Done = ec3Done;
            }
            public void SetEC4Done(bool ec4Done)
            {
                EC4Done = ec4Done;
            }

            public int GetEnergyCondition()
            {
                return energyCondition;
            }
            public int GetEnergyConditionPrevious()
            {
                return previousEnergyCondition;
            }

            public void IncTimerCounter()
            {
                timerCounter++;
            }

            public int GetTimerCounter()
            {
                return timerCounter;
            }
            public void ClrTimerCounter()
            {
                timerCounter = 0;
            }


            public void Test(SerialIO SerialManager)
            {
                SerialManager.WriteSerialPort("/1&");
            }

            /// <summary>
            /// steps through pump related calibration state machine
            /// </summary>
            /// <returns></returns>
            public int GetPumpCounter()
            {
                return pumpCounterVariable;
            }

            public void SetPumpCounter(int pumpCounterValue)
            {
                pumpCounterVariable = pumpCounterValue;

            }



            /// <summary>
            /// steps through leak check pump related state machine
            /// </summary>
            /// <returns></returns>
            public int GetLeakCheckCounter()
            {
                return pumpLeakCheckVariable;
            }

            public void SetLeakCheckCounter(int pumpLeakCheckValue)
            {
                pumpLeakCheckVariable = pumpLeakCheckValue;

            }

            public int GetCounterTS()
            {
                return counterVariableTS;
            }

            public int GetCounter()
            {
                return counterVariable;
            }

            public void SetCounter(int counterValue)
            {
                counterVariable = counterValue;

            }
            public void SetCounterTS(int counterValue)
            {
                counterVariableTS = counterValue;

            }


            //
            // get and set the date and time for error and run files associated with with RUN was pushed
            //

            //public void SetLogFileStart(DateTime startDateTime)
            //{
            //    logFileStartDateTime = startDateTime;
            //}

            //public DateTime GetLogFileStart()
            //{
            //    return logFileStartDateTime;
            //}

            public void SetErrorFileStart(DateTime startErrorDateTime)
            {
                errorFileStartDateTime = startErrorDateTime;
            }

            public DateTime GetErrorFileStart()
            {
                return errorFileStartDateTime;
            }









            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            public int GetPumpLockCounter()
            {
                return pumpLockCounterVariable;
            }

            public void SetPumpLockCounter(int pumpLockCounterValue)
            {
                pumpLockCounterVariable = pumpLockCounterValue;

            }
            public void ZeroPumpLockCounter()
            {
                pumpLockCounterVariable = 0;
            }



            public void IncCounter()
            {
                counterVariable += 1;

            }

            public int GetSerialWait()
            {
                return waitSerialVariable;
            }

            public void SetSerialWait(int waitSerialValue)
            {
                waitSerialVariable = waitSerialValue;

            }

            //public string GetSerialResponse()
            //{
            //    return getSerialResponseString;

            //}

            public int GetState()
            {
                return stateControl;
            }
            public int GetStateTS()
            {
                return stateControlTS;
            }


            public void SetState(int stateValue)
            {
                stateControl = stateValue;

            }

            public void SetStateTS(int stateValue)
            {
                stateControlTS = stateValue;

            }


            public int GetSamplePeriod()
            {

                //bhc debug this is debug only
                //samplePeriod = 120;
                //bhc debug this is debug only

                return samplePeriod;


            }
            /// <summary>
            /// ##
            /// </summary>
            /// <param name="minutes"></param>
            public void SetAcquireStartTimeMinutes(DateTime minutes)
            {
                DateTime tempmin;
                //handle seoncds, if any by setting to zero.
                if (minutes.Second != 0)
                {

                    tempmin = minutes.AddSeconds(-minutes.Second);
                }
                else
                {
                    tempmin = minutes;
                }
                minValueStart = tempmin.Minute;
                //double minValue1, minValue2, minValue3;



            }




            public double GetAcquireStartTimeMinutes()
            {
                return minValueStart;
            }
            public void SetEC1Time(int EC1Time)
            {

                secValue1 = EC1Time;
            }
            public void SetEC2Time(int EC2Time)

            {
                secValue2 = EC2Time;
            }
            public void SetEC3Time(int EC3Time)
            {
                secValue3 = EC3Time;
            }
            public void SetEC4Time(int EC4Time)
            {
                secValue4 = EC4Time;
            }



            public void SetPumpTime(DateTime pumpTimeValue)
            {
                PumpTime = pumpTimeValue;
            }
            public DateTime GetPumpTime()
            {
                return PumpTime;
            }

            public void SetPumpTimePrevious(DateTime pumpTimeValue)
            {
                PumpTimePrevious = pumpTimeValue;
            }
            public DateTime GetPumpTimePrevious()
            {
                return PumpTimePrevious;
            }


            public void SetAcquireStartTime(DateTime StartAcquire)
            {
                DateTime Result;
                //verify that the seconds portion is zero:
                if (StartAcquire.Second != 0)
                {
                    Result = StartAcquire.AddSeconds(-StartAcquire.Second);
                }
                else
                {
                    Result = StartAcquire;
                }
                StartAcquireTime = Result;
            }


            public void SetEC1EndTime(DateTime EC1End)
            {
                EC1EndTime = EC1End;
            }
            public void SetEC2EndTime(DateTime EC2End)
            {
                EC2EndTime = EC2End;
            }
            public void SetEC3EndTime(DateTime EC3End)
            {
                //add adjustment check to end of ec3!
                EC3EndTime = EC3End;
            }
            public void SetEC4EndTime(DateTime EC4End)
            {
                //add adjustment check to end of ec3!
                EC4EndTime = EC4End;
            }



            public bool GetEC1Enabled()
            {
                return EC1Enabled;
            }
            public bool GetEC2Enabled()
            {
                return EC2Enabled;
            }
            public bool GetEC3Enabled()
            {
                return EC3Enabled;
            }
            public bool GetEC4Enabled()
            {
                return EC4Enabled;
            }




            public void SetEC1Enabled(bool EC1en)
            {
                EC1Enabled = EC1en;
            }
            public void SetEC2Enabled(bool EC2en)
            {
                EC2Enabled = EC2en;
            }
            public void SetEC3Enabled(bool EC3en)
            {
                EC3Enabled = EC3en;
            }
            public void SetEC4Enabled(bool EC4en)
            {
                EC4Enabled = EC4en;
            }



            public DateTime GetEC1EndTime()
            {
                return EC1EndTime;
            }
            public DateTime GetEC2EndTime()
            {
                return EC2EndTime;
            }
            public DateTime GetEC3EndTime()
            {
                return EC3EndTime;
            }
            public DateTime GetEC4EndTime()
            {
                return EC4EndTime;
            }



            public DateTime AddMin(DateTime val, int SampleTime)
            {

                int modval = val.Minute % SampleTime;
                DateTime result1;
                DateTime result2;
                DateTime result3;
                if (modval == 0)
                {
                    return val;
                }
                else
                {

                    result1 = val;
                    result2 = val.AddMinutes(-1 * modval);
                    result3 = result2.AddMinutes(SampleTime);
                    return result3;
                }

            }

            public DateTime AdjMin(DateTime startVal, DateTime val, int SampleTime)
            {

                int modval = val.Minute % SampleTime;
                DateTime result1;
                DateTime result2;
                DateTime result3;
                if (modval == 0)
                {
                    return val;
                }
                else
                {
                    result1 = val;
                    if (modval > 50)
                    {
                        result2 = val.AddMinutes(60 - modval);
                        result3 = result2;
                    }
                    else
                    {
                        result2 = val.AddMinutes(-1 * modval);

                        if (modval > SampleTime * 0.5)
                        {
                            result3 = result2.AddMinutes(SampleTime);
                        }
                        else
                        {
                            result3 = result2;
                        }
                    }
                    return result3;

                }

            }



            public DateTime CalculateAcquireStartTime(DateTime DTNow)
            {
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                int samplePeriod = AcquisitionControl.GetSamplePeriod();

                //for testing only BHC
                //debug only
                // bhc debug
                //samplePeriod = 120;
                // bhc debug


                DateTime Result;
                if (samplePeriod == 15 || samplePeriod == 77)
                {
                    Result = DTNow;
                    if (DTNow.Minute >= 0 && DTNow.Minute <= 15)
                    {
                        Result = DTNow.Date.Add(new TimeSpan(DTNow.Hour, 15, 0));
                    }
                    else if (DTNow.Minute > 15 && DTNow.Minute <= 30)
                    {
                        Result = DTNow.Date.Add(new TimeSpan(DTNow.Hour, 30, 0));
                    }
                    else if (DTNow.Minute > 30 && DTNow.Minute <= 45)
                    {
                        Result = DTNow.Date.Add(new TimeSpan(DTNow.Hour, 45, 0));
                    }
                    else if (DTNow.Minute > 45 && DTNow.Minute <= 59)
                    {
                        Result = DTNow.AddHours(1.0);  //just wait
                        DateTime Result1 = Result;
                        DateTime Result2 = Result1.AddMinutes(-1 * Result.Minute);
                        DateTime Result3 = Result2.AddSeconds(-1 * Result.Second);
                        Result = Result3;
                    }
                    return Result;
                }
                else if (samplePeriod == 5)
                {
                    Result = DTNow;
                    if (DTNow.Minute >= 0 && DTNow.Minute <= 5)
                    {
                        Result = DTNow.Date.Add(new TimeSpan(DTNow.Hour, 10, 0));   //was 5
                    }
                    else if (DTNow.Minute > 5 && DTNow.Minute <= 10)
                    {
                        Result = DTNow.Date.Add(new TimeSpan(DTNow.Hour, 15, 0));
                    }
                    else if (DTNow.Minute > 10 && DTNow.Minute <= 15)
                    {
                        Result = DTNow.Date.Add(new TimeSpan(DTNow.Hour, 20, 0));
                    }
                    else if (DTNow.Minute > 15 && DTNow.Minute <= 20)
                    {
                        Result = DTNow.Date.Add(new TimeSpan(DTNow.Hour, 25, 0));
                    }
                    else if (DTNow.Minute > 20 && DTNow.Minute <= 25)
                    {
                        Result = DTNow.Date.Add(new TimeSpan(DTNow.Hour, 30, 0));
                    }
                    else if (DTNow.Minute > 25 && DTNow.Minute <= 30)
                    {
                        Result = DTNow.Date.Add(new TimeSpan(DTNow.Hour, 35, 0));
                    }
                    else if (DTNow.Minute > 30 && DTNow.Minute <= 35)
                    {
                        Result = DTNow.Date.Add(new TimeSpan(DTNow.Hour, 40, 0));
                    }
                    else if (DTNow.Minute > 35 && DTNow.Minute <= 40)
                    {
                        Result = DTNow.Date.Add(new TimeSpan(DTNow.Hour, 45, 0));
                    }
                    else if (DTNow.Minute > 40 && DTNow.Minute <= 45)
                    {
                        Result = DTNow.Date.Add(new TimeSpan(DTNow.Hour, 50, 0));
                    }
                    else if (DTNow.Minute > 45 && DTNow.Minute <= 50)
                    {
                        Result = DTNow.Date.Add(new TimeSpan(DTNow.Hour, 55, 0));
                    }
                    else if (DTNow.Minute > 50 && DTNow.Minute <= 55)
                    {
                        Result = DTNow.AddHours(1.0);  //just wait
                        DateTime Result1 = Result;
                        DateTime Result2 = Result1.AddMinutes(-1 * Result.Minute);
                        DateTime Result3 = Result2.AddSeconds(-1 * Result.Second);
                        Result = Result3;
                    }
                    else if (DTNow.Minute > 55 && DTNow.Minute <= 59)
                    {
                        Result = DTNow.AddHours(1.0);  //just wait
                        DateTime Result1 = Result;
                        DateTime Result2 = Result1.AddMinutes((-1 * Result.Minute)+5);
                        DateTime Result3 = Result2.AddSeconds(-1 * Result.Second);
                        Result = Result3;
                    }
                    return Result;
                }

                else if (samplePeriod == 30)
                {
                    Result = DTNow;
                    if (DTNow.Minute >= 0 && DTNow.Minute <= 30)
                    {
                        Result = DTNow.Date.Add(new TimeSpan(DTNow.Hour, 30, 0));
                    }
                    else if (DTNow.Minute > 30 && DTNow.Minute <= 59)
                    {
                        Result = DTNow.AddHours(1.0);  //just wait
                        DateTime Result1 = Result;
                        DateTime Result2 = Result1.AddMinutes(-1 * Result.Minute);
                        DateTime Result3 = Result2.AddSeconds(-1 * Result.Second);
                        Result = Result3;
                    }
                    return Result;
                }
                else if (samplePeriod == 60)
                {
                    Result = DTNow;
                    if (DTNow.Minute > 45)  // if >=50 then there isn't enough sample time to tube season so change to >=20
                    {
                        Result = DTNow.AddHours(1.0);  //just wait
                        DateTime Result1 = Result;
                        DateTime Result2 = Result1.AddMinutes(-1 * Result.Minute);
                        DateTime Result3 = Result2.AddSeconds(-1 * Result.Second);
                        Result = Result3;
                    }
                    else
                    {
                        Result = DTNow;
                    }
                    return Result;
                }
                else if (samplePeriod == 120)
                {
                    Result = DTNow;
                    if (DTNow.Hour % 2 == 0)
                    {
                        Result = DTNow.AddHours(0.0);
                        if (Result.Minute > 30)
                        {
                            Result = DTNow.Date.Add(new TimeSpan(Result.Hour, 0, 0));
                        }
                        else
                        {
                            Result = DTNow.Date.Add(new TimeSpan(Result.Hour, 0, 0));
                        }
                    }
                    else //we are on an odd hour
                    {
                        Result = DTNow;
                        if (Result.Minute > 30)
                        {
                            Result = DTNow.AddHours(1.0);  //just wait
                            DateTime Result1 = Result;
                            DateTime Result2 = Result1.AddMinutes(-1 * Result.Minute);
                            DateTime Result3 = Result2.AddSeconds(-1 * Result.Second);
                            Result = Result3;
                        }
                        else
                        {
                            //                            Result = DTNow.Date.Add(new TimeSpan(Result.Hour, 0, 0)); //start for 30 min sample
                            Result = DTNow.AddHours(-1.0); //go ahead and start
                            DateTime Result1 = Result;
                            DateTime Result2 = Result1.AddMinutes(-1 * Result.Minute);
                            DateTime Result3 = Result2.AddSeconds(-1 * Result.Second);
                            Result = Result3;

                        }
                    }
                    return Result;
                }
                else if (samplePeriod == 240)
                {
                    //how much time is left in the sample period from now:
                    //when does the next %4 hour time occur from how 
                    //update needed:

                    //if( )
                    // i.e. its 4:01 pm
                    //the next %4 hour time is 8pm
                    // if the hours is >0 then start
                    //else wait....



                    Result = DTNow;
                    DateTime Result2;
                    DateTime Result3;
                    DateTime Result4;



                    if (DTNow.Hour % 4 == 0)
                    {
                        //Result = DTNow.AddHours(0.0);
                        Result = DTNow.Date.Add(new TimeSpan(Result.Hour, 0, 0));

                    }
                    else //wait another till mod hours %3 ==0
                    {
                        if (Result.Hour % 4 == 0)
                        {
                            Result = DTNow;
                            return Result;
                        }

                        Result2 = DTNow.AddHours(1.0);
                        //                        Result2 = DTNow.Date.Add(new TimeSpan(Result2.Hour, 0, 0));
                        DateTime Result10 = Result2;
                        DateTime Result20 = Result10.AddMinutes(-1 * Result.Minute);
                        DateTime Result30 = Result20.AddSeconds(-1 * Result.Second);
                        Result2 = Result30;

                        if (Result2.Hour % 4 == 0)
                        {
                            return Result2;
                        }

                        Result3 = DTNow.AddHours(2.0);
                        //Result3 = DTNow.Date.Add(new TimeSpan(Result3.Hour, 0, 0));
                        DateTime Result11 = Result3;
                        DateTime Result21 = Result11.AddMinutes(-1 * Result.Minute);
                        DateTime Result31 = Result21.AddSeconds(-1 * Result.Second);  //was result 20
                        Result3 = Result31;

                        if (Result3.Hour % 4 == 0)
                        {
                            return Result3;

                        }
                        Result4 = DTNow.AddHours(3.0);
                        //                        Result4 = DTNow.Date.Add(new TimeSpan(Result4.Hour, 0, 0));
                        DateTime Result12 = Result4;
                        DateTime Result22 = Result12.AddMinutes(-1 * Result.Minute);
                        DateTime Result32 = Result22.AddSeconds(-1 * Result.Second);
                        Result4 = Result32;

                        if (Result4.Hour % 4 == 0)
                        {
                            return Result4;

                        }
                    }
                    return Result;

                }

                return DTNow;

            }
            /// <summary>
            /// 
            /// </summary>
            /// <param name="DTNow"></param>
            /// <param name="samplePeriod"></param>
            /// <returns></returns>
            public DateTime GetAcquireEndTime(DateTime DTNow)  //this is the sample end time
            {

                DateTime Result;
                DateTime Result2;




                if (samplePeriod == 15 || samplePeriod == 77)
                {
                    Result = DTNow.AddMinutes(15.0);
                    if (Result.Minute % 15 != 0)
                    {

                    }



                }
                else if (samplePeriod == 30)
                {
                    Result = DTNow.AddMinutes(30.0);
                }
                else if (samplePeriod == 60)
                {
                    Result = DTNow.AddMinutes(60.0);

                }
                else if (samplePeriod == 120)
                {
                    Result = DTNow.AddMinutes(120.0);
                }
                else if (samplePeriod == 180)
                {
                    Result = DTNow.AddMinutes(180.0);
                }
                else if (samplePeriod == 240)
                {
                    Result = DTNow.AddMinutes(240.0);
                }

                else
                {
                    Result = DTNow;
                }
                int s = Result.Second;

                //Logger.WriteLogFile(   "get acq end time,seconds value.  Must be zero.  (Will adjust end time by:) " + s.ToString());
                //remove seconds here:
                if (s != 0)
                {
                    Result2 = Result.AddSeconds(-1 * (s));
                }
                else
                {
                    Result2 = Result;
                }
                Logger.WriteLogFile("get acquire end time, returning result: " + Result2.ToString());

                return Result2;


            }



            /// <summary>
            /// 
            /// </summary>
            /// <param name="m_oWorkerPump"></param>
            public int PumpOn(BackgroundWorker m_oWorkerPump)
            {
                //Error = 0.0;
                //integral = 0.0;
                //derivative = 0.0;

                //Init parameters for the digital filter (LPF) break at about 0.5 Hz
                //labelPump.Text = "ON";
                //labelPump.BackColor = Color.Green;
                //metroPumpProgressSpinner1.Spinning = true;
                try
                {
                    //Logger.WriteInternalLogFile("Set PumpIntention = 1.");
                    PumpIntention = 1;

                    FlowVolumeValue = 0;

                    m_oWorkerPump.RunWorkerAsync();

                    //todo: add check for successful start -- how can this be done between two separately running threads?
                    //the answer is with static variables one enabling the check -- one looking at the flow rate (i.e. 16.7)
                    return PASS;
                }
                catch (Exception eX)
                {
                    Logger.WriteInternalLogFile("Set PumpIntention = 0 @ex");
                    PumpIntention = 0;
                    Logger.WriteErrorFile("Error:  Unable to start pump. Ex=" + eX.ToString());
                    return FAIL;
                }
            }
            public double GetFlowVolume()
            {
                return FlowVolumeValue;
            }
            public void SetFlowVolume(double FlowVolume)
            {
                FlowVolumeValue = FlowVolume;
            }
            public void AddFlowVolume(double FlowVolume)
            {

                FlowVolumeValue = FlowVolumeValue + FlowVolume;
                //Logger.WriteLogFile("C:/temp/pump_data.txt", "FlowVolume to add = " + FlowVolume.ToString("F2"));
                //Logger.WriteLogFile("C:/temp/pump_data.txt", "subtotal = " + FlowVolumeValue.ToString("F2"));

            }
            public void SaveFlowVolumeForAnalysis(double value)
            {
                SavedFlowVolumeForAnalysis = value;

            }
            public double GetFlowVolumeForAnalysis()
            {
                return SavedFlowVolumeForAnalysis;
            }
            public void SetFlowVolumeForAnalysis(double value)
            {
                SavedFlowVolumeForAnalysis = value;
            }




            public void SetItem(double value)
            {
                Item = value;
            }
            public double GetItem()
            {
                return Item;
            }

            /// <summary>
            /// 
            /// </summary>
            /// <param name="m_oWorkerPump"></param>
            public int PumpOff(BackgroundWorker m_oWorkerPump)
            {



                //clear variables
                //Setpoint = 0.0;
                //integral = 0.0;
                //derivative = 0.0;
                //Error = 0.0;

                //cancel thread
                int returnValue;
                try
                {

                    //Logger.WriteInternalLogFile("Set PumpIntention = 0.  ACPO.");
                    PumpIntention = 0;

                    if (m_oWorkerPump.IsBusy)
                    {
                        m_oWorkerPump.CancelAsync();
                    }
                    Logger.WriteLogFile("CANCEL pump async sent.");

                    //todo:  this must save pump volume data
    
                    returnValue = PASS;
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Set PumpIntention = 0.  ACPO. ex1.");
                    PumpIntention = 0;

                    Logger.WriteErrorFile("Exception, unable to stop Pump. Ex=" + Ex.ToString());
                    AnalogSingleChannelWriter writerOffCompletion = new AnalogSingleChannelWriter(PumpOutput.Stream);
                    writerOffCompletion.WriteSingleSample(true, 0.00);

                    returnValue = FAIL;


                }
                /*
                finally
                {
                    Logger.WriteLogFile(   "setting pump voltage to zero.");
                    Thread.Sleep(2000);
                    //to do read the NI board flow value or pump output voltage to verify off.
                    try
                    {
                        //turn off pump directly
                        AnalogSingleChannelWriter writerOffCompletion = new AnalogSingleChannelWriter(PumpOutputOffAcq.Stream);
                        writerOffCompletion.WriteSingleSample(true, 0.00);
                    }
                    catch (Exception Ex)
                    {

                        Logger.WriteErrorFile("Exception in stop Pump. Ex=" + Ex.ToString());
                        AnalogSingleChannelWriter writerOffCompletion = new AnalogSingleChannelWriter(PumpOutputOffAcq.Stream);
                        writerOffCompletion.WriteSingleSample(true, 0.00);

                    }


                }
                */
                return returnValue;




                //and must handle this:
                //labelPump.Text = "OFF";
                //labelPump.BackColor = Color.White;
                //metroPumpProgressSpinner1.Spinning = false;
            }

            /// <summary>
            /// 
            /// </summary>
            /// <param name="samplePeriodValue"></param>
            public void SetSamplePeriod(int samplePeriodValue)
            {
                samplePeriod = samplePeriodValue;
            }
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            public double GetRemainingTime()
            {
                return timeValue;
            }
            /// <summary>
            /// 
            /// </summary>
            /// <returns></returns>
            public DateTime GetAcquireStartTime()
            {
                return StartAcquireTime;
            }

            public DateTime CalculateTimeToSample()
            {
                DateTime result;
                result = DateTime.Now;
                DateTime DTNow;
                DTNow = DateTime.Now;

                //
                DateTime result2, result3, result4, result5;



                //180 is obsolete
                if (GetSamplePeriod() == 60 )
                {
                    result = DTNow.AddMinutes(GetSamplePeriod());
                    if (DTNow.Day == result.Day)
                    {
                        result2 = result;
                        result3 = result2.AddMinutes(-1 * result.Minute);
                        result4 = result3.AddSeconds(-1 * result3.Second);
                        return result4;
                    }
                    else
                    {
                        result2 = result.AddHours(-1 * result.Hour);
                        result3 = result2.AddMinutes(-1 * result.Minute);
                        result4 = result3.AddSeconds(-1 * result3.Second);
                        return result4;
                    }

                    //result = DTNow.Date.Add(new TimeSpan(result.Hour, 0, 0));
                }

                else if (GetSamplePeriod() == 120)
                {
                    result = DTNow.AddMinutes(GetSamplePeriod());
                    if (DTNow.Day == result.Day)
                    {
                        result2 = result;
                        result3 = result2.AddMinutes(-1 * result.Minute);
                        result4 = result3.AddSeconds(-1 * result3.Second);

                        if ((result4.Hour % 2) != 0)
                        {
                            result5 = result4.AddHours(-1);
                            return result5;
                        }
                        else
                        {
                            return result4;
                        }

                    }
                    else
                    {
                        result2 = result.AddHours(-1 * result.Hour);
                        result3 = result2.AddMinutes(-1 * result.Minute);
                        result4 = result3.AddSeconds(-1 * result3.Second);
                        return result4;
                    }

                    //result = DTNow.Date.Add(new TimeSpan(result.Hour, 0, 0));
                }


                else if (GetSamplePeriod() == 240)
                {
                    result = DTNow.AddMinutes(GetSamplePeriod());
                    if (DTNow.Day == result.Day)
                    {
                        result2 = result;
                        result3 = result2.AddMinutes(-1 * result.Minute);
                        result4 = result3.AddSeconds(-1 * result3.Second);
                        return result4;
                    }
                    else
                    {
                        result2 = result.AddHours(-1 * result.Hour);
                        result3 = result2.AddMinutes(-1 * result.Minute);
                        result4 = result3.AddSeconds(-1 * result3.Second);
                        return result4;
                    }

                    //result = DTNow.Date.Add(new TimeSpan(result.Hour, 0, 0));

                }


                else if (GetSamplePeriod() == 30)
                {
                    result = DTNow.AddMinutes(GetSamplePeriod());
                    if (result.Minute <= 29)
                    {
                        result2 = result;
                        result3 = result2.AddMinutes(-1 * result.Minute);

                        result4 = result3.AddSeconds(-1 * result.Second);
                        return result4;
                        //                        result = DTNow.Date.Add(new TimeSpan(result.Hour, 0, 0));
                    }
                    else
                    {
                        //result = DTNow.Date.Add(new TimeSpan(result.Hour, 30, 0));
                        result2 = result;
                        int tempMin = result2.Minute % 30;
                        result3 = result2.AddMinutes(-1 * tempMin);
                        result4 = result3.AddSeconds(-1 * result.Second);
                        return result4;
                        //result5 
                    }

                }
                else if (GetSamplePeriod() == 15 || GetSamplePeriod() == 77)
                {
                    int sample = GetSamplePeriod();
                    if (sample == 77)
                    {
                        sample = 15;
                    }
                    DateTime resultDate;
                    resultDate = DTNow.AddMinutes(sample);
                    //result = DTNow.Date.Add(new TimeSpan(result.Hour, result.Minute, 0));


                    if (resultDate.Minute <= 14)
                    {
                        result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 0, 0));

                    }
                    else if (resultDate.Minute >= 15 && resultDate.Minute <= 29)
                    {
                        result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 15, 0));
                    }
                    else if (resultDate.Minute >= 30 && resultDate.Minute <= 44)
                    {
                        result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 30, 0));
                    }
                    else if (resultDate.Minute >= 45 && resultDate.Minute <= 59)
                    {
                        result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 45, 0));
                    }
                    else
                    {
                        result = resultDate;
                    }


                }
                else if (GetSamplePeriod() == 5)
                {

                    int sample = GetSamplePeriod();
                    DateTime resultDate;
                    resultDate = DTNow.AddMinutes(sample);
                    //result = DTNow.Date.Add(new TimeSpan(result.Hour, result.Minute, 0));


                    if (resultDate.Minute <= 4)
                    {
                        result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 0, 0));
                    }
                    else if (resultDate.Minute >= 5 && resultDate.Minute <= 9)
                    {
                        result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 5, 0));
                    }
                    else if (resultDate.Minute >= 10 && resultDate.Minute <= 14)
                    {
                        result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 10, 0));
                    }
                    else if (resultDate.Minute >= 15 && resultDate.Minute <= 19)
                    {
                        result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 15, 0));
                    }
                    else if (resultDate.Minute >= 20 && resultDate.Minute <= 24)
                    {
                        result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 20, 0));
                    }
                    else if (resultDate.Minute >= 25 && resultDate.Minute <= 29)
                    {
                        result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 25, 0));
                    }
                    else if (resultDate.Minute >= 30 && resultDate.Minute <= 34)
                    {
                        result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 30, 0));
                    }
                    else if (resultDate.Minute >= 35 && resultDate.Minute <= 39)
                    {
                        result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 35, 0));
                    }
                    else if (resultDate.Minute >= 40 && resultDate.Minute <= 44)
                    {
                        result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 40, 0));
                    }
                    else if (resultDate.Minute >= 45 && resultDate.Minute <= 49)
                    {
                        result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 45, 0));
                    }
                    else if (resultDate.Minute >= 50 && resultDate.Minute <= 54)
                    {
                        result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 50, 0));
                    }
                    else if (resultDate.Minute >= 55 && resultDate.Minute <= 59)
                    {
                        result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 55, 0));
                    }
                    //else if (resultDate.Minute >= 15 && resultDate.Minute <= 19)
                    //{
                    //    result = resultDate.Date.Add(new TimeSpan(resultDate.Hour, 45, 0));
                    //}

                    else
                    {
                        result = resultDate;
                    }


                }







                return result;
            }




            //int EC1p = AcquisitionControl.GetEC1Percent();
            //int EC2p = AcquisitionControl.GetEC2Percent();
            //int EC3p = AcquisitionControl.GetEC3Percent();
            public void SetEC1Percent(double percent)
            {
                EC1Percent = percent;
            }
            public void SetEC2Percent(double percent)
            {
                EC2Percent = percent;
            }
            public void SetEC3Percent(double percent)
            {
                EC3Percent = percent;
            }

            public double GetEC1Percent()
            {
                return EC1Percent;
            }
            public double GetEC2Percent()
            {
                return EC2Percent;
            }
            public double GetEC3Percent()
            {
                return EC3Percent;
            }
            public double GetEC4Percent()
            {
                return EC4Percent;
            }



            /// <summary>
            /// 
            /// </summary>
            /// <param name="startTime"></param>
            public void SetStartTime(double startTime)
            {
                actualStartTime = startTime;

            }


            /// <summary>
            /// 
            /// </summary>
            /// <param name="SerialManager"></param>
            /// <returns></returns>
            public int MoveRodHome(SerialIO SerialManager, Form1 f)
            {

                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                try
                {

                    int movec = Properties.Settings.Default.DMC;
                    int holdc = Properties.Settings.Default.DHC;



                    int returnVal14 = AcquisitionControl.CheckEZ(SerialManager, "/1&\r");
                    if (returnVal14 == PASS)
                    {
                        f.UpdateDynamicRodMessage("Moving DR Home");

                        string stepCommand = "P" + "400" + "R\r";
                        string command1 = "/1aM4m" + movec.ToString() + "h" + holdc.ToString();
                        string command2 = command1 + stepCommand;
                        SerialManager.WriteSerialPort(command2);
                        Thread.Sleep(2500);

                        SerialManager.WriteSerialPort("/1aM4m" + movec.ToString() + "h" + holdc.ToString() + "n0f1Z7500R\r");    //was 25 5
                                                                                                                                 //Thread.Sleep(12500);
                                                                                                                                 //f.UpdateDynamicRodMessage("Home");

                        //check for sensor state....


                        int motor = 4;  //motor 4 is the  DR
                        int upperLimit = 0;
                        int lowerLimit = 0;
                        int retVal = FAIL;
                        int count = 0;
                        do
                        {

                            retVal = CheckLimitsDR(SerialManager, motor, out upperLimit, out lowerLimit);
                            if (retVal == PASS)
                            {
                                if (upperLimit <= 6000)    //typical Ul = 50, ll = 16000   && lowerLimit > 6000
                                {
                                    //filterWheelCurrentPosition = 0;
                                    //Logger.WriteInternalLogFile("DRH sensor UL = " + upperLimit.ToString() + " sensor LL = " + lowerLimit.ToString());
                                    //f.UpdateDynamicRodMessage("DR home sensor found");
                                    //Thread.Sleep(750);
                                    break; //return PASS;

                                }
                            }
                            count++;
                            Thread.Sleep(500);

                        } while (count < 60) ;

                            if (upperLimit <= 6000)    //typical Ul = 50, ll = 16000   && lowerLimit > 6000
                            {
                                filterWheelCurrentPosition = 0;
                                Logger.WriteInternalLogFile("DRH sensor UL = " + upperLimit.ToString() + " sensor LL = " + lowerLimit.ToString());
                                f.UpdateDynamicRodMessage("DR home.  Home sensor found");
                                Thread.Sleep(750);
                                return PASS;

                            }
                            else
                            {
                                Logger.WriteErrorFile("Error:  DR Home sensor not found.  Sensor value <=6000 required.  Sensor = " + upperLimit.ToString());
                            Logger.WriteLogFile("Error:  DR Home sensor not found.  Sensor value <=6000 required.  Sensor = " + upperLimit.ToString());
                            Logger.WriteInternalLogFile("DRH sensor UL = " + upperLimit.ToString() + " sensor LL = " + lowerLimit.ToString());
                                f.UpdateDynamicRodMessage("DR home sensor not found");
                                Thread.Sleep(750);
                                return FAIL;
                            }


                            //int retVal = CheckLimitsDR(SerialManager, motor, out upperLimit, out lowerLimit);


                            //upperLimit = 16000;  //inject error to test system response.
                            /*
                            if (retVal == PASS)
                            {

                                if (upperLimit <= 6000 )    //typical Ul = 50, ll = 16000   && lowerLimit > 6000
                                {
                                filterWheelCurrentPosition = 0;
                                    //f.UpdateDynamicRodMessage("Home");
                                    Logger.WriteInternalLogFile("DRH sensor UL = " + upperLimit.ToString() + " sensor LL = " + lowerLimit.ToString());
                                    //f.UpdateMaintFilterWheelMessage("Home");
                                    f.UpdateDynamicRodMessage("DR home sensor found");
                                    Thread.Sleep(1000);
                                    return PASS;

                                }
                               else
                                {
                                    Logger.WriteErrorFile("Error:  DR Home sensor not found.  Sensor value <=6000 required.  Sensor = " + upperLimit.ToString());
                                    Logger.WriteInternalLogFile("DRH sensor UL = " + upperLimit.ToString() + " sensor LL = " + lowerLimit.ToString());
                                    f.UpdateDynamicRodMessage("DR home sensor not found");
                                    return FAIL;
                                }
                            }
                            else
                            {
                                Logger.WriteErrorFile("DR home: Read home sensor failed  (check limits function failed).");
                                return FAIL;

                            }
                            */
                    }
                    else
                    {
                            Logger.WriteInternalLogFile("Error: Check EZ failed at Move DR Home. Check motor control board.");
                            f.UpdateDynamicRodMessage("Error:  Move DR Home. Check motor control board.");
                            return FAIL;
                    }
                    
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error: in Rod home command.  Ex = " + Ex.ToString());
                    Logger.WriteLogFile("Error: in Rod home command.  Ex = " + Ex.ToString());

                    f.UpdateDynamicRodMessage("Move DR home failed.");
                    return FAIL;
                }


            }


            /// <summary>
            /// 
            /// </summary>
            /// <param name="SerialManager"></param>
            /// <returns></returns>
            public int MoveRod(SerialIO SerialManager, int position, Form1 f)
            {

                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                try
                {


                    int movec = Properties.Settings.Default.DMC;
                    int holdc = Properties.Settings.Default.DHC;


                    //int returnVal14 = AcquisitionControl.CheckEZ(SerialManager, "/1&\r");
                    //if (returnVal14 == PASS)
                    //{
                        SerialManager.WriteSerialPort("/1aM4m" + movec.ToString() + "h" + holdc.ToString() + "n0P" + position.ToString() + "R\r");    //was 25/5
                        if (position == Properties.Settings.Default.UpscaleRodPosition)
                        {
                            f.UpdateDynamicRodMessage("Moving DR to Upscale Position (" + position.ToString() + ")");
                        }
                        else if (position == Properties.Settings.Default.EcalRodPosition)
                        {
                            f.UpdateDynamicRodMessage("Moving DR to Ecal Position (" + position.ToString() + ")");
                        }
                        else
                        {
                            f.UpdateDynamicRodMessage("Moving DR (" + position.ToString() + ")");
                        }
                        //Thread.Sleep(12500);



                        //poll for position







                        return PASS;

                    //}
                    //else
                    //{
                    //    Logger.WriteErrorFile("Error:  Motor Control board unresponsive. Move to upscale position " + position.ToString() + " function failed.");
                    //    f.UpdateDynamicRodMessage("Motor Control board unresponsive.");
                    //    return FAIL;

                    //}



                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in move DR to position command = " + Ex.ToString());
                    Logger.WriteLogFile("Error in move DR to position command = " + Ex.ToString());
                    f.UpdateDynamicRodMessage("Failed move to upscale position " + position.ToString());
                    return FAIL;

                }




            }



            /// <summary>
            /// 
            /// </summary>
            /// <param name="SerialManager"></param>
            /// <returns></returns>
            public int MoveFWHome(SerialIO SerialManager, Form1 f)
            {
                int count = 0;
                do
                {


                    try
                    {
                        f.UpdateFilterWheelMessage("Moving FW Home");
                        int movec = Properties.Settings.Default.FWMC;
                        int holdc = Properties.Settings.Default.FWHC;
                        int fwHomeKick = Properties.Settings.Default.FWHK;

                        //SerialManager.WriteSerialPort("/1aM1m"+movec.ToString()+"h"+holdc.ToString()+"n0M500P500Z7000P10z0R\r");    //was 25/7   1.0.0.56 inc to 50/15
                        SerialManager.WriteSerialPort("/1aM1m" + movec.ToString() + "h" + holdc.ToString() + "n0M500P500Z7000P" + fwHomeKick.ToString() + "z0R\r");    //was 25/7   1.0.0.56 inc to 50/15

                        //f.UpdateMaintFilterWheelMessage("Moving FW Home");


                        Thread.Sleep(750);

                        int motor = 1;  //motor 1 is the  FW
                        int upperLimit = 0;
                        int lowerLimit = 0;
                        int retVal = FAIL;
                        int limitcounter = 0;
                        do
                        {
                            Logger.WriteInternalLogFile("Checking FW Home ....");
                            retVal = CheckLimitsFW(SerialManager, motor, out upperLimit, out lowerLimit);
                            if (retVal == PASS)
                            {
                                if (upperLimit < 6000)
                                {
                                    break;
                                }
                            }
                            limitcounter++;
                            Thread.Sleep(500);

                        } while (limitcounter < 30);

                        //if (retVal == PASS)
                        //{

                            if (upperLimit <= 6000 /*&& lowerLimit > 6000*/)    //typical Ul = 50, ll = 16000
                            {
                                filterWheelCurrentPosition = 0;
                                f.UpdateFilterWheelMessage("FW home.  Home sensor found");
                                Thread.Sleep(500);
                                Logger.WriteInternalLogFile("FWH sensor UL = " + upperLimit.ToString() + " sensor LL = " + lowerLimit.ToString());
                                //f.UpdateMaintFilterWheelMessage("Home");
                                return PASS;

                            }
                            else
                            {
                                Logger.WriteErrorFile("Error:  FW Home sensor not found.  Sensor value <=6000 required.  Sensor = " + upperLimit.ToString());
                                Logger.WriteLogFile("Error:  FW Home sensor not found.  Sensor value <=6000 required.  Sensor = " + upperLimit.ToString());
                                f.UpdateFilterWheelMessage("Error: FW Home sensor not found");
                                count++;
                            }

                        //}
                        //else
                        //{
                        //    Logger.WriteErrorFile("FW Home Read Home sensor command failed  (check limits function failed).");
                        //    f.UpdateFilterWheelMessage("Error: Read FW Home sensor failed");
                        //    return FAIL;

                        //}
                    }
                    catch (Exception Ex)
                    {

                        Logger.WriteErrorFile("Error move FW Home. Ex = " + Ex.ToString());
                        f.UpdateFilterWheelMessage("Error: Move FW Home failed");
                        count++;  
                        //return FAIL;
                    }
                } while (count < 3);

                Logger.WriteErrorFile("FW Home Read Home sensor command failed  (check limits function failed).");
                Logger.WriteLogFile("FW Home Read Home sensor command failed  (check limits function failed).");

                f.UpdateFilterWheelMessage("Error: Read FW Home sensor failed");
                return FAIL;


            }

            public int PollMotorPosition(int motor, SerialIO SerialManager)
            {//1=FW, 2=TP, 3=NZ, 4=DR
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                //check for stable position read 
                int pos3 = 0;
                int pos2 = 1;
                int pos1 = 2;
                int retv = FAIL;
                int counter = 0;
                int sameCounter = 0;

                int sameCounterLimit = 0;
                string motorID="";
                if (motor == 4)
                {
                    motorID = "DR";
                    sameCounterLimit = 3;
                }
                else if (motor == 3)
                {
                    motorID = "NZ";
                    sameCounterLimit = 1;
                }
                else if (motor == 2)
                {
                    motorID = "TP";
                    sameCounterLimit = 1;
                }
                else if (motor ==1)
                {
                    motorID = "FW";
                    sameCounterLimit = 1;
                }

                int getPositionValue = 0;
                do
                {
                    retv = AcquisitionControl.CheckMotorPosition(SerialManager, motor, out getPositionValue);
                    if (retv == PASS)
                    {
                        pos1 = getPositionValue;

                        Logger.WriteInternalLogFile("Poll: checking "+motorID+" pos = " + getPositionValue.ToString());

                        if ((pos1 == pos2) && (pos1 == pos3))
                        {
                            sameCounter++;
                            if (sameCounter >= sameCounterLimit)
                            {
                                break;

                            }
                        }
                        pos3 = pos2;
                        pos2 = pos1;

                    }
                    counter++;
                    Thread.Sleep(350);
                } while (counter < 60);

                int positionReturn = -1;
                if (sameCounter >= sameCounterLimit)
                {
                    positionReturn = pos1;
                }
                return positionReturn;
            }


            public int PollMotorPositionTape(int motor, SerialIO SerialManager, out int tapeULduring, out int tapeLLduring)
            {//1=FW, 3=TP, 2=NZ, 4=DR
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                //check for stable position read 
                int pos3 = 0;
                int pos2 = 1;
                int pos1 = 2;
                int retv = FAIL;
                int counter = 0;
                int sameCounter = 0;
                int tapeUpperLduring = 0;
                int tapeLowerLduring = 0;


                int sameCounterLimit = 0;
                string motorID = "";

                tapeULduring = -1;
                tapeLLduring = -1;

                if (motor == 4)
                {
                    motorID = "DR";
                    sameCounterLimit = 3;
                }
                else if (motor == 3)
                {
                    motorID = "NZ";
                    sameCounterLimit = 1;
                }
                else if (motor == 2)
                {
                    motorID = "TP";
                    sameCounterLimit = 1;
                }
                else if (motor == 1)
                {
                    motorID = "FW";
                    sameCounterLimit = 1;
                }

                int getPositionValue = 0;
                do
                {
                    retv = AcquisitionControl.CheckMotorPosition(SerialManager, motor, out getPositionValue);
                    if (retv == PASS)
                    {
                        pos1 = getPositionValue;

                        Logger.WriteInternalLogFile("Poll: checking " + motorID + " pos = " + getPositionValue.ToString());

                        if ((pos1 == pos2) && (pos1 == pos3))
                        {
                            sameCounter++;
                            if (sameCounter >= sameCounterLimit)
                            {
                                AcquisitionControl.CheckLimitsTape(SerialManager, 3, out tapeUpperLduring, out tapeLowerLduring);
                                tapeULduring = tapeUpperLduring;
                                tapeLLduring = tapeLowerLduring;

                                break;

                            }
                        }
                        pos3 = pos2;
                        pos2 = pos1;

                    }
                    counter++;

                    //if(counter==1)  //was 3 -- waits too long if tape is nearly empty
                    //{
                    //    AcquisitionControl.CheckLimitsTape(SerialManager, 3, out tapeUpperLduring, out tapeLowerLduring);
                    //    tapeULduring = tapeUpperLduring;
                    //    tapeLLduring = tapeLowerLduring;
                    //}
                    Thread.Sleep(300);




                } while (counter < 60);

                int positionReturn = -1;
                if (sameCounter >= sameCounterLimit)
                {
                    positionReturn = pos1;
                }
                return positionReturn;
            }






            /// <summary>
            /// single function to handle fw movement
            /// </summary>
            /// <param name="SerialManager"></param>
            /// <param name="ecStart"></param>
            /// <param name="ecEnd"></param>
            /// <returns></returns>
            public int MoveFWEC(SerialIO SerialManager, int ecStart, int ecEnd, Form1 f)
            {
                int movec = Properties.Settings.Default.FWMC;
                int holdc = Properties.Settings.Default.FWHC;

                fwEC1Pos = Properties.Settings.Default.FWEC1;  //update position check variables (in case the FW pos settings have changed
                fwEC2Pos = Properties.Settings.Default.FWEC2;
                fwEC3Pos = Properties.Settings.Default.FWEC3;
                fwEC4Pos = Properties.Settings.Default.FWEC4;


                //int stepsToMove = 0;
                int move = 0;
                try
                {

                    if (ecStart == 0)
                    {
                        if (ecEnd == 1)
                        {
                            move = fwEC1Pos;
                        }
                        else if (ecEnd == 2)
                        {
                            move = fwEC2Pos;
                        }
                        else if (ecEnd == 3)
                        {
                            move = fwEC3Pos;
                        }
                        else if (ecEnd == 4)
                        {
                            move = fwEC4Pos;
                        }

                    }
                    else if (ecStart == 1)
                    {
                        if (ecEnd == 2)
                        {
                            move = (fwEC2Pos - fwEC1Pos);
                        }
                        else if (ecEnd == 3)
                        {
                            move = (fwEC3Pos - fwEC1Pos);
                        }
                        else if (ecEnd == 4)
                        {
                            move = (fwEC4Pos - fwEC1Pos);
                        }

                    }
                    else if (ecStart == 2)
                    {
                        if (ecEnd == 1)
                        {
                            move = (fwEC1Pos - fwEC2Pos);
                        }
                        else if (ecEnd == 3)
                        {
                            move = (fwEC3Pos - fwEC2Pos);
                        }
                        else if (ecEnd == 4)
                        {
                            move = (fwEC4Pos - fwEC2Pos);
                        }


                    }
                    else if (ecStart == 3)
                    {
                        if (ecEnd == 1)
                        {
                            move = (fwEC1Pos - fwEC3Pos);
                        }
                        else if (ecEnd == 2)
                        {
                            move = (fwEC2Pos - fwEC3Pos);
                        }
                        else if (ecEnd == 4)
                        {
                            move = (fwEC4Pos - fwEC3Pos);
                        }
                    }
                    else if (ecStart == 4)
                    {
                        if (ecEnd == 1)
                        {
                            move = (fwEC1Pos - fwEC4Pos);
                        }
                        else if (ecEnd == 2)
                        {
                            move = (fwEC2Pos - fwEC4Pos);
                        }
                        else if (ecEnd == 3)
                        {
                            move = (fwEC3Pos - fwEC4Pos);
                        }
                    }


                    string command;
                    if (move > 0)
                    {
                        command = "/1aM1m" + movec.ToString() + "h" + holdc.ToString() + "n0M500P" + move.ToString() + "R\r";   //was 30/5
                    }
                    else if (move < 0)
                    {
                        move = (move * -1);  //or math.abs
                        command = "/1aM1m" + movec.ToString() + "h" + holdc.ToString() + "n0M500D" + move.ToString() + "R\r";
                    }
                    else //do not send a move of zero 
                    {
                        command = "/1aM1m" + movec.ToString() + "h" + holdc.ToString() + "n0M500" + "R\r";
                    }
                    if (ecStart == 0)
                    {
                        f.UpdateFilterWheelMessage("Moving FW from home to EC" + ecEnd.ToString());

                    }
                    else
                    {
                        f.UpdateFilterWheelMessage("Moving FW from EC" + ecStart.ToString() + " to EC" + ecEnd.ToString());
                    }
                    //f.UpdateMaintFilterWheelMessage("Moving FW from EC" + ecStart.ToString() + " to EC" + ecEnd.ToString());

                    SerialManager.WriteSerialPort(command);
                    //filterWheelCurrentPosition = totalSteps;


                    //Thread.Sleep(2500);

                    //todo: query motor possition and home sensor to determine success and 
                    //todo: add retry logic


                    //f.UpdateFilterWheelMessage("Filter Wheel at EC" + ecEnd.ToString());
                    //f.UpdateMaintFilterWheelMessage("Filter Wheel at EC" + ecEnd.ToString());

                    //query motor position after move
                    //do
                    //{



                    //}while




                    return PASS;
                }
                catch (Exception Ex)
                {
                    f.UpdateFilterWheelMessage("Error in move Filter Wheel.  Ex = " + Ex.ToString());
                    //f.UpdateMaintFilterWheelMessage("Error in move Filter Wheel");

                    Logger.WriteErrorFile("Error in move FW Home: Ex = " + Ex.ToString());
                    Logger.WriteLogFile("Error in move FW Home: Ex = " + Ex.ToString());

                    return FAIL;
                }

            }







            /// <summary>
            /// 
            /// </summary>
            /// <param name="SerialManager"></param>
            /// <returns>1=pass 0=fail 2=fail nozzle</returns>
            public int MoveTapeFull(SerialIO SerialManager, Form1 f)
            {

                ////////////////////////////////////////start

                // Motor 3 - Tape FULL Advance
                // Uses Motor 3 - checks motor two limits before moving the tape
                //add stop and error
                int motorPositionBefore;
                int motorPositionAfter;

                motorPositionBefore = 0;
                motorPositionAfter = 0;

                try
                {

                    Logger.WriteLogFile("Encoder wheel  U Limit threshold (changes state during move) = " + Properties.Settings.Default.EncoderWheelUL.ToString());
                    Logger.WriteLogFile("Encoder wheel  L Limit threshold  = " + Properties.Settings.Default.EncoderWheelLL.ToString());


                    if (Properties.Settings.Default.TapeMidMoveCheckEnable == 1)
                    {
                        Logger.WriteLogFile("Move Tape Full:  TapeMidMoveCheckEnable = 1");

                    }
                    else
                    {
                        Logger.WriteLogFile("Move Tape Full:  TapeMidMoveCheckEnable = 0");
                    }


                    int movec = Properties.Settings.Default.TapeMC;
                    int holdc = Properties.Settings.Default.TapeHC;

                    f.UpdateMaintTapeMessage("Move full...");

                    AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                    int motor = 2;  //motor 2 is the nozzle up/dn
                    int upperLimit = 0;
                    int lowerLimit = 0;
                    int retVal = AcquisitionControl.CheckLimitsNZ(SerialManager, motor, out upperLimit, out lowerLimit);

                    int beforeLimitsUpper = -1;
                    int beforeLimitsLower = -1;
                    int afterLimitsUpper = -1;
                    int afterLimitsLower = -1;

                    int duringLimitsUpper = -1;
                    int duringLimitsLower = -1;
                    if (retVal == PASS)
                    {

                        if (upperLimit > 12000 && lowerLimit < 6000)   //ll was 1000 this are the Nozzle limits, checked here
                        {
                            int move1000counter = 0;
                            do
                            {
                                AcquisitionControl.ZeroMotorPosition(SerialManager, 3);  //motor 3 is the tape 
                                motorPositionBefore = AcquisitionControl.PollMotorPosition(3, SerialManager);

                                CheckLimitsTape(SerialManager, 3, out beforeLimitsUpper, out beforeLimitsLower);
                                Logger.WriteLogFile("Encoder wheel  before move U Limit  = " + beforeLimitsUpper.ToString());
                                Logger.WriteLogFile("Encoder wheel  before move L Limit  = " + beforeLimitsLower.ToString());

                                //                                SerialManager.WriteSerialPort("/1aM3m" + movec.ToString() + "h" + holdc.ToString() + "V2270n0z0M500D1000R\r");
                                SerialManager.WriteSerialPort("/1aM3m" + movec.ToString() + "h" + holdc.ToString() + "V2000n0z0M500D1000R\r");
                                Logger.WriteLogFile("Move off sensor (1000) counts move command sent.");

                                SerialManager.responseVariable = 0;
                                SerialManager.serialResponseString = "";

                                int count = 0;
                                do
                                {
                                    Thread.Sleep(250);
                                    motorPositionAfter = AcquisitionControl.PollMotorPositionTape(3, SerialManager, out duringLimitsUpper, out duringLimitsLower);
                                    count++;
                                } while (count < 3 && motorPositionAfter != -1000);
                                Logger.WriteLogFile("Encoder wheel  during move U Limit  = " + duringLimitsUpper.ToString());
                                Logger.WriteLogFile("Encoder wheel  during move L Limit  = " + duringLimitsLower.ToString());
                                move1000counter++;
                                Logger.WriteLogFile("Tape move off sensor count = " + move1000counter.ToString());

                            } while ((move1000counter < 2) && (duringLimitsUpper < Properties.Settings.Default.EncoderWheelUL));




                            //SerialManager.WriteSerialPort("/1aM3m" + movec.ToString() + "h" + holdc.ToString() + "V2270n0z0M500D8000f1n2D12000R\r");
                            SerialManager.WriteSerialPort("/1aM3m" + movec.ToString() + "h" + holdc.ToString() + "V2000n0z0M500D8000f1n2D12000R\r");
                            Logger.WriteLogFile("Command sent:  move 8000 , and check for next encoder wheel slot.");



                            //CheckLimitsTape(SerialManager, 3, out afterLimitsUpper, out afterLimitsLower);
                            motorPositionAfter = AcquisitionControl.PollMotorPositionTape(3, SerialManager, out afterLimitsUpper, out afterLimitsLower);
                            Logger.WriteLogFile(" Tape Move After: ," + motorPositionAfter.ToString(), "c:/ces/internallog/tapemotor.txt");
                            Logger.WriteLogFile("Encoder wheel  after move U Limit  = " + afterLimitsUpper.ToString());
                            Logger.WriteLogFile("Encoder wheel  after move L Limit  = " + afterLimitsLower.ToString());


                            int value1 = Properties.Settings.Default.EncoderWheelLL;
                            int value2 = Properties.Settings.Default.EncoderWheelUL;

                            Logger.WriteInternalLogFile("Encoder wheel  before move Limit  = "  + beforeLimitsUpper.ToString());
                            Logger.WriteInternalLogFile("Encoder wheel  during move Limit  = " + duringLimitsUpper.ToString());
                            Logger.WriteInternalLogFile("Encoder wheel  after move Limit  = " + afterLimitsUpper.ToString());

                            if (motorPositionAfter <= -20000 || motorPositionAfter ==-1)
                            {
                                f.UpdateMaintTapeMessage("Error:  Check tape");
                                Logger.WriteErrorFile("Error:  Check tape.");
                                Logger.WriteLogFile("Error:  Check tape.");
                                return FAIL;
                            }


                            else if(duringLimitsUpper<Properties.Settings.Default.EncoderWheelUL)
                            {
                                f.UpdateMaintTapeMessage("Error:  check tape");
                                //ERROR tape broken
                                Logger.WriteErrorFile("Error: Tape full move. Encoder wheel shows tape did not move. (during limit too low) Check tape.");
                                Logger.WriteLogFile("Error: Tape full move.  Encoder wheel input did not read >10000 during move. Input = "+duringLimitsUpper.ToString() + "  Check tape.");
                                Logger.WriteInternalLogFile("Error: Tape full move.  Encoder wheel shows tape did not move. (during limit too low) Check tape.");
                                if (Properties.Settings.Default.TapeMidMoveCheckEnable == 1)
                                {


                                    Logger.WriteLogFile("TapeMidMoveCheckEnable = 1");

                                    return FAIL;
                                }
                                else
                                {
                                    f.UpdateMaintTapeMessage("Error:  check tape, pass");
                                    Logger.WriteLogFile("TapeMidMoveCheckEnable = 0");
                                    return PASS;
                                }
                            }

                            //version 1.2.0.49, move tape check value at start to 7000 from 6000
                            else if(beforeLimitsUpper >  7000)  //Properties.Settings.Default.EncoderWheelLL)
                            {
                                f.UpdateMaintTapeMessage("Pass");
                                //ERROR tape broken
                                //Logger.WriteErrorFile("Error: Tape full move. Encoder wheel shows tape did not move. (before limit too hi) Check tape.");
                                Logger.WriteLogFile("Tape full move.  Encoder wheel limit is high at start of move.  Encoder wheel limit = "+beforeLimitsUpper.ToString()+"  Check tape.");
                                Logger.WriteInternalLogFile("Tape full move.  Encoder wheel limit is high at start of move. Encoder wheel limit = "+beforeLimitsUpper.ToString()+"  Check tape.");
                                //return FAIL;
                                //                                return PASS;

                                if (Properties.Settings.Default.TapeMidMoveCheckEnable == 1)
                                {
                                    Logger.WriteLogFile("TapeMidMoveCheckEnable = 1");

                                    return FAIL;
                                }
                                else
                                {
                                    f.UpdateMaintTapeMessage("Error:  check tape, pass");
                                    Logger.WriteLogFile("TapeMidMoveCheckEnable = 0");
                                    return PASS;
                                }

                            }


                            else if (afterLimitsUpper > Properties.Settings.Default.EncoderWheelLL)
                            {
                                f.UpdateMaintTapeMessage("Error:  check tape");
                                //ERROR tape broken
                                Logger.WriteErrorFile("Error: Tape full move. Encoder wheel shows tape did not move. Encoder wheel limit >6000.  Limit = "+afterLimitsUpper.ToString()+" Check tape.");
                                Logger.WriteLogFile("Error: Tape full move.Encoder wheel shows tape did not move.Encoder wheel limit > 6000.Limit = "+afterLimitsUpper.ToString()+" Check tape.");
                                Logger.WriteInternalLogFile("Error: Tape full move. Encoder wheel shows tape did not move. Encoder wheel limit >6000.  Limit = " + afterLimitsUpper.ToString() + " Check tape.");
                                //                                return FAIL;
                                if (Properties.Settings.Default.TapeMidMoveCheckEnable == 1)
                                {
                                    Logger.WriteLogFile("TapeMidMoveCheckEnable = 1");

                                    return FAIL;
                                }
                                else
                                {
                                    f.UpdateMaintTapeMessage("Error:  check tape, pass");
                                    Logger.WriteLogFile("TapeMidMoveCheckEnable = 0");
                                    return PASS;
                                }

                            }

                            else
                            {
                                f.UpdateMaintTapeMessage("Pass");
                                return PASS;
                            }

                        }
                        else if (upperLimit < 6000 && lowerLimit > 12000)  //ul was 1000
                        {
                            f.UpdateMaintTapeMessage("Error.  Nozzle up");
                            Logger.WriteErrorFile("Move tape command, but Nozzle limits show UP!  Upper = " + upperLimit.ToString() + " Lower = " + lowerLimit.ToString());
                            Logger.WriteLogFile("Move tape command, but Nozzle limits show UP!  Upper = " + upperLimit.ToString() + " Lower = " + lowerLimit.ToString());
                            return FAIL_NOZZLE;
                        }
                        else
                        {
                            f.UpdateMaintTapeMessage("Error: Nozzle limits Invalid");
                            Logger.WriteLogFile("Move tape command,  INVALID nozzle limit switch return values.  Lower = " + lowerLimit.ToString() + " Upper = " + upperLimit.ToString());
                            return FAIL_NOZZLE;
                        }
                    }
                    else
                    {
                        //mtbTapeControlStatus.Text = "Fail limits";
                        f.UpdateMaintTapeMessage("Error:  check limits failed");
                        Logger.WriteErrorFile("Tape move (full) Nozzle command, check limits function failed.");
                        return FAIL_NOZZLE;
                    }


                }
                catch (Exception Ex)
                {
                    f.UpdateMaintTapeMessage("Error:  tape move full");
                    Logger.WriteErrorFile("Error in Tape Move (Full) command. Ex = " + Ex.ToString());
                    Logger.WriteLogFile("Error in Tape Move (Full) command. Ex = " + Ex.ToString());
                    return FAIL;
                }
            }


            /// <summary>
            /// 
            /// </summary>
            /// <param name="SerialManager"></param>
            /// <returns></returns>
            public int MoveTapeHalf(SerialIO SerialManager, Form1 f)
            { //move tape half
                //////////////////////  start

                // Motor 3 - Tape half Advance
                // Uses Motor 3 - checks motor two limits before moving the tape
                //mtbTapeControlStatus.Text = "Move half...";
                //mtbTapeControlStatus.Refresh();
                f.UpdateMaintTapeMessage("Move half...");

                try
                {


                    Logger.WriteLogFile("Encoder wheel  U Limit threshold (changes state during move) = " + Properties.Settings.Default.EncoderWheelUL.ToString());
                    Logger.WriteLogFile("Encoder wheel  L Limit threshold  = " + Properties.Settings.Default.EncoderWheelLL.ToString());



                    if (Properties.Settings.Default.TapeMidMoveCheckEnable == 1)
                    {
                        Logger.WriteLogFile("Move Tape Half:  TapeMidMoveCheckEnable = 1");

                    }
                    else
                    {
                        Logger.WriteLogFile("Move Tape Half:  TapeMidMoveCheckEnable = 0");
                    }


                    int movec = Properties.Settings.Default.TapeMC;
                    int holdc = Properties.Settings.Default.TapeHC;

                    AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                    int motor = 2;  //motor 2 is the nozzle up/dn
                    int upperLimit = 0;
                    int lowerLimit = 0;


                    int beforeLimitsUpper = -1;
                    int beforeLimitsLower = -1;
                    int duringLimitsUpper = -1;
                    int duringLimitsLower = -1;
                    int afterLimitsUpper = -1;
                    int afterLimitsLower = -1;

                    int retVal = AcquisitionControl.CheckLimitsNZ(SerialManager, motor, out upperLimit, out lowerLimit);

                    if (retVal == PASS)
                    {

                        if (upperLimit > 12000 && lowerLimit < 6000)  //ll was 1000
                        {
                            int motorPositionBefore = 0;
                            int motorPositionAfter = 0;


                            int move1000counter = 0;
                            do
                            {
                                AcquisitionControl.ZeroMotorPosition(SerialManager, 3);  //motor 3 is the tape 
                                motorPositionBefore = AcquisitionControl.PollMotorPosition(3, SerialManager);

                                CheckLimitsTape(SerialManager, 3, out beforeLimitsUpper, out beforeLimitsLower);
                                Logger.WriteLogFile("Encoder wheel  before move U Limit  = " + beforeLimitsUpper.ToString());
                                Logger.WriteLogFile("Encoder wheel  before move L Limit  = " + beforeLimitsLower.ToString());

                                //SerialManager.WriteSerialPort("/1aM3m" + movec.ToString() + "h" + holdc.ToString() + "V2270n0z0M500D1000R\r");
                                SerialManager.WriteSerialPort("/1aM3m" + movec.ToString() + "h" + holdc.ToString() + "V2000n0z0M500D1000R\r");
                                Logger.WriteLogFile("Move off sensor (1000) counts move command sent.");

                                SerialManager.responseVariable = 0;
                                SerialManager.serialResponseString = "";

                                int count = 0;
                                do
                                {
                                    Thread.Sleep(250);
                                    motorPositionAfter = AcquisitionControl.PollMotorPositionTape(3, SerialManager, out duringLimitsUpper, out duringLimitsLower);
                                    count++;
                                } while (count < 3 && motorPositionAfter != -1000);
                                Logger.WriteLogFile("Encoder wheel  during move U Limit  = " + duringLimitsUpper.ToString());
                                Logger.WriteLogFile("Encoder wheel  during move L Limit  = " + duringLimitsLower.ToString());
                                move1000counter++;
                                Logger.WriteLogFile("Tape move off sensor count = " + move1000counter.ToString());

                            } while ((move1000counter < 2) && (duringLimitsUpper < Properties.Settings.Default.EncoderWheelUL));







                            //complete the move:
                            //SerialManager.WriteSerialPort("/1aM3m" + movec.ToString() + "h" + holdc.ToString() + "V2270n0z0M500D1000f1n2D10000R\r");   //half 
                            SerialManager.WriteSerialPort("/1aM3m" + movec.ToString() + "h" + holdc.ToString() + "V2000n0z0M500D1000f1n2D10000R\r");   //half 


                            motorPositionAfter = AcquisitionControl.PollMotorPositionTape(3, SerialManager, out afterLimitsUpper, out afterLimitsLower);


                            Logger.WriteInternalLogFile("beforeLimitsUpper  = " + beforeLimitsUpper.ToString());
                            Logger.WriteInternalLogFile("duringLimitsUpper  = " + duringLimitsUpper.ToString());
                            Logger.WriteInternalLogFile("afterLimitsUpper   = " + afterLimitsUpper.ToString());



                            if (motorPositionAfter <= -11000 || motorPositionAfter == -1)
                            {
                                f.UpdateMaintTapeMessage("Error:  check tape");
                                //ERROR tape broken
                                Logger.WriteErrorFile("Error: Tape half move.  Check tape.");
                                Logger.WriteLogFile("Error: Tape half move.  Check tape.");

                                return FAIL;
                            }
                            else if (duringLimitsUpper < Properties.Settings.Default.EncoderWheelUL)
                            {
                                f.UpdateMaintTapeMessage("Error:  check tape");
                                //ERROR tape broken
                                Logger.WriteErrorFile("Error: Tape half move. Encoder wheel shows tape did not move. (during limit too low) Check tape.");
                                Logger.WriteLogFile("Error: Tape half move.  Encoder wheel shows tape did not move. (during limit too low) Check tape.");
                                Logger.WriteInternalLogFile("Error: Tape half move.  Encoder wheel shows tape did not move. (during limit too low) Check tape.");
                                //return FAIL;
                                if (Properties.Settings.Default.TapeMidMoveCheckEnable == 1)
                                {

                                    Logger.WriteLogFile("TapeMidMoveCheckEnable = 1");

                                    return FAIL;
                                }
                                else
                                {
                                    f.UpdateMaintTapeMessage("Error:  check tape, pass");
                                    Logger.WriteLogFile("TapeMidMoveCheckEnable = 0");
                                    return PASS;
                                }

                            }

                            //else if(beforeLimitsUpper >6000)
                            //1.2.0.49 change before check from 6000 to 7000
                            else if (beforeLimitsUpper > 7000)  //Properties.Settings.Default.EncoderWheelLL) 
                            {
                                f.UpdateMaintTapeMessage("Pass");
                                //ERROR tape broken
                                Logger.WriteErrorFile("Error: Tape half move. Encoder wheel shows tape did not move. (before limit too hi) Check tape.");
                                Logger.WriteLogFile("Error: Tape half move.  Encoder wheel shows tape did not move.  (before limit too hi) Check tape.");
                                Logger.WriteInternalLogFile("Error: Tape half move.  Encoder wheel shows tape did not move.  (before limit too hi) Check tape.");
                                //                                return PASS;
                                if (Properties.Settings.Default.TapeMidMoveCheckEnable == 1)
                                {
                                    Logger.WriteLogFile("TapeMidMoveCheckEnable = 1");

                                    return FAIL;
                                }
                                else
                                {
                                    f.UpdateMaintTapeMessage("Error:  check tape, pass");
                                    Logger.WriteLogFile("TapeMidMoveCheckEnable = 0");
                                    return PASS;
                                }

                            }
                            //else if (afterLimitsUpper >6000)

                            else if(afterLimitsUpper > Properties.Settings.Default.EncoderWheelLL)
                            {
                                f.UpdateMaintTapeMessage("Error:  check tape");
                                //ERROR tape broken
                                Logger.WriteErrorFile("Error: Tape half move. Encoder wheel shows tape did not move. (after limit too high) Check tape.");
                                Logger.WriteLogFile("Error: Tape half move.  Encoder wheel shows tape did not move.  (after limit too high) Check tape.");
                                Logger.WriteInternalLogFile("Error: Tape half move.  Encoder wheel shows tape did not move.  (after limit too high) Check tape.");
                                //                                return FAIL;
                                if (Properties.Settings.Default.TapeMidMoveCheckEnable == 1)
                                {
                                    Logger.WriteLogFile("TapeMidMoveCheckEnable = 1");

                                    return FAIL;
                                }
                                else
                                {
                                    f.UpdateMaintTapeMessage("Error:  check tape, pass");
                                    Logger.WriteLogFile("TapeMidMoveCheckEnable = 0");
                                    return PASS;
                                }

                            }
                            else
                            {
                                f.UpdateMaintTapeMessage("Pass");
                                return PASS;
                            }

                        }
                        else if (upperLimit < 6000 && lowerLimit > 12000)  //ul was 1000
                        {
                            //mtbTapeControlStatus.Text = "Fail tape move. Nozzle Up";
                            f.UpdateMaintTapeMessage("Error.  Nozzle up");
                            Logger.WriteErrorFile("Error:  Advance tape half command, but Nozzle limits show UP!  Upper = " + upperLimit.ToString() + " Lower = " + lowerLimit.ToString());
                            Logger.WriteLogFile("Error:  Advance tape half command, but Nozzle limits show UP!  Upper = " + upperLimit.ToString() + " Lower = " + lowerLimit.ToString());
                            return FAIL_NOZZLE;
                        }
                        else
                        {
                            //mtbTapeControlStatus.Text = "Fail limits";
                            f.UpdateMaintTapeMessage("Error.  nozzle limits");
                            Logger.WriteLogFile("Tape move command,  INVALID nozzle limit switch return values.  Lower = " + lowerLimit.ToString() + " Upper = " + upperLimit.ToString());
                            return FAIL_NOZZLE;
                        }

                    }
                    else
                    {
                        //mtbTapeControlStatus.Text = "Fail limits";
                        f.UpdateMaintTapeMessage("Error.  unable to read nozzle limits");
                        Logger.WriteErrorFile("Tape move (full) Nozzle command, check limits function failed.");
                        Logger.WriteLogFile("Error:  Tape move (full) Nozzle command, check limits function failed.");
                        return FAIL_NOZZLE;

                    }

                }
                catch (Exception Ex)
                {
                    //mtbTapeControlStatus.Text = "Fail";
                    f.UpdateMaintTapeMessage("Error.  Move half failed");

                    Logger.WriteErrorFile("Error: in Tape Move (half) command.  Ex = " + Ex.ToString());
                    Logger.WriteLogFile("Error: in Tape Move (half) command.  Ex = " + Ex.ToString());
                    return FAIL;

                }
            }

            /// <summary>
            /// 
            /// </summary>
            /// <param name="SerialManager"></param>
            /// <returns></returns>
            public int NozzleUp(SerialIO SerialManager, Form1 f)
            {  //add vane up logic here:


                try
                {

                    AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                    f.UpdateNozzleMessage("Moving Nozzle Up");
                    Logger.WriteLogFile("*** Moving Nozzle Up ***");

                    int returnVal14 = AcquisitionControl.CheckEZ(SerialManager, "/1&\r");
                    if (returnVal14 == PASS)
                    {

                        int motor = 2;
                        int upperLimit = 0;
                        int lowerLimit = 0;
                        int movec = Properties.Settings.Default.NozzleMC;
                        int holdc = Properties.Settings.Default.NozzleHC;

                        f.UpdateNozzleMessage("Check nozzle limit switches");
                        Thread.Sleep(250);
                        int retVal = AcquisitionControl.CheckLimitsNZ(SerialManager, motor, out upperLimit, out lowerLimit);

                        if (retVal == PASS)
                        {

                            Logger.WriteLogFile("Nozzle Up, nozzle limits, before move(1):  UL = " + upperLimit.ToString() + " LL = " + lowerLimit.ToString());
                            if (upperLimit > 12000 && lowerLimit < 6000)   //ll was 1000
                            {
                                //processNozzleOutput("UL = OPEN   LL = CLOSED");

                                f.UpdateNozzleMessage("Move Nozzle Up");

                                SerialManager.WriteSerialPort("/1aM2m" + movec.ToString() + "h" + holdc.ToString() + "V2000n0M500z0D1000f1n2D15000R\r");
                //dn            SerialManager.WriteSerialPort("/1aM2m" + movec.ToString() + "h" + holdc.ToString() + "L2000V3000n0M500z0P1000f1n2P15000R\r");


                                //+800 NO.   SerialManager.WriteSerialPort("/1aM2m" + movec.ToString() + "h" + holdc.ToString() + "V2870n0M500z0D1000f1n2D15000R\r");
                                //double NO. SerialManager.WriteSerialPort("/1aM2m" + movec.ToString() + "h" + holdc.ToString() + "V4540n0M500z0D1000f1n2D15000R\r");
                                //SerialManager.WriteSerialPort("/1aM2m" + movec.ToString() + "h" + holdc.ToString() + "V2270n0M500z0D1000f1n2D15000R\r");
                                //Thread.Sleep(15000);
                                //f.UpdateNozzleMessage("Nozzle Up");
                                //return PASS;
                                Thread.Sleep(250);
                                int counter = 0;
                                do
                                {
                                    retVal = AcquisitionControl.CheckLimitsNZ(SerialManager, motor, out upperLimit, out lowerLimit);

                                    if (retVal == PASS)
                                    {
                                        Logger.WriteLogFile("Nozzle Up function, polling(1) limits:  UL = " + upperLimit.ToString() + " LL = " + lowerLimit.ToString());

                                        if (upperLimit < 6000 && lowerLimit > 12000)
                                        {
                                            Logger.WriteLogFile("Nozzle Up function(Break), UL<6000 UL = " + upperLimit.ToString() +" LL >12000 LL = "+ lowerLimit.ToString());
                                            break;
                                        }
                                    }
                                    Thread.Sleep(300);
                                    counter++;
                                } while (counter < 30);

                                if (upperLimit < 6000 && lowerLimit > 12000)
                                {
                                    f.UpdateNozzleMessage("Pass");
                                    f.UpdateNozzleMessage("Nozzle Up");
                                    Logger.WriteLogFile("*** Nozzle Up ***");
                                    return PASS;
                                }
                                else
                                {
                                    Logger.WriteLogFile("Error:  nozzle command Up, failed.  Nozzle LL = " + lowerLimit.ToString() + " Nozzle UL = " + upperLimit.ToString());
                                    f.UpdateNozzleMessage("Nozzle Up failed");
                                    return FAIL;

                                }



                            }
                            else if (upperLimit < 6000 && lowerLimit > 12000)  //ll was 1000
                            {

                                Logger.WriteLogFile("Nozzle command Up, Pass.  Nozzle LL = "+lowerLimit.ToString()+" Nozzle UL = "+upperLimit.ToString());
                                
                                f.UpdateNozzleMessage("Pass");
                                f.UpdateNozzleMessage("Nozzle Up");
                                Logger.WriteLogFile("*** Nozzle Up ***");

                                return PASS;
                            }
                            else
                            {
                                //the limits are both made up--i.e. the nozzle is in the middle, go ahead and execute the command.

                                //                            Logger.WriteLogFile(   "Nozzle command Up, INVALID limit switch return values.  Lower = " + lowerLimit.ToString() + " Upper = " + upperLimit.ToString());
                                //                            return FAIL;
                                f.UpdateNozzleMessage("Limits show middle.  Move Nozzle Up");
                                Logger.WriteLogFile("Nozzle command Up, but Nozzle limits show middle.  Nozzle UL= " + upperLimit.ToString() + " Nozzle LL = " + lowerLimit.ToString());


                                //SerialManager.WriteSerialPort("/1aM2m" + movec.ToString() + "h" + holdc.ToString() + "V2270n0M500z0D1000f1n2D15000R\r");
                                SerialManager.WriteSerialPort("/1aM2m" + movec.ToString() + "h" + holdc.ToString() + "V2000n0M500z0D1000f1n2D15000R\r");
                                Thread.Sleep(250);
                                f.UpdateNozzleMessage("Move Nozzle Up");

                                //return PASS;
                                int counter = 0;
                                do
                                {
                                    retVal = AcquisitionControl.CheckLimitsNZ(SerialManager, motor, out upperLimit, out lowerLimit);

                                    if (retVal == PASS)
                                    {
                                        Logger.WriteLogFile(" Nozzle Up, polling(2) nozzle limits:  UL = " + upperLimit.ToString() + " LL = " + lowerLimit.ToString());

                                        if (upperLimit < 6000 && lowerLimit >12000)
                                        {
                                            Logger.WriteLogFile("Nozzle Up function(Break), UL<6000 UL = " + upperLimit.ToString() + " LL >12000 LL = " + lowerLimit.ToString());
                                            break;
                                        }
                                    }
                                    Thread.Sleep(300);
                                    counter++;
                                } while (counter < 30);

                                if (upperLimit < 6000 && lowerLimit > 12000)
                                {
                                    Logger.WriteLogFile("Nozzle command Up, Pass.  Nozzle LL = " + lowerLimit.ToString() + " Nozzle UL = " + upperLimit.ToString());

                                    f.UpdateNozzleMessage("Pass");
                                    f.UpdateNozzleMessage("Nozzle Up");
                                    Logger.WriteLogFile("*** Nozzle Up ***");

                                    return PASS;
                                }
                                else
                                {
                                    Logger.WriteLogFile("Error: Nozzle Up failed.  Nozzle LL = " + lowerLimit.ToString() + " Nozzle UL = " + upperLimit.ToString());

                                    f.UpdateNozzleMessage("Nozzle Up failed");
                                    return FAIL;

                                }



                            }

                        }
                        else
                        {
                            Logger.WriteLogFile("Nozzle command Up, Checl nozzle limits failed.");  //  Nozzle LL = " + lowerLimit.ToString() + " Nozzle UL = " + upperLimit.ToString());

                            f.UpdateNozzleMessage("Error Nozzle Up, check limits function failed");
                            Logger.WriteInternalLogFile("Error Nozzle Up, check limits function failed.");
                            return FAIL;

                        }

                    }
                    else
                    {
                        f.UpdateNozzleMessage("Error Nozzle UP,  Check motor control board");
                        Logger.WriteInternalLogFile("Error Nozzle UP,  Check motor control board.");
                        return FAIL;
                    }

                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in Nozzle Up,  Ex = " + Ex.ToString());
                    f.UpdateNozzleMessage("Error in Nozzle Up,  See ErrorFile.txt");
                    return FAIL;

                }


            }
            public int GetDataSet()
            {
                //Logger.WriteLogFile("returning DataSet = " + dataSet.ToString(),"c:/temp/tapePressureRaw.txt");
                return dataSet;
            }
            public void SetDataSet(int newDataSet)
            {
                //Logger.WriteLogFile("Setting dataSet to:  " + newDataSet.ToString(), "c:/temp/tapePressureRaw.txt");

                dataSet = newDataSet;
            }




            /// <summary>
            /// 
            /// </summary>
            /// <param name="SerialManager"></param>
            /// <returns></returns>
            public int NozzleDown(SerialIO SerialManager, Form1 f)
            {

                try
                {
                    AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                    //f.UpdateNozzleMessage()
                    f.UpdateNozzleMessage("Moving Nozzle Down");
                    Logger.WriteLogFile("*** Moving Nozzle Down ***");

                    int returnVal14 = AcquisitionControl.CheckEZ(SerialManager, "/1&\r");
                    if (returnVal14 == PASS)
                    {

                        int motor = 2;
                        int upperLimit = 0;
                        int lowerLimit = 0;

                        int movec = Properties.Settings.Default.NozzleMC;
                        int holdc = Properties.Settings.Default.NozzleHC;

                        f.UpdateNozzleMessage("Check nozzle limit switches");
                        Thread.Sleep(250);
                        int retVal = AcquisitionControl.CheckLimitsNZ(SerialManager, motor, out upperLimit, out lowerLimit);

                        if (retVal == PASS)
                        {
                            Logger.WriteLogFile("Nozzle Dn, Nozzle limits before move(1):  UL = " + upperLimit.ToString() + " LL = " + lowerLimit.ToString());

                            if (upperLimit < 6000 && lowerLimit > 12000)  //ul was 1000
                            {
                                //Logger.WriteLogFile("Move nozzle down:  UL = " + upperLimit.ToString() + " LL = " + lowerLimit.ToString());
                                f.UpdateNozzleMessage("Move Nozzle Down");
                                //SerialManager.WriteSerialPort("/1aM2m" + movec.ToString() + "h" + holdc.ToString() + "V2270n0M500z0P1000f1n2P15000R\r");
                                SerialManager.WriteSerialPort("/1aM2m" + movec.ToString() + "h" + holdc.ToString() + "V2000n0M500z0P1000f1n2P15000R\r");   //move L from 1000 to 10 per April 10 2020 email 
                                //int returnVal15 = AcquisitionControl.NozzleDown(SerialManager);
                                Thread.Sleep(250);


                                int counter = 0;
                                do
                                {
                                    retVal = AcquisitionControl.CheckLimitsNZ(SerialManager, motor, out upperLimit, out lowerLimit);
                                    Logger.WriteLogFile(retVal.ToString() + " Nozzle Dn, polling(1) nozzle limits:  UL = " + upperLimit.ToString() + " LL = " + lowerLimit.ToString());

                                    if (retVal == PASS)
                                    {
                                        if (upperLimit > 12000 && lowerLimit < 6000)
                                        {
                                            Logger.WriteLogFile("Nozzle Dn function(Break), UL>12000  " + upperLimit.ToString() + " LL <6000 LL = " + lowerLimit.ToString());
                                            break;
                                        }
                                    }
                                    Thread.Sleep(300);
                                    counter++;
                                } while (counter < 30);

                                if (upperLimit > 12000 && lowerLimit < 6000)
                                {
                                    Logger.WriteLogFile("Nozzle command Down Pass.  Nozzle LL = " + lowerLimit.ToString() + " Nozzle UL = " + upperLimit.ToString());
                                    f.UpdateNozzleMessage("Pass");
                                    f.UpdateNozzleMessage("Nozzle Down");
                                    Logger.WriteLogFile("*** Nozzle Down ***");

                                    return PASS;
                                }
                                else
                                {
                                    Logger.WriteLogFile("Error:  Nozzle command Down.  Nozzle LL = " + lowerLimit.ToString() + " Nozzle UL = " + upperLimit.ToString());
                                    f.UpdateNozzleMessage("Nozzle Down failed");
                                    return FAIL;

                                }
                            }
                            else if (upperLimit > 12000 && lowerLimit < 6000)  //ll was 1000
                            {
                                f.UpdateNozzleMessage("Nozzle already down");

                                //Logger.WriteLogFile("Nozzle command Dn, but Nozzle already Dn.");
                                Logger.WriteLogFile("Nozzle command Dn, Nozzle already Dn.  Nozzle LL = " + lowerLimit.ToString() + " Nozzle UL = " + upperLimit.ToString());

                                f.UpdateNozzleMessage("Pass");
                                f.UpdateNozzleMessage("Nozzle Down");
                                return PASS;
                            }
                            else
                            {
                                f.UpdateNozzleMessage("Limits show middle.  Move Nozzle Down");
                                Logger.WriteLogFile("Nozzle command Dn, Nozzle limits show middle. " + "UL = " + upperLimit.ToString() + " LL = " + lowerLimit.ToString());
                                //SerialManager.WriteSerialPort("/1aM2m" + movec.ToString() + "h" + holdc.ToString() + "V2270n0M500z0P1000f1n2P15000R\r");
                                SerialManager.WriteSerialPort("/1aM2m" + movec.ToString() + "h" + holdc.ToString() + "V2000n0M500z0P1000f1n2P15000R\r");
                                //int returnVal15 = AcquisitionControl.NozzleDown(SerialManager);
                                Thread.Sleep(250);

                                int counter = 0;
                                do
                                {
                                    retVal = AcquisitionControl.CheckLimitsNZ(SerialManager, motor, out upperLimit, out lowerLimit);
                                    Logger.WriteLogFile(retVal.ToString()+" Nozzle Dn function, polling(2): nozzle limits  UL = " + upperLimit.ToString() + " LL = " + lowerLimit.ToString());
                               
                                    if (retVal == PASS)
                                    {
                                        if (upperLimit > 12000 && lowerLimit < 6000)
                                        {
                                            Logger.WriteLogFile("Nozzle Dn function(Break), UL>12000 UL = " + upperLimit.ToString() + " LL <6000 LL = " + lowerLimit.ToString());
                                            break;
                                        }
                                    }
                                    Thread.Sleep(300);
                                    counter++;
                                } while (counter < 30);


                                if (upperLimit > 12000 && lowerLimit < 6000)
                                {
                                    Logger.WriteLogFile("Nozzle command Down: Pass,  Nozzle LL = " + lowerLimit.ToString() + " Nozzle UL = " + upperLimit.ToString());

                                    f.UpdateNozzleMessage("Pass");
                                    f.UpdateNozzleMessage("Nozzle Down");
                                    Logger.WriteLogFile("*** Nozzle Down ***");

                                    return PASS;
                                }
                                else
                                {
                                    Logger.WriteLogFile("Error: Nozzle command Dn, Nozzle LL = " + lowerLimit.ToString() + " Nozzle UL = " + upperLimit.ToString());

                                    f.UpdateNozzleMessage("Nozzle Down failed");
                                    return FAIL;

                                }
                                //go ahead and execute the command:  the nozzle is likely between the limits.

                                //                            Logger.WriteLogFile(   "Nozzle command Dn, INVALID limit switch return values.  Lower = " + lowerLimit.ToString() + " Upper = " + upperLimit.ToString());
                                //                            return FAIL;
                            }

                        }
                        else
                        {
                            f.UpdateNozzleMessage("Unable to read Nozzle Limit Switches");
                            Logger.WriteInternalLogFile("Error Nozzle Dn.  Check limits failed.");
                            return FAIL;

                        }

                    }
                    else
                    {
                        f.UpdateNozzleMessage("Error Nozzle Down.  Check motor control board.");
                        Logger.WriteInternalLogFile("Error in Move Nozzle Down. Check motor control board.");
                        return FAIL;
                    }

                }
                catch (Exception Ex)
                {
                    f.UpdateNozzleMessage("Error Move Nozzle Down");
                    Logger.WriteInternalLogFile("Error in Vane Dn command. Ex = " + Ex.ToString());
                    return FAIL;

                }



            }
            // check limits tape


            public int CheckLimitsTape(SerialIO SerialManager, int motor, out int upperLimit, out int lowerLimit)
            {
                //tape is 3

                string requestLimits;
                upperLimit = 0;
                lowerLimit = 0;
                Logger.WriteInternalLogFile("checking limits for motor =  " + motor.ToString());
                requestLimits = "/1?aa" + motor.ToString() + "\r";
                Logger.WriteInternalLogFile("check limits command string = " + requestLimits);

                int returnValue;
                int DRcounter = 0;
                do
                {
                    returnValue = FAIL;
                    DRcounter += 1;
                    try
                    {
                        Logger.WriteInternalLogFile("serial response string (before clear)= " + SerialManager.GetResponseString());
                        SerialManager.ClearSerialResponseString();
                        Logger.WriteInternalLogFile("serial response string (after clear)= " + SerialManager.GetResponseString());
                        SerialManager.WriteSerialPort(requestLimits);
                        //}
                        //catch (Exception Ex)
                        //{
                        //    Logger.WriteErrorFile("Error sending request for limit switches for motor " + motor.ToString() + " Ex = " + Ex.ToString());
                        //    //return FAIL;
                        //    returnValue = FAIL;
                        //}
                        Logger.WriteInternalLogFile("wait for limits response.... ");

                        Thread.Sleep(500);
                        Logger.WriteInternalLogFile("done wait.");


                        string response = SerialManager.GetResponseString();

                        Logger.WriteInternalLogFile("response from ez4axis = " + response);

                        string output1 = "";
                        string output2 = "";
                        int retVal = FAIL;
                        retVal = CleanResponse(response, out output1, out output2);
                        if (retVal == PASS)
                        {
                            bool conv1, conv2;
                            conv1 = false;
                            conv2 = false;
                            try
                            {
                                upperLimit = Convert.ToInt32(output2);
                                conv2 = true;
                            }
                            catch (Exception Ex)
                            {
                                Logger.WriteInternalLogFile("Error convert value to int.  Value = " + output2 + " Ex = " + Ex.ToString());
                                conv2 = false;
                            }
                            try
                            {

                                lowerLimit = Convert.ToInt32(output1);
                                conv1 = true;
                            }
                            catch (Exception Ex)
                            {
                                Logger.WriteInternalLogFile("Error convert value to int.  Value = " + output1 + " Ex = " + Ex.ToString());
                                conv2 = false;
                            }
                            if (conv1 == true && conv2 == true)
                            {
                                returnValue = PASS;
                            }
                            else
                            {
                                returnValue = FAIL;
                            }

                        }
                        else
                        {
                            upperLimit = 0;
                            lowerLimit = 0;
                            returnValue = FAIL;
                        }



                    }
                    catch (Exception Ex)
                    {
                        Logger.WriteInternalLogFile("Error in request limits " + motor.ToString() + " Ex = " + Ex.ToString());
                        returnValue = FAIL;
                    }
                    Logger.WriteInternalLogFile("tape counter = " + DRcounter.ToString());
                } while (returnValue == FAIL && DRcounter <= 3);
                if (returnValue == PASS)
                {
                    return PASS;
                }
                else
                {
                    return FAIL;
                }

            }







            //end check limits tape
            public int CheckLimitsDR(SerialIO SerialManager, int motor, out int upperLimit, out int lowerLimit)
            {
                //dr is 4

                string requestLimits;
                upperLimit = 0;
                lowerLimit = 0;
                Logger.WriteInternalLogFile("checking limits for motor =  " + motor.ToString());
                requestLimits = "/1?aa" + motor.ToString() + "\r";
                Logger.WriteInternalLogFile("check limits command string = " + requestLimits);

                int returnValue;
                int DRcounter = 0;
                do
                {
                    returnValue = FAIL;
                    DRcounter += 1;
                    try
                    {
                        Logger.WriteInternalLogFile("serial response string (before clear)= " + SerialManager.GetResponseString());
                        SerialManager.ClearSerialResponseString();
                        Logger.WriteInternalLogFile("serial response string (after clear)= " + SerialManager.GetResponseString());
                        SerialManager.WriteSerialPort(requestLimits);
                        //}
                        //catch (Exception Ex)
                        //{
                        //    Logger.WriteErrorFile("Error sending request for limit switches for motor " + motor.ToString() + " Ex = " + Ex.ToString());
                        //    //return FAIL;
                        //    returnValue = FAIL;
                        //}
                        Logger.WriteInternalLogFile("wait for limits response.... ");

                        Thread.Sleep(500);
                        Logger.WriteInternalLogFile("done wait.");


                        string response = SerialManager.GetResponseString();

                        Logger.WriteInternalLogFile("response from ez4axis = " + response);

                        string output1 = "";
                        string output2 = "";
                        int retVal = FAIL;
                        retVal = CleanResponse(response, out output1, out output2);
                        if (retVal == PASS)
                        {
                            bool conv1, conv2;
                            conv1 = false;
                            conv2 = false;
                            try
                            {
                                upperLimit = Convert.ToInt32(output2);
                                conv2 = true;
                            }
                            catch (Exception Ex)
                            {
                                Logger.WriteInternalLogFile("Error convert value to int.  Value = " + output2 + " Ex = " + Ex.ToString());
                                conv2 = false;
                            }
                            try
                            {

                                lowerLimit = Convert.ToInt32(output1);
                                conv1 = true;
                            }
                            catch (Exception Ex)
                            {
                                Logger.WriteInternalLogFile("Error convert value to int.  Value = " + output1 + " Ex = " + Ex.ToString());
                                conv2 = false;
                            }
                            if (conv1 == true && conv2 == true)
                            {
                                returnValue = PASS;
                            }
                            else
                            {
                                returnValue = FAIL;
                            }

                        }
                        else
                        {
                            upperLimit = 0;
                            lowerLimit = 0;
                            returnValue = FAIL;
                        }



                    }
                    catch (Exception Ex)
                    {
                        Logger.WriteInternalLogFile("Error in request limits " + motor.ToString() + " Ex = " + Ex.ToString());
                        returnValue = FAIL;
                    }
                    Logger.WriteInternalLogFile("DRcounter = " + DRcounter.ToString());
                } while (returnValue == FAIL && DRcounter <= 3);
                if (returnValue == PASS)
                {
                    return PASS;
                }
                else
                {
                    return FAIL;
                }

            }


            public int CheckLimitsNZ(SerialIO SerialManager, int motor, out int upperLimit, out int lowerLimit)
            {
                //NZ is 3

                string requestLimits;
                upperLimit = 0;
                lowerLimit = 0;
                Logger.WriteInternalLogFile("NZ checking limits for motor =  " + motor.ToString());
                requestLimits = "/1?aa" + motor.ToString() + "\r";
                Logger.WriteInternalLogFile("NZ check limits command string = " + requestLimits);

                int returnValue;
                int NZcounter = 0;
                do
                {
                    returnValue = FAIL;
                    NZcounter += 1;
                    try
                    {


                        Logger.WriteInternalLogFile("serial response string (before clear)= " + SerialManager.GetResponseString());
                        SerialManager.ClearSerialResponseString();
                        Logger.WriteInternalLogFile("serial response string (after clear)= " + SerialManager.GetResponseString());

                        SerialManager.responseVariable = 0;
                        SerialManager.WriteSerialPort(requestLimits);
  
                        Logger.WriteInternalLogFile("get limits response.... ");
                       
                        int sretVal = WaitForSerialResponse(SerialManager);

                        if (sretVal == 1)
                        {
                            string response = SerialManager.GetResponseString();
                            Logger.WriteInternalLogFile("response from ez4axis = " + response);

                            string output1 = "";
                            string output2 = "";
                            int retVal = FAIL;
                            retVal = CleanResponse(response, out output1, out output2);
                            if (retVal == PASS)
                            {
                                bool conv1, conv2;
                                conv1 = false;
                                conv2 = false;
                                try
                                {
                                    upperLimit = Convert.ToInt32(output2);
                                    conv2 = true;
                                }
                                catch (Exception Ex)
                                {
                                    Logger.WriteInternalLogFile("Error convert value to int.  Value = " + output2 + " Ex = " + Ex.ToString());
                                    conv2 = false;
                                }
                                try
                                {

                                    lowerLimit = Convert.ToInt32(output1);
                                    conv1 = true;
                                }
                                catch (Exception Ex)
                                {
                                    Logger.WriteInternalLogFile("Error convert value to int.  Value = " + output1 + " Ex = " + Ex.ToString());
                                    conv2 = false;
                                }
                                if (conv1 == true && conv2 == true)
                                {
                                    returnValue = PASS;
                                }
                                else
                                {
                                    returnValue = FAIL;
                                }

                            }
                            else
                            {
                                upperLimit = 0;
                                lowerLimit = 0;
                                returnValue = FAIL;
                            }

                        }
                        else
                        {
                            Logger.WriteInternalLogFile("Serial Response timeout.");
                        }



                    }
                    catch (Exception Ex)
                    {
                        Logger.WriteInternalLogFile("Error in request limits " + motor.ToString() + " Ex = " + Ex.ToString());
                        returnValue = FAIL;
                    }
                    Logger.WriteInternalLogFile("NZcounter = " + NZcounter.ToString());
                } while (returnValue == FAIL && NZcounter <= 3);
                if (returnValue == PASS)
                {
                    return PASS;
                }
                else
                {
                    return FAIL;
                }

            }

            public int WaitForSerialResponse(SerialIO SerialManager)
            {
                int counter = 0;
                do
                {
                    counter++;
                    Thread.Sleep(100);
                    
                } while (SerialManager.responseVariable == 0 && counter<50);
                if(counter<50)
                {
                    return 1;

                }
                else
                {
                    return 0;
                }


            }


            public int CheckLimitsFW(SerialIO SerialManager, int motor, out int upperLimit, out int lowerLimit)
            {
                //fw is motor 1

                string requestLimits;
                upperLimit = 0;
                lowerLimit = 0;
                Logger.WriteInternalLogFile("FW checking limits for motor =  " + motor.ToString());
                requestLimits = "/1?aa" + motor.ToString() + "\r";
                Logger.WriteInternalLogFile("FW check limits command string = " + requestLimits);

                int returnValue;
                int FWcounter = 0;
                do
                {
                    returnValue = FAIL;
                    FWcounter += 1;
                    try
                    {
                        //Logger.WriteInternalLogFile("FW serial response string (before clear)= " + SerialManager.GetResponseString());
                        SerialManager.ClearSerialResponseString();
                        SerialManager.responseVariable = 0;
                        Logger.WriteInternalLogFile("FW serial response string (after clear)= " + SerialManager.GetResponseString());
                        SerialManager.WriteSerialPort(requestLimits);
                        //}
                        //catch (Exception Ex)
                        //{
                        //    Logger.WriteErrorFile("Error sending request for limit switches for motor " + motor.ToString() + " Ex = " + Ex.ToString());
                        //    //return FAIL;
                        //    returnValue = FAIL;
                        //}
                        Logger.WriteInternalLogFile("wait for limits response.... ");

                        //Thread.Sleep(500);
                        //Logger.WriteInternalLogFile("done wait.");
                        int counter = 0;
                        do
                        {
                            Thread.Sleep(250);
                            //Logger.WriteInternalLogFile("done wait.");
                            if (SerialManager.responseVariable == 1)
                            {
                                break;
                            }
                            counter++;
                        } while (counter < 30);





                        string response = SerialManager.GetResponseString();
                        Logger.WriteInternalLogFile("response from ez4axis = " + response);


                        string output1 = "";
                        string output2 = "";
                        int retVal = FAIL;
                        retVal = CleanResponse(response, out output1, out output2);
                        if (retVal ==PASS)
                        {
                            bool conv1, conv2;
                            conv1 = false;
                            conv2 = false;
                            try
                            {
                                upperLimit = Convert.ToInt32(output2);
                                conv2 = true;
                            }
                            catch (Exception Ex)
                            {
                                Logger.WriteInternalLogFile("Error convert value to int.  Value = " + output2 + " Ex = " + Ex.ToString());
                                conv2 = false;
                            }
                            try
                            {

                                lowerLimit = Convert.ToInt32(output1);
                                conv1 = true;
                            }
                            catch(Exception Ex)
                            {
                                Logger.WriteInternalLogFile("Error: in convert value to int.  Value = " + output1 + " Ex = " + Ex.ToString());
                                conv2 = false;
                            }
                            if (conv1 == true && conv2 == true)
                            {
                                returnValue = PASS;
                            }
                            else
                            {
                                returnValue = FAIL;
                            }

                        }
                        else
                        {
                            upperLimit = 0;
                            lowerLimit = 0;
                            returnValue = FAIL;
                        }



                    }
                    catch (Exception Ex)
                    {
                        Logger.WriteInternalLogFile("Error in request limits " + motor.ToString() + " Ex = " + Ex.ToString());
                        returnValue = FAIL;
                    }
                    Logger.WriteInternalLogFile("FW counter = " + FWcounter.ToString());
                } while (returnValue == FAIL && FWcounter <= 3);

                if (returnValue == PASS)
                {
                    return PASS;
                }
                else
                {
                    return FAIL;
                }

            }


            int CleanResponse(string input, out string output1, out string output2) 
            {
                string[] responseValue = new string[2];
                string[] temp = Regex.Split(input, ",");



                output1 = string.Empty;
                output2 = string.Empty;
                string resultString1 = null;
                string resultString2 = null;

                try
                {
                    Regex regexObj = new Regex(@"[^\d]");
                    resultString1 = regexObj.Replace(temp[0], "");
                }
                catch (ArgumentException Ex)
                {
                    
                    Logger.WriteInternalLogFile("Invalid parse of input string 1 = " + temp[0]);
                    Logger.WriteInternalLogFile("Error:  " + Ex.ToString());
                    return FAIL;
                }
                try
                {
                    Regex regexObj = new Regex(@"[^\d]");
                    resultString2 = regexObj.Replace(temp[1], "");
                    
                }
                catch (ArgumentException Ex)
                {
                    Logger.WriteInternalLogFile("Invalid parse of input string 2 = " + temp[1]);
                    Logger.WriteInternalLogFile("Error:  " + Ex.ToString());
                    // Syntax error in the regular expression
                    return FAIL;
                }

                output1 = resultString1;
                output2 = resultString2;
                return PASS;


            }


            public int CheckHomeSensor(SerialIO SerialManager, int motor, out int upperLimit, out int lowerLimit)
            {

                string requestLimits;
                upperLimit = 0;
                lowerLimit = 0;

                requestLimits = "/1aM" + motor.ToString() + "M500?aa" + motor.ToString() + "\r";

                try
                {
                    //"/1aM1M500?aa1\r"
                    SerialManager.WriteSerialPort(requestLimits);
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error sending request for limit switches for motor " + motor.ToString() + " Ex = " + Ex.ToString());
                    return FAIL;
                }
                Thread.Sleep(2750);
                string response = SerialManager.GetResponseString();
                string cleanedResponse1;
                string cleanedResponse2;
                string cleanedResponse3;
                string cleanedResponse4;
                string cleanedResponse5;
                try
                {

                    //cleanedResponse1 = Regex.Replace(response, "?/0", "");
                    cleanedResponse1 = response.Replace("?", "");
                    cleanedResponse2 = cleanedResponse1.Replace("/0", "");
                    cleanedResponse3 = cleanedResponse2.Replace("\u0003", "");
                    cleanedResponse4 = cleanedResponse3.Replace("\r\n", "");
                    cleanedResponse5 = cleanedResponse4.Replace("`", "");
                    string[] Linputs = Regex.Split(cleanedResponse5, ",");

                    int numValueLimitUpper;
                    int numValueLimitLower;
                    bool parsedUpper = Int32.TryParse(Linputs[0], out numValueLimitUpper);

                    if (!parsedUpper)
                    {
                        Logger.WriteInternalLogFile("Int32.TryParse could not parse " + Linputs[0].ToString() + "  to an int.");
                    }

                    bool parsedLower = Int32.TryParse(Linputs[1], out numValueLimitLower);

                    if (!parsedLower)
                    {
                        Logger.WriteInternalLogFile("Int32.TryParse could not parse " + Linputs[1].ToString() + "  to an int.");
                    }
                    if (parsedUpper == true)
                    {
                        upperLimit = numValueLimitLower;
                    }
                    else
                    {
                        upperLimit = 0;
                    }

                    if (parsedLower == true)
                    {
                        lowerLimit = numValueLimitUpper;
                    }
                    else
                    {
                        lowerLimit = 0;
                    }

                    if (parsedUpper == true && parsedLower == true)
                    {
                        return PASS;
                    }
                    else
                    {
                        return FAIL;
                    }

                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in request motor " + motor.ToString() + " Ex = " + Ex.ToString());
                    return FAIL;
                }
            }



            public int ZeroMotorPosition(SerialIO SerialManager, int motor)
            {
                string selectMotor;
                selectMotor = "/1aM" + motor.ToString() + "RM500\r";
                try
                {
                    SerialManager.WriteSerialPort(selectMotor);
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in sending motor select motor in zero motor position. " + motor.ToString() + " status:  " + Ex.ToString());

                    return FAIL;
                }

                string zeroPosition = "/1z0R" + "\r";

                try
                {
                    //"/1aM1M500?0\r"
                    SerialManager.WriteSerialPort(zeroPosition);
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in sending request to zero position for motor " + motor.ToString() + " Ex = " + Ex.ToString());

                    return FAIL;
                }
                Thread.Sleep(100);  
                return PASS;

            }


            public int CheckMotorPosition(SerialIO SerialManager, int motor, out int position)
            {
                //motor 1 = __fw__, motor 2=__nozzle__, motor 3 = __tape advance__, motor 4 = __DR__ 
                string selectMotor;
                string requestPosition;
                //upperLimit = 0;
                //lowerLimit = 0;
                Logger.WriteLogFile(   "*** reading motor " + motor.ToString() + " (1=FW, 2=NZ, 3=TA, 4=DR)");
                selectMotor = "/1aM" + motor.ToString() + "RM750\r";
                try
                {
                    SerialManager.WriteSerialPort(selectMotor);
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in sending motor select for motor = " + motor.ToString() + " status:  " + Ex.ToString());
                    position = 0;
                    return FAIL;
                }
                Thread.Sleep(100);  



                requestPosition = "/1?0" + "\r";
                int retry = 0;
                do
                {
                    try
                    {
                        retry++;
                        //"/1aM1M500?0\r"
                        SerialManager.responseVariable = 0;
                        SerialManager.WriteSerialPort(requestPosition);
                        
                    }
                    catch (Exception Ex)
                    {
                        Logger.WriteInternalLogFile("Error in sending request for position for motor " + motor.ToString() + " status:  " + Ex.ToString());
                        position = 0;
                        return FAIL;
                    }
                    
                    int counter = 0;
                    do
                    {
                        Thread.Sleep(100);
                        counter++;
                    } while (SerialManager.responseVariable == 0 && counter < 30);  //counter 7
                    if(SerialManager.responseVariable==1)
                    {
                        break;
                    }

                } while (retry <= 3);

                string response = SerialManager.GetResponseString();
                string cleanedResponse1;
                string cleanedResponse2;
                string cleanedResponse3;
                string cleanedResponse4;
                string cleanedResponse5;
                string cleanedResponse6;
                string cleanedResponse7;
                try
                {

                    //cleanedResponse1 = Regex.Replace(response, "?/0", "");
                    cleanedResponse1 = response.Replace("?", "");
                    cleanedResponse2 = cleanedResponse1.Replace("/0", "");
                    cleanedResponse3 = cleanedResponse2.Replace("\u0003", "");
                    cleanedResponse4 = cleanedResponse3.Replace("\r\n", "");
                    cleanedResponse5 = cleanedResponse4.Replace("`", "");
                    cleanedResponse6 = cleanedResponse5.Replace("a", "");
                    cleanedResponse7 = cleanedResponse6.Replace("@", "");
                    //string[] Linputs = Regex.Split(cleanedResponse5, ",");

                    //int numValueLimitUpper;
                    int positionValue;
                    bool parsedPosition = Int32.TryParse(cleanedResponse7, out positionValue);

                    if (parsedPosition == false)
                    {
                        Logger.WriteInternalLogFile("Error:  Int32.TryParse could not parse " + cleanedResponse7 + "  to an int.");
                        position = 0;
                        return FAIL;
                    }
                    else
                    {
                        Logger.WriteLogFile(   "reading motor " + motor.ToString() + " (1=FW, 2=NZ, 3=TA, 4=DR) POS = "+positionValue.ToString());

                        position = positionValue;
                        return PASS;
                    }

                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Exception in request motor " + motor.ToString() + " position, Ex = " + Ex.ToString());
                    position = 0;
                    return FAIL;
                }

            }



            /// <summary>
            /// 
            /// </summary>
            /// <param name="SerialManager"></param>
            /// <returns></returns>
            public int CheckEZ(SerialIO SerialManager, string checkString)
            {
                int retryCount = 0;
                do
                {

                    try
                    {

                        SerialManager.responseVariable = 0;
                        SerialManager.WriteSerialPort(checkString);

                        //Thread.Sleep(500);
                        //query limits and motor pos instead of sleep
                        int counter = 0;
                        do
                        {
                            Thread.Sleep(100);
                            counter++;
                        } while (SerialManager.responseVariable == 0 && counter < 50);
                        
                        string retString = SerialManager.returnValue;

                        Logger.WriteInternalLogFile("check ez4axis board return string = " + retString);

                        if (  (retString.Contains("EZController") && retString.Contains("AllMotion")) || ((retString.Contains("50h6") || retString.Contains("5-18-13"))  ))
                        {
                            Logger.WriteLogFile(   "EZ4Axis board responding OK");
                            break;
                        }
                        else
                        {
                            SerialManager.WriteSerialPort("/1T\r");
                            Thread.Sleep(500);
                            retryCount += 1;
                        }


                    }
                    catch (Exception Ex)
                    {
                        Logger.WriteInternalLogFile(Ex.ToString());
                        //return FAIL;
                    }

                } while (retryCount < 3);
                if (retryCount < 3)
                    return PASS;
                else
                    return FAIL;


            }




            public List<string> ReadFile(string pathFilename)
            {

                string[] lines;
                var list = new List<string>();
                var fileStream = new FileStream(@"c:\file.txt", FileMode.Open, FileAccess.Read);
                using (var streamReader = new StreamReader(fileStream, Encoding.UTF8))
                {
                    string line;
                    while ((line = streamReader.ReadLine()) != null)
                    {
                        list.Add(line);
                    }
                }
                lines = list.ToArray();
                return list;
            }



            ///
            ///
            //serial control lines functions
            public int SetControlLines(SerialControlLinesIO SerialControlLinesManager, bool controlLine7, bool controlLine4)
            {
                try
                {
                    if (controlLine7 == true)
                    {
                        SerialControlLinesManager.SetOutputPin7();
                    }
                    else //if(controlLine7 ==false)
                    {
                        SerialControlLinesManager.ClrOutputPin7();
                    }
                    if (controlLine4 == true)
                    {
                        SerialControlLinesManager.SetOutputPin4();
                    }
                    else //if(controlLine7 ==false)
                    {
                        SerialControlLinesManager.ClrOutputPin4();
                    }
                    return PASS;
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in Set Control Lines.  Ex = " + Ex.ToString());
                    return FAIL;
                }



            }
            public int GetControlLines(SerialControlLinesIO SerialControlLinesManager, out bool controlLine7, out bool controlLine4)
            {
                
                try
                {
                    bool get7 = false;
                    get7 = SerialControlLinesManager.GetOutputPin7();
                    controlLine7 = get7;

                    bool get4 = false;
                    get4 = SerialControlLinesManager.GetOutputPin4();
                    controlLine4 = get4;
                    return PASS;
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in GetControl Lines.  Ex = " + Ex.ToString());
                    controlLine4 = false;
                    controlLine7 = false;
                    return FAIL;
                }



            }
            // *******************************************************************************************************

            //wind speed and direction functions:
            /// <summary>
            /// 
            /// </summary>
            /// <param name="SerialManager"></param>
            /// <returns></returns>
            public int GetWindSpeedandDirection(SerialWindSpeedandDirIO serialManager /*, out int position*/ /*, Form1 form1*/, out string windSpeed, out string windDirection)
            {
                //return FAIL or PASS;
                windSpeed = "None";
                windDirection = "None";
                if (windSpeedAndDirResponseCounter == 0)
                {
                    serialManager.ClrResponseString(); //clear the response


                    string requestString = "?\nT\n";  //make the request
                    try
                    {
                        //Logger.WriteLogFile("c:/temp/WindSpeed.txt", "Sending request string:  " + requestString);
                        serialManager.WriteSerialPort(requestString);
                    }
                    catch (Exception Ex)
                    {
                        Logger.WriteInternalLogFile("Error in sending wind speed and direction request: Ex = " + Ex.ToString());
                        //Logger.WriteLogFile("c:/temp/WindSpeed.txt", "Exception sending request.  Ex = " + Ex.ToString());
                        return FAIL;
                    }
                    //windSpeedAndDirResponseCounter++;
                    allowWindSpeedAndDirResponseCounter = 1;
                }
                if(allowWindSpeedAndDirResponseCounter==1)
                {
                    windSpeedAndDirResponseCounter++;
                }




                if (windSpeedAndDirResponseCounter >= 2)
                {
                    allowWindSpeedAndDirResponseCounter = 0;
                    //check for complete response sent?
                    string response = serialManager.GetResponseString(); //get the total response
                    if (response.Length == 0)
                    {
                        windSpeed = "None";
                        windDirection = "None";
                        return FAIL;
                    }
                    else if(response.Contains("T"))
                    { 

                        if (response.Length > 4)
                        {
                            try
                            {
                                //process response
                                //Logger.WriteInternalLogFile("RAW WINDSPEED RESPONSE = " + response);
                                //write raw data to lists
                                string[] splitLine = response.Split(',');
                                try
                                {
                                    if (splitLine[2] != "" && splitLine[1] != "")
                                    {
                                        //todo:  only valid to collect data if RUN is clicked.

                                        if (runState == 1)
                                        {
                                            SetWindSpeed(double.Parse(splitLine[2]));

                                            SetWindDirection(double.Parse(splitLine[1]));
                                            //
                                        }

                                        windSpeed = splitLine[2];
                                        windDirection = splitLine[1];

                                    }
                                    else
                                    {
                                        if (runState == 1)
                                        {
                                            SetWindSpeed(0.0);
                                            SetWindDirection(0.0);
                                        }
                                        //windSpeed = splitLine[2];
                                        //windDirection = splitLine[1];
                                        windSpeed = "None";
                                        windDirection = "None";
                                        allowWindSpeedAndDirResponseCounter = 0;
                                        windSpeedAndDirResponseCounter = 0;

                                    }
                                }
                                catch (Exception Ex)
                                {
                                    //Logger.WriteLogFile("c:/temp/WindSpeed.txt", "Exception in parsing response.  Ex = " + Ex.ToString());
                                    Logger.WriteInternalLogFile("Exception in wind speed function:  Ex = " + Ex.ToString());
                                    if (runState == 1)
                                    {
                                        SetWindSpeed(0.0);
                                        SetWindDirection(0.0);
                                    }
                                    windSpeed = "None";
                                    windDirection = "None";

                                    allowWindSpeedAndDirResponseCounter = 0;
                                    windSpeedAndDirResponseCounter = 0;
                                    return FAIL;
                                }
                            }

                            catch (Exception Ex)
                            {
                                Logger.WriteInternalLogFile("Error in process wind speed and direction response.  Ex = " + Ex.ToString());
                                windSpeed = "None";
                                windDirection = "None";

                                allowWindSpeedAndDirResponseCounter = 0;
                                windSpeedAndDirResponseCounter = 0;


                                return FAIL;
                            }
                        }
                        else
                        {
                            //Logger.WriteInternalLogFile("" + Ex.ToString());
                            if (runState == 1)
                            {
                                SetWindSpeed(0.0);
                                SetWindDirection(0.0);
                            }
                            windSpeed = "None";
                            windDirection = "None";

                            allowWindSpeedAndDirResponseCounter = 0;
                            windSpeedAndDirResponseCounter = 0;
                            return FAIL;
                        }
                    }

                    else
                    {
                            windSpeed = "bad";
                            windDirection = "setup";

                            return FAIL;

                    }

                }


                return PASS;
            }


            /// <summary>
            /// 
            /// </summary>
            public void ProcessWindSpeedandDirectionData()
            {
                //perform avgs

                //perform the coordinate translations

                //return avgs for saving to sqlite and to modbus and to process data file
            }








        }
        // *** end of acqusition class



        private void mbEnableDisableChanges_Click(object sender, EventArgs e)
        {
            //enable / disable changes
            if (mbEnableDisableChanges.Text.Contains("Enable"))
            {
                    if (mbRun.Text == "Run" || troubleshooting ==1)
                    {
                        mbEnableDisableChanges.Text = "Disable Changes";
                        //enable all text boxes
                        mbSettingsSave.Enabled = true;

                        //default to enable false:
                        cbMetroSamplePeriod.Enabled = true;
                        tbMetroUpscalePos.Enabled = true;
                        tbMetroEnergyCalPos.Enabled = true;
                        tbMetroEC1FilterPos.Enabled = true;
                        tbMetroEC2FilterPos.Enabled = true;
                        tbMetroEC3FilterPos.Enabled = true;
                        tbMetroEC4FilterPos.Enabled = true;

                        tbMetroEcalkV.Enabled = true;
                        tbMetroEcaluA.Enabled = true;
                        tbMetroEcalTime.Enabled = true;
                        tbMetroEC1kV.Enabled = true;
                        tbMetroEC1uA.Enabled = true;
                        tbMetroEC1RunTimePercent.Enabled = true;
                        tbMetroEC1RunTimeSeconds.Enabled = false;
                        cbMetroEC1Filter.Enabled = true;
                        cbMetroEC1AutoCurrent.Enabled = true;

                        tbMetroEC2kV.Enabled = true;
                        tbMetroEC2uA.Enabled = true;
                        tbMetroEC2RunTimePercent.Enabled = true;
                        tbMetroEC2RunTimeSeconds.Enabled = false;
                        cbMetroEC2Filter.Enabled = true;
                        cbMetroEC2AutoCurrent.Enabled = true;

                        tbMetroEC3kV.Enabled = true;
                        tbMetroEC3uA.Enabled = true;
                        tbMetroEC3RunTimePercent.Enabled = true;
                        tbMetroEC3RunTimeSeconds.Enabled = false;
                        cbMetroEC3Filter.Enabled = true;
                        cbMetroEC3AutoCurrent.Enabled = true;

                        tbMetroEC4kV.Enabled = true;
                        tbMetroEC4uA.Enabled = true;
                        tbMetroEC4RunTimePercent.Enabled = true;
                        tbMetroEC4RunTimeSeconds.Enabled = false;
                        cbMetroEC4Filter.Enabled = true;
                        cbMetroEC4AutoCurrent.Enabled = true;


                        //tbMetroFWMC.Enabled = false;
                        //tbMetroFWHC.Enabled = false;
                        //tbMetroDMC.Enabled = false;
                        //tbMetroDHC.Enabled = false;
                        //tbMetroNozzleMC.Enabled = false;
                        //tbMetroNozzleHC.Enabled = false;
                        //tbMetroTapeMC.Enabled = false;
                        //tbMetroTapeHC.Enabled = false;

                        tbMetroMotorComPort.Enabled = true;
                        tbMetroWindComPort.Enabled = true;
                        tbMetroInletHeaterRH.Enabled = true;
                        tbMetroModbusComPort.Enabled = true;

                        tbMetroUpscaleCr.Enabled = true; // = Properties.Settings.Default.UpscaleCr.ToString();
                        tbMetroUpscalePb.Enabled = true; // = Properties.Settings.Default.UpscalePb.ToString();
                        tbMetroUpscaleCd.Enabled = true; // Text = Properties.Settings.Default.UpscaleCd.ToString();
                        tbMetroUpscaleEC4.Enabled = true; //
                        tbMetroNb.Enabled = true; // = Properties.Settings.Default.Nb.ToString();
                        tbMetroNbAlarmPercent.Enabled = true;

                        tbMetroUpscaleAlarmPercent.Enabled = true; // Text = Properties.Settings.Default.UpscaleAlarmPercent.ToString();
                        cbMetroFlowControl.Enabled = true; // = Properties.Settings.Default.FlowControl.ToString();
                        cbMetroFlowSum.Enabled = true; // Text = Properties.Settings.Default.FlowSum.ToString();
                        mbOptions.Enabled = true;


                        // if(cbMetroSamplePeriod.SelectedIndex!=7)
                        // {
                        //     cbMetroSamplePeriod.Items.Remove("M");
                        // }
                        //if(cbMetroSamplePeriod.Items.Contains("M"))
                        //{
                        //    cbMetroSamplePeriod.Items.Remove("M");
                        //    cbMetroSamplePeriod.SelectedItem = "15";
                        //    Properties.Settings.Default.SampleTime = 15;
                        //}
                        if (cbMetroSamplePeriod.Items.Contains("0"))
                        {
                            cbMetroSamplePeriod.Items.Remove("0");

                        }


                        //check for key press here:
                        if (((Keyboard.IsKeyDown(Key.LeftCtrl) || Keyboard.IsKeyDown(Key.RightCtrl)) && Keyboard.IsKeyDown(Key.M)))
                        {
                            // CTRL + M is currently pressed

                            if (cbMetroSamplePeriod.Items.Contains("M"))
                            {
                                cbMetroSamplePeriod.SelectedIndex = 6;

                            }
                            else
                            {
                                cbMetroSamplePeriod.Items.Add("M");
                                cbMetroSamplePeriod.SelectedIndex = 6;
                            }


                        }



                    }


            }
            else if (mbEnableDisableChanges.Text.Contains("Disable"))
            {

                //re-read from settings....
                mbSettingsSave.Enabled = false;
                cbMetroSamplePeriod.Text = Properties.Settings.Default.SampleTime.ToString();
                tbMetroUpscalePos.Text = Properties.Settings.Default.UpscaleRodPosition.ToString();
                tbMetroEnergyCalPos.Text = Properties.Settings.Default.EcalRodPosition.ToString();
                tbMetroEC1FilterPos.Text = Properties.Settings.Default.FWEC1.ToString();
                tbMetroEC2FilterPos.Text = Properties.Settings.Default.FWEC2.ToString();
                tbMetroEC3FilterPos.Text = Properties.Settings.Default.FWEC3.ToString();
                tbMetroEC4FilterPos.Text = Properties.Settings.Default.FWEC4.ToString();

                tbMetroEcalkV.Text = Properties.Settings.Default.EcalkV.ToString();
                tbMetroEcaluA.Text = Properties.Settings.Default.EcaluA.ToString();
                tbMetroEcalTime.Text = Properties.Settings.Default.EcalTime.ToString();


                tbMetroEC1kV.Text = Properties.Settings.Default.EC1kV.ToString();
                tbMetroEC1uA.Text = Properties.Settings.Default.EC1uA.ToString();
                tbMetroEC1RunTimePercent.Text = Properties.Settings.Default.EC1RTP.ToString();
                tbMetroEC1RunTimeSeconds.Text = Properties.Settings.Default.EC1RunTime.ToString();
                cbMetroEC1Filter.Text = Properties.Settings.Default.EC1Filter.ToString();
                cbMetroEC1AutoCurrent.Text = Properties.Settings.Default.EC1AC.ToString();

                tbMetroEC2kV.Text = Properties.Settings.Default.EC2kV.ToString();
                tbMetroEC2uA.Text = Properties.Settings.Default.EC2uA.ToString();
                tbMetroEC2RunTimePercent.Text = Properties.Settings.Default.EC2RTP.ToString();
                tbMetroEC2RunTimeSeconds.Text = Properties.Settings.Default.EC2RunTime.ToString();
                cbMetroEC2Filter.Text = Properties.Settings.Default.EC2Filter.ToString();
                cbMetroEC2AutoCurrent.Text = Properties.Settings.Default.EC2AC.ToString();

                tbMetroEC3kV.Text = Properties.Settings.Default.EC3kV.ToString();
                tbMetroEC3uA.Text = Properties.Settings.Default.EC3uA.ToString();
                tbMetroEC3RunTimePercent.Text = Properties.Settings.Default.EC3RTP.ToString();
                tbMetroEC3RunTimeSeconds.Text = Properties.Settings.Default.EC3RunTime.ToString();
                cbMetroEC3Filter.Text = Properties.Settings.Default.EC3Filter.ToString();
                cbMetroEC3AutoCurrent.Text = Properties.Settings.Default.EC3AC.ToString();

                tbMetroEC4kV.Text = Properties.Settings.Default.EC4kV.ToString();
                tbMetroEC4uA.Text = Properties.Settings.Default.EC4uA.ToString();
                tbMetroEC4RunTimePercent.Text = Properties.Settings.Default.EC4RTP.ToString();
                tbMetroEC4RunTimeSeconds.Text = Properties.Settings.Default.EC4RunTime.ToString();
                cbMetroEC4Filter.Text = Properties.Settings.Default.EC4Filter.ToString();
                cbMetroEC4AutoCurrent.Text = Properties.Settings.Default.EC4AC.ToString();


                //tbMetroFWMC.Text = Properties.Settings.Default.FWMC.ToString();
                //tbMetroFWHC.Text = Properties.Settings.Default.FWHC.ToString();
                //tbMetroDMC.Text = Properties.Settings.Default.DMC.ToString();
                //tbMetroDHC.Text = Properties.Settings.Default.DHC.ToString();
                //tbMetroNozzleMC.Text = Properties.Settings.Default.NozzleMC.ToString();
                //tbMetroNozzleHC.Text = Properties.Settings.Default.NozzleHC.ToString();
                //tbMetroTapeMC.Text = Properties.Settings.Default.TapeMC.ToString();
                //tbMetroTapeHC.Text = Properties.Settings.Default.TapeHC.ToString();

                tbMetroMotorComPort.Text = Properties.Settings.Default.MotorComPort.ToString();
                tbMetroWindComPort.Text = Properties.Settings.Default.WindComPort.ToString();
                tbMetroInletHeaterRH.Text = Properties.Settings.Default.InletHeater.ToString();

                tbMetroUpscaleCr.Text = Properties.Settings.Default.UpscaleCr.ToString();
                tbMetroUpscalePb.Text = Properties.Settings.Default.UpscalePb.ToString();
                tbMetroUpscaleCd.Text = Properties.Settings.Default.UpscaleCd.ToString();
                tbMetroUpscaleEC4.Text = Properties.Settings.Default.UpscaleEC4.ToString();
                tbMetroNb.Text = Properties.Settings.Default.Nb.ToString();
                tbMetroNbAlarmPercent.Text = Properties.Settings.Default.NbAlarmPercent.ToString();

                tbMetroUpscaleAlarmPercent.Text = Properties.Settings.Default.UpscaleAlarmPercent.ToString();
                cbMetroFlowControl.Text = Properties.Settings.Default.FlowControl.ToString();
                cbMetroFlowSum.Text = Properties.Settings.Default.FlowSum.ToString();
                tbMetroModbusComPort.Text = Properties.Settings.Default.ModbusComPort.ToString();
                //default enable / disable button to 'enable' everything only if stopped




                mbEnableDisableChanges.Text = "Enable Changes";
                //disable all text boxes
                cbMetroSamplePeriod.Enabled = false;
                tbMetroUpscalePos.Enabled = false;
                tbMetroEnergyCalPos.Enabled = false;
                tbMetroEC1FilterPos.Enabled = false;
                tbMetroEC2FilterPos.Enabled = false;
                tbMetroEC3FilterPos.Enabled = false;
                tbMetroEC4FilterPos.Enabled = false;
                tbMetroEcalkV.Enabled = false;
                tbMetroEcaluA.Enabled = false;
                tbMetroEcalTime.Enabled = false;

                tbMetroEC1kV.Enabled = false;
                tbMetroEC1uA.Enabled = false;
                tbMetroEC1RunTimePercent.Enabled = false;
                tbMetroEC1RunTimeSeconds.Enabled = false;
                cbMetroEC1Filter.Enabled = false;
                cbMetroEC1AutoCurrent.Enabled = false;

                tbMetroEC2kV.Enabled = false;
                tbMetroEC2uA.Enabled = false;
                tbMetroEC2RunTimePercent.Enabled = false;
                tbMetroEC2RunTimeSeconds.Enabled = false;
                cbMetroEC2Filter.Enabled = false;
                cbMetroEC2AutoCurrent.Enabled = false;

                tbMetroEC3kV.Enabled = false;
                tbMetroEC3uA.Enabled = false;
                tbMetroEC3RunTimePercent.Enabled = false;
                tbMetroEC3RunTimeSeconds.Enabled = false;
                cbMetroEC3Filter.Enabled = false;
                cbMetroEC3AutoCurrent.Enabled = false;

                tbMetroEC4kV.Enabled = false;
                tbMetroEC4uA.Enabled = false;
                tbMetroEC4RunTimePercent.Enabled = false;
                tbMetroEC4RunTimeSeconds.Enabled = false;
                cbMetroEC4Filter.Enabled = false;
                cbMetroEC4AutoCurrent.Enabled = false;


                //tbMetroFWMC.Enabled = false;
                //tbMetroFWHC.Enabled = false;
                //tbMetroDMC.Enabled = false;
                //tbMetroDHC.Enabled = false;
                //tbMetroNozzleMC.Enabled = false;
                //tbMetroNozzleHC.Enabled = false;
                //tbMetroTapeMC.Enabled = false;
                //tbMetroTapeHC.Enabled = false;

                tbMetroMotorComPort.Enabled = false;
                tbMetroWindComPort.Enabled = false;
                tbMetroInletHeaterRH.Enabled = false;
                tbMetroModbusComPort.Enabled = false;

                mbOptions.Enabled = false;


                tbMetroUpscaleCr.Enabled = false; // = Properties.Settings.Default.UpscaleCr.ToString();
                tbMetroUpscalePb.Enabled = false; // = Properties.Settings.Default.UpscalePb.ToString();
                tbMetroUpscaleCd.Enabled = false; // = Properties.Settings.Default.UpscaleCd.ToString();
                tbMetroUpscaleEC4.Enabled = false; //
                tbMetroNb.Enabled = false; // = Properties.Settings.Default.Nb.ToString();
                tbMetroNbAlarmPercent.Enabled = false;
                tbMetroUpscaleAlarmPercent.Enabled = false; // = Properties.Settings.Default.UpscaleAlarmPercent.ToString();
                cbMetroFlowControl.Enabled = false; // = Properties.Settings.Default.FlowControl.ToString();
                cbMetroFlowSum.Enabled = false; // = Properties.Settings.Default.FlowSum.ToString();



            }





        }

        private void metroTextBox21_Click(object sender, EventArgs e)
        {

        }

        private void metroComboBox1_SelectedIndexChanged(object sender, EventArgs e)
        {

        }

        private void metroLabel74_Click(object sender, EventArgs e)
        {


        }

        private void metroTextBox24_Click(object sender, EventArgs e)
        {

        }

        private void metroButton7_Click(object sender, EventArgs e)
        {
            //save all of the settings values //from settings page:

            int returnValEC1, returnValEC2, returnValEC3, returnValEC4, returnValEcal, returnValECTimes;

            try
            {

                //check for valid kV and uA inputs before saving:





                returnValEC1 = VerifykVuA(Convert.ToInt32(tbMetroEC1kV.Text), Convert.ToInt32(tbMetroEC1uA.Text), "EC 1 ");
                returnValEC2 = VerifykVuA(Convert.ToInt32(tbMetroEC2kV.Text), Convert.ToInt32(tbMetroEC2uA.Text), "EC 2 ");
                returnValEC3 = VerifykVuA(Convert.ToInt32(tbMetroEC3kV.Text), Convert.ToInt32(tbMetroEC3uA.Text), "EC 3 ");
                returnValEC4 = VerifykVuA(Convert.ToInt32(tbMetroEC4kV.Text), Convert.ToInt32(tbMetroEC4uA.Text), "EC 4 ");

                returnValEcal = VerifykVuA(Convert.ToInt32(tbMetroEcalkV.Text), Convert.ToInt32(tbMetroEcaluA.Text), "Energy Cal ");

                returnValECTimes = VerifyECTimes(Convert.ToInt32(tbMetroEC1RunTimePercent.Text),Convert.ToInt32(tbMetroEC2RunTimePercent.Text),Convert.ToInt32(tbMetroEC3RunTimePercent.Text),Convert.ToInt32(tbMetroEC4RunTimePercent.Text));





                if (returnValEC1 == PASS && returnValEC2 == PASS && returnValEC3 == PASS && returnValEC4 == PASS && returnValEcal == PASS && returnValECTimes == PASS)
                {



                    if (cbMetroSamplePeriod.SelectedItem.Equals("M"))
                    {
                        Properties.Settings.Default.SampleTime = 77; //thats ascii for M
                    }
                    else
                    {
                        Properties.Settings.Default.SampleTime = Convert.ToInt32(cbMetroSamplePeriod.SelectedItem.ToString());
                        if (cbMetroSamplePeriod.Items.Contains("M"))
                        {
                            cbMetroSamplePeriod.Items.Remove("M");
                        }
                    }
                    //int value = Properties.Settings.Default.SampleTime;
                    Properties.Settings.Default.UpscaleRodPosition = Convert.ToInt32(tbMetroUpscalePos.Text);
                    Properties.Settings.Default.EcalRodPosition = Convert.ToInt32(tbMetroEnergyCalPos.Text);
                    Properties.Settings.Default.FWEC1 = Convert.ToInt32(tbMetroEC1FilterPos.Text);
                    Properties.Settings.Default.FWEC2 = Convert.ToInt32(tbMetroEC2FilterPos.Text);
                    Properties.Settings.Default.FWEC3 = Convert.ToInt32(tbMetroEC3FilterPos.Text);
                    Properties.Settings.Default.FWEC4 = Convert.ToInt32(tbMetroEC4FilterPos.Text);

                    Properties.Settings.Default.EcalkV = Convert.ToInt32(tbMetroEcalkV.Text);
                    Properties.Settings.Default.EcaluA = Convert.ToInt32(tbMetroEcaluA.Text);
                    Properties.Settings.Default.EcalTime = Convert.ToInt32(tbMetroEcalTime.Text);




                    Properties.Settings.Default.EC1kV = Convert.ToInt32(tbMetroEC1kV.Text);

                    Properties.Settings.Default.EC1uA = Convert.ToInt32(tbMetroEC1uA.Text);

                    Properties.Settings.Default.EC1RTP = Convert.ToInt32(tbMetroEC1RunTimePercent.Text);


                    Properties.Settings.Default.EC1RunTime = Convert.ToInt32(tbMetroEC1RunTimeSeconds.Text);

                    Properties.Settings.Default.EC1Filter = cbMetroEC1Filter.SelectedItem.ToString();

                    Properties.Settings.Default.EC1AC = cbMetroEC1AutoCurrent.SelectedItem.ToString();

                    Properties.Settings.Default.EC2kV = Convert.ToInt32(tbMetroEC2kV.Text);


                    Properties.Settings.Default.EC2uA = Convert.ToInt32(tbMetroEC2uA.Text);

                    Properties.Settings.Default.EC2RTP = Convert.ToInt32(tbMetroEC2RunTimePercent.Text);

                    Properties.Settings.Default.EC2RunTime = Convert.ToInt32(tbMetroEC2RunTimeSeconds.Text);

                    Properties.Settings.Default.EC2Filter = cbMetroEC2Filter.SelectedItem.ToString();

                    Properties.Settings.Default.EC2AC = cbMetroEC2AutoCurrent.SelectedItem.ToString();


                    Properties.Settings.Default.EC3kV = Convert.ToInt32(tbMetroEC3kV.Text);

                    Properties.Settings.Default.EC3uA = Convert.ToInt32(tbMetroEC3uA.Text);

                    Properties.Settings.Default.EC3RTP = Convert.ToInt32(tbMetroEC3RunTimePercent.Text);

                    Properties.Settings.Default.EC3RunTime = Convert.ToInt32(tbMetroEC3RunTimeSeconds.Text);

                    Properties.Settings.Default.EC3Filter = cbMetroEC3Filter.SelectedItem.ToString();

                    Properties.Settings.Default.EC3AC = cbMetroEC3AutoCurrent.SelectedItem.ToString();


                    Properties.Settings.Default.EC4kV = Convert.ToInt32(tbMetroEC4kV.Text);

                    Properties.Settings.Default.EC4uA = Convert.ToInt32(tbMetroEC4uA.Text);

                    Properties.Settings.Default.EC4RTP = Convert.ToInt32(tbMetroEC4RunTimePercent.Text);

                    Properties.Settings.Default.EC4RunTime = Convert.ToInt32(tbMetroEC4RunTimeSeconds.Text);

                    Properties.Settings.Default.EC4Filter = cbMetroEC4Filter.SelectedItem.ToString();

                    Properties.Settings.Default.EC4AC = cbMetroEC4AutoCurrent.SelectedItem.ToString();




                    //Properties.Settings.Default.FWMC = Convert.ToInt32(tbMetroFWMC.Text);

                    //Properties.Settings.Default.FWHC = Convert.ToInt32(tbMetroFWHC.Text);
                    //Properties.Settings.Default.DMC = Convert.ToInt32(tbMetroDMC.Text);

                    //Properties.Settings.Default.DHC = Convert.ToInt32(tbMetroDHC.Text);

                    //Properties.Settings.Default.NozzleMC = Convert.ToInt32(tbMetroNozzleMC.Text);
                    //Properties.Settings.Default.NozzleHC = Convert.ToInt32(tbMetroNozzleHC.Text);
                    //Properties.Settings.Default.TapeMC = Convert.ToInt32(tbMetroTapeMC.Text);

                    //Properties.Settings.Default.TapeHC = Convert.ToInt32(tbMetroTapeHC.Text);

                    Properties.Settings.Default.MotorComPort = Convert.ToInt32(tbMetroMotorComPort.Text);

                    Properties.Settings.Default.WindComPort = Convert.ToInt32(tbMetroWindComPort.Text);
                    Properties.Settings.Default.InletHeater = Convert.ToInt32(tbMetroInletHeaterRH.Text);

                    Properties.Settings.Default.UpscaleCr = Convert.ToDouble(tbMetroUpscaleCr.Text);
                    Properties.Settings.Default.UpscalePb = Convert.ToDouble(tbMetroUpscalePb.Text);
                    Properties.Settings.Default.UpscaleCd = Convert.ToDouble(tbMetroUpscaleCd.Text);
                    Properties.Settings.Default.UpscaleEC4 = Convert.ToDouble(tbMetroUpscaleEC4.Text);

                    Properties.Settings.Default.Nb = Convert.ToDouble(tbMetroNb.Text);
                    Properties.Settings.Default.NbAlarmPercent = Convert.ToDouble(tbMetroNbAlarmPercent.Text);
                    Properties.Settings.Default.UpscaleAlarmPercent = Convert.ToInt32(tbMetroUpscaleAlarmPercent.Text);
                    Properties.Settings.Default.FlowControl = cbMetroFlowControl.Text;
                    Properties.Settings.Default.FlowSum = cbMetroFlowSum.Text;
                    Properties.Settings.Default.ModbusComPort = Convert.ToInt32(tbMetroModbusComPort.Text);

                    if (System.IO.File.Exists("c:/CES/UserSettings/old_settings_2.ini") == true)
                    {
                        System.IO.File.Delete("c:/CES/UserSettings/old_settings_2.ini");
                    }

                    if (System.IO.File.Exists("c:/CES/UserSettings/old_settings_1.ini") == true)
                    {
                        System.IO.File.Move("c:/CES/UserSettings/old_settings_1.ini", "c:/CES/UserSettings/old_settings_2.ini");
                        System.IO.File.Delete("c:/CES/UserSettings/old_settings_1.ini");
                    }

                    if (System.IO.File.Exists("c:/CES/UserSettings/settings.ini") == true)
                    {
                        System.IO.File.Move("c:/CES/UserSettings/settings.ini", "c:/CES/UserSettings/old_settings_1.ini");
                        System.IO.File.Delete("c:/CES/UserSettings/settings.ini");
                    }



                    //Save Settings
                    Logger.SaveSetting(cbMetroSamplePeriod.SelectedItem.ToString());
                    Logger.SaveSetting(tbMetroUpscalePos.Text);
                    Logger.SaveSetting(tbMetroEnergyCalPos.Text);
                    Logger.SaveSetting(tbMetroEC1FilterPos.Text);
                    Logger.SaveSetting(tbMetroEC2FilterPos.Text);
                    Logger.SaveSetting(tbMetroEC3FilterPos.Text);

                    Logger.SaveSetting(tbMetroEcalkV.Text);
                    Logger.SaveSetting(tbMetroEcaluA.Text);
                    Logger.SaveSetting(tbMetroEcalTime.Text);

                    Logger.SaveSetting(tbMetroEC1kV.Text);
                    Logger.SaveSetting(tbMetroEC1uA.Text);
                    Logger.SaveSetting(tbMetroEC1RunTimePercent.Text);
                    Logger.SaveSetting(tbMetroEC1RunTimeSeconds.Text);
                    Logger.SaveSetting(cbMetroEC1Filter.SelectedItem.ToString());
                    Logger.SaveSetting(cbMetroEC1AutoCurrent.SelectedItem.ToString());

                    Logger.SaveSetting(tbMetroEC2kV.Text);
                    Logger.SaveSetting(tbMetroEC2uA.Text);
                    Logger.SaveSetting(tbMetroEC2RunTimePercent.Text);
                    Logger.SaveSetting(tbMetroEC2RunTimeSeconds.Text);
                    Logger.SaveSetting(cbMetroEC2Filter.SelectedItem.ToString());
                    Logger.SaveSetting(cbMetroEC2AutoCurrent.SelectedItem.ToString());

                    Logger.SaveSetting(tbMetroEC3kV.Text);
                    Logger.SaveSetting(tbMetroEC3uA.Text);
                    Logger.SaveSetting(tbMetroEC3RunTimePercent.Text);
                    Logger.SaveSetting(tbMetroEC3RunTimeSeconds.Text);
                    Logger.SaveSetting(cbMetroEC3Filter.SelectedItem.ToString());
                    Logger.SaveSetting(cbMetroEC3AutoCurrent.SelectedItem.ToString());

                    Logger.SaveSetting(Properties.Settings.Default.FWMC.ToString());
                    Logger.SaveSetting(Properties.Settings.Default.FWHC.ToString());
                    Logger.SaveSetting(Properties.Settings.Default.DMC.ToString());
                    Logger.SaveSetting(Properties.Settings.Default.DHC.ToString());
                    Logger.SaveSetting(Properties.Settings.Default.NozzleMC.ToString());
                    Logger.SaveSetting(Properties.Settings.Default.NozzleHC.ToString());
                    Logger.SaveSetting(Properties.Settings.Default.TapeMC.ToString());
                    Logger.SaveSetting(Properties.Settings.Default.TapeHC.ToString());

                    Logger.SaveSetting(tbMetroMotorComPort.Text);
                    Logger.SaveSetting(tbMetroWindComPort.Text);
                    Logger.SaveSetting(tbMetroInletHeaterRH.Text);

                    Logger.SaveSetting(tbMetroUpscaleCr.Text);
                    Logger.SaveSetting(tbMetroUpscalePb.Text);
                    Logger.SaveSetting(tbMetroUpscaleCd.Text);
                    Logger.SaveSetting(tbMetroNb.Text);

                    Logger.SaveSetting(tbMetroUpscaleAlarmPercent.Text);
                    Logger.SaveSetting(cbMetroFlowControl.Text);
                    Logger.SaveSetting(cbMetroFlowSum.Text);
                    Logger.SaveSetting(tbMetroModbusComPort.Text);

                    Logger.SaveSetting(Properties.Settings.Default.yint.ToString());
                    Logger.SaveSetting(Properties.Settings.Default.slope.ToString());

                    Logger.SaveSetting(Properties.Settings.Default.TnistCalAdj.ToString());
                    Logger.SaveSetting(Properties.Settings.Default.PnistCalAdj.ToString());

                    Logger.SaveSetting(Properties.Settings.Default.PSnistCalAdj.ToString());

                    Logger.SaveSetting(Properties.Settings.Default.OutputPin7.ToString());
                    Logger.SaveSetting(Properties.Settings.Default.OutputPin4.ToString());
                    Logger.SaveSetting(Properties.Settings.Default.NbAlarmPercent.ToString());  //order matters here....

                    Logger.SaveSetting(Properties.Settings.Default.TubeTempErrorTrigger.ToString());
                    Logger.SaveSetting(Properties.Settings.Default.TubeTempWarningTrigger.ToString());
                    Logger.SaveSetting(Properties.Settings.Default.FWHK.ToString());

                    Logger.SaveSetting(tbMetroEC4kV.Text);
                    Logger.SaveSetting(tbMetroEC4uA.Text);
                    Logger.SaveSetting(tbMetroEC4RunTimePercent.Text);
                    Logger.SaveSetting(tbMetroEC4RunTimeSeconds.Text);
                    Logger.SaveSetting(cbMetroEC4Filter.SelectedItem.ToString());
                    Logger.SaveSetting(cbMetroEC4AutoCurrent.SelectedItem.ToString());

                    Logger.SaveSetting(tbMetroEC4FilterPos.Text);
                    Logger.SaveSetting(tbMetroUpscaleEC4.Text);


                    Logger.SaveSetting(Properties.Settings.Default.EncoderWheelLL.ToString());
                    Logger.SaveSetting(Properties.Settings.Default.EncoderWheelUL.ToString());

                    Logger.SaveSetting(Properties.Settings.Default.TemperatureSensorType.ToString());

                    Logger.SaveSetting(Properties.Settings.Default.FlowError.ToString());
                    Logger.SaveSetting(Properties.Settings.Default.FlowWarning.ToString());


                    string item = Properties.Settings.Default.TapeMidMoveCheckEnable.ToString();
                    Logger.SaveSetting(Properties.Settings.Default.TapeMidMoveCheckEnable.ToString());

                    Logger.SaveSetting(Properties.Settings.Default.RunModeFlow.ToString());

                    //End Writting Setting File




                    Properties.Settings.Default.Save();
                    mbEnableDisableChanges.Text = "Enable Changes";


                    //
                    cbMetroSamplePeriod.Enabled = false;
                    tbMetroUpscalePos.Enabled = false;
                    tbMetroEnergyCalPos.Enabled = false;
                    tbMetroEC1FilterPos.Enabled = false;
                    tbMetroEC2FilterPos.Enabled = false;
                    tbMetroEC3FilterPos.Enabled = false;
                    tbMetroEC4FilterPos.Enabled = false;
                    tbMetroEcalkV.Enabled = false;
                    tbMetroEcaluA.Enabled = false;
                    tbMetroEcalTime.Enabled = false;


                    tbMetroEC1kV.Enabled = false;
                    tbMetroEC1uA.Enabled = false;
                    tbMetroEC1RunTimePercent.Enabled = false;
                    tbMetroEC1RunTimeSeconds.Enabled = false;
                    cbMetroEC1Filter.Enabled = false;
                    cbMetroEC1AutoCurrent.Enabled = false;

                    tbMetroEC2kV.Enabled = false;
                    tbMetroEC2uA.Enabled = false;
                    tbMetroEC2RunTimePercent.Enabled = false;
                    tbMetroEC2RunTimeSeconds.Enabled = false;
                    cbMetroEC2Filter.Enabled = false;
                    cbMetroEC2AutoCurrent.Enabled = false;

                    tbMetroEC3kV.Enabled = false;
                    tbMetroEC3uA.Enabled = false;
                    tbMetroEC3RunTimePercent.Enabled = false;
                    tbMetroEC3RunTimeSeconds.Enabled = false;
                    cbMetroEC3Filter.Enabled = false;
                    cbMetroEC3AutoCurrent.Enabled = false;

                    tbMetroEC4kV.Enabled = false;
                    tbMetroEC4uA.Enabled = false;
                    tbMetroEC4RunTimePercent.Enabled = false;
                    tbMetroEC4RunTimeSeconds.Enabled = false;
                    cbMetroEC4Filter.Enabled = false;
                    cbMetroEC4AutoCurrent.Enabled = false;



                    tbMetroMotorComPort.Enabled = false;
                    tbMetroWindComPort.Enabled = false;
                    tbMetroInletHeaterRH.Enabled = false;
                    tbMetroUpscaleCr.Enabled = false;
                    tbMetroUpscalePb.Enabled = false;
                    tbMetroUpscaleCd.Enabled = false;
                    tbMetroUpscaleEC4.Enabled = false;
                    tbMetroNb.Enabled = false;
                    tbMetroNbAlarmPercent.Enabled = false;
                    tbMetroUpscaleAlarmPercent.Enabled = false;
                    cbMetroFlowControl.Enabled = false;
                    cbMetroFlowSum.Enabled = false;
                    tbMetroModbusComPort.Enabled = false;

                    mbSettingsSave.Enabled = false;

                    mbOptions.Enabled = false;



                    nModbusOperations.Dispose();

                    SerialManager.CloseSerialPort();
                    SerialManager.Dispose();
                    SerialManager.initSerialIO();

                    SerialWindSpeedandDirManager.CloseSerialPort();
                    SerialWindSpeedandDirManager.Dispose();
                    SerialWindSpeedandDirManager.initSerialIO();

        


                    //
                    // start code block for resetting comport assigned to modbus or CL output
                    //
                    if (Properties.Settings.Default.OutputPin7 == false)
                    {
                        if (SerialIOControlLinesManager!= null)
                        {
                            try
                            {
                                SerialIOControlLinesManager.Dispose();
                            }
                            catch(Exception Ex)
                            {

                            }
                        }
                    }
                    else
                    {
                        if (SerialIOControlLinesManager!= null)
                        {
                            try
                            {
                                nModbusOperations.Dispose();
                            }
                            catch
                            {
                            }
                        }
                    }
                    if (Properties.Settings.Default.OutputPin7 == true /*|| Properties.Settings.Default.OutputPin4 == true*/)
                    {
                        try
                        {
                            SerialIOControlLinesManager = new SerialControlLinesIO();
                            SerialIOControlLinesManager.initSerialIO();  //init sets up the comport and use the nmodbus comport number.
                            SerialIOControlLinesManager.ClrOutputPin4();
                            SerialIOControlLinesManager.ClrOutputPin7();
                        }
                        catch(Exception Ex)
                        {

                        }
                    }
                    else
                    {
                        try
                        {
                            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                            DataStore xactHoldingRegisters = AcquisitionControl.getDataStore();
                            string mbComport = "COM" + Properties.Settings.Default.ModbusComPort.ToString();
                            nModbusOperations.initialize(mbComport, 9600, out xactHoldingRegisters);
                            AcquisitionControl.setDataStore(xactHoldingRegisters);
                        }
                        catch(Exception Ex)
                        {

                        }
                    }
                    //
                    // start code block for resetting comport assigned to modbus or CL output
                    //

                }
                //else
                //{

                //    //pop up confirmation
                //    FlexibleMessageBox.FONT = SystemFonts.MenuFont;

                //    DialogResult dialogResult = FlexibleMessageBox.Show("Invalid kV or uA values.  Re-enter parameters.",
                //            "Re-enter parameters",
                //            MessageBoxButtons.OK,
                //            MessageBoxIcon.Exclamation,
                //            MessageBoxDefaultButton.Button1
                //            );



                //    if (dialogResult == DialogResult.OK)
                //    {
                //        //do something


                //    }
                //    else
                //    {

                //    }
                //}



            }
            catch (Exception Ex)
            {

                Logger.WriteInternalLogFile("Error saving settings.  Ex = " + Ex.ToString());
            }





        }

        private void metroTextBox43_Click(object sender, EventArgs e)
        {

        }

        private void metroButton9_Click(object sender, EventArgs e)
        {  //ramp to zero


            if (mbRun.Text.Contains("Stop"))
            {

                runState = 0;
                mbRun.Text = "Run";
                mtbStatusOperation.Text = "Ramp to Zero Pressed.  Stop Acquisition.";
                Logger.WriteLogFile(   "Ramp to Zero pressed in maint tab.");
                //Warning("Stop Button Pressed.");
                //mbRun.BackColor = Color.Gray;
                metroStatusButton.BackColor = Color.Gray;
                RampXraysToZero();
                if (BackgroundManager.m_oWorkerAcq.IsBusy)
                {
                    BackgroundManager.m_oWorkerAcq.CancelAsync();
                }


            }
            else
            {

                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;



                //double targetVoltage = 0.0;
                //double targetCurrent = 0.0;

                mtbMaintenanceTargetkV.Text = "0.0";
                mtbMaintenanceTargetuA.Text = "0.0";


                //read presentV (actual 'kV') from NI
                double presentV = 0.0;
                presentV = readInputVoltage;
                presentV = (presentV * 50.0 / 10.0);

                //mtbActualkV.Text = presentV.ToString("F2");
                //presentV = Math.Round(presentV, 2, MidpointRounding.AwayFromZero);

                //write to GUI:
                //mtbActualkV.Text = presentV.ToString();


                //read presentI (actual i) from NI
                double presentI = 0.0;
                presentI = readInputCurrent;
                presentI = (presentI * 2000.0 / 10.0);
                //presentI = Math.Round(presentI, 2, MidpointRounding.AwayFromZero);

                //write to GUI:
                //mtbActualuA.Text = presentI.ToString("F2");


                if (presentV < 0)
                    presentV = 0.0;
                if (presentI < 0)
                    presentI = 0.0;

                int returnVal = AcquisitionControl.RampXrays(presentV, presentI, 0.0, 0.0, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
            }
            xrayOnCommand = 0;


        }

        private void metroButton20_Click(object sender, EventArgs e)
        {
            try
            {

                // logic for com interface to xrsfp and spectra x

                myxrsfp = new cMTFFPX();
                var returnValue = myxrsfp.Connect_MCA;
                

                var returnVal = 0;
                returnVal = myxrsfp.GetHASPbits;   //if this returns non zero hasp is okay

                if (returnVal < 0)
                {
                    mlabelHasp.Text = "INVALID key";

                    mlabelHasp.BackColor = Color.DimGray;
                    mtbXrsStatus.Text = "Xrs-Fp init: Fail";
                    mtbXrsStatus.Refresh();

                }
                else
                {
                    mlabelHasp.Text = "VALID key";
                    //lb_hasp.BackColor = Color.Cyan;
                    //mlabelHasp.BackColor = System.Drawing.Color.LimeGreen;   //no work metro
                    mlabelHasp.BackColor = Color.LimeGreen;
                    mtbXrsStatus.Text = "Xrs-Fp init: Pass";
                    mtbXrsStatus.Refresh();

                    //hasp key valid
                }
                myxrsfp.Form_Show = false;
                myxrsfp.SpectraX_Show = false;



            }
            catch (Exception Ex)
            {
                //int error = 1;
                Logger.WriteErrorFile("Error in check xrsfp hasp key.  Ex = "+Ex.ToString());
            }

        }

        private void metroButton16_Click(object sender, EventArgs e)
        {
            //vane up click
            //mtbNozzleControlStatus.Text = "Move Up";
            //mtbStatusNozzleMessage.Text = "Move Up";
            //mtbNozzleControlStatus.Refresh();
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            int retVal = AcquisitionControl.NozzleUp(SerialManager, this);
            if (retVal != PASS)
            {
                Logger.WriteErrorFile("Error Move Nozzle Up.");
                Logger.WriteLogFile("Error Move Nozzle Up.");
                //mtbNozzleControlStatus.Text = "Error Move Up";
                //mtbStatusNozzleMessage.Text = "Error Move Up";
            }
            else
            {
                //Logger.WriteLogFile("")
                //mtbNozzleControlStatus.Text = "";
            }







        }

        private void mbVaneDown_Click(object sender, EventArgs e)
        {


            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            //mtbNozzleControlStatus.Text = "Move Dn...";
            //mtbNozzleControlStatus.Refresh();
            int returnVal = AcquisitionControl.NozzleDown(SerialManager, this);
            if (returnVal != PASS)
            {
                //mtbNozzleControlStatus.Text = "Error Nozzle Dn";
                Logger.WriteErrorFile("Error Move Nozzle Down.");
                Logger.WriteLogFile("Error Move Nozzle Down.");
            }
            else
            {
                //mtbNozzleControlStatus.Text = "Nozzle is Dn";
            }



        }

        private void mbDynamicRodHome_Click(object sender, EventArgs e)
        {

            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            int retVal = AcquisitionControl.MoveRodHome(SerialManager, this);

            if (retVal == PASS)
            {

                //confirm position
                int position = 0;
                //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                //int returnVal27 = AcquisitionControl.CheckMotorPosition(SerialManager, 4, out position);

                position = AcquisitionControl.PollMotorPosition(4, SerialManager);
                //Logger.WriteLogFile(   "EC " + "init" + " (destination) motor position, after home = " + position.ToString());
                UpdateDynamicRodMessage("Dynamic Rod at position (" + position.ToString()+")");
            }
            else
            {
                UpdateDynamicRodMessage("Error: Moving DR Home.");
                //confirm position
                //int position = 0;
                //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                //int returnVal28 = AcquisitionControl.CheckMotorPosition(SerialManager, 4, out position);
                //Logger.WriteLogFile(   "EC " + "init" + " (destination) motor position, after home = " + position.ToString());
                //UpdateDynamicRodMessage("Error:  Dynamic Rod at position (" + position.ToString()+")");

            }


            //UpdateDynamicRodMessage("Moving DR Home");

            //int movec = Properties.Settings.Default.DMC;
            //int holdc = Properties.Settings.Default.DHC;

            //try
            //{
            //    SerialManager.WriteSerialPort("/1aM4m"+movec.ToString()+"h"+holdc.ToString()+"n0f1Z7500R\r");  //was 25 7
            //}

            //catch (Exception Ex)
            //{
            //    Logger.WriteErrorFile("Error move DR home.  Ex = " + Ex.ToString());
            //    UpdateDynamicRodMessage("Error move DR home.  Ex = " + Ex.ToString());
            //}

            //Thread.Sleep(12500);

            ////check for home sensor









        }

        private void mbMoveFilterWheelHome_Click(object sender, EventArgs e)
        {

            //mtbFWOutput.Text = "Moving FW Home";
            //mtbFWOutput.Refresh();
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            int retVal = AcquisitionControl.MoveFWHome(SerialManager, this);
            if (retVal == PASS)
            {
                //confirm position
                int position;

                //int returnVal27 = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);
                position = AcquisitionControl.PollMotorPosition(1, SerialManager);
                //Logger.WriteLogFile(   "EC " + "init" + " (destination) motor position, after home = " + position.ToString());
                UpdateFilterWheelMessage("Filter Wheel at position (" + position.ToString() + ")");
            }
            else
            {
                UpdateFilterWheelMessage("Error Filter Wheel home function.");

            }

            //confirm home sensor

            //int upperlim, lowerlim;
            //int returnValHome = AcquisitionControl.CheckHomeSensor(SerialManager, 1,out upperlim, out lowerlim);


        }

        private void mbDynamicRodForward_Click(object sender, EventArgs e)
        {


            //todo move and hold current

            //dynamic rod forward
            //mtbDynamicRodStepsIn

            double lastepsIn = 0.0;
            int laSteps = 0;
            string laStepsStr;

            try
            {
                double.TryParse(mtbDynamicRodStatus.Text, out lastepsIn);

                laSteps = (int)lastepsIn;
                laStepsStr = laSteps.ToString();

                if (laSteps > 10000)
                {
                    laStepsStr = "10000";
                }
                string stepCommand;

                stepCommand = "P" + laStepsStr + "R\r";
                int movec = Properties.Settings.Default.DMC;
                int holdc = Properties.Settings.Default.DHC;

                string command1 = "/1aM4m" + movec.ToString() + "h" + holdc.ToString();
                string command2 = command1 + stepCommand;


                mtbDROutput.Text = "Moving DR Fwd:  " + laStepsStr;
                mtbDROutput.Refresh();
                if (laSteps != 0)
                {
                    SerialManager.WriteSerialPort(command2);
                    //
                    //Thread.Sleep(9500);
                    //
                }
                //check for stable position read 
                int position = 0;
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;


                position = AcquisitionControl.PollMotorPosition(4, SerialManager);
                //int posOld = 0;
                //int posNew = 1;
                //int retv = FAIL;
                //int counter = 0;
                //do
                //{
                //    retv = AcquisitionControl.CheckMotorPosition(SerialManager, 4, out position);
                //    if (retv == PASS)
                //    {
                //        posNew = position;
                //    }

                //    if (posNew == posOld)
                //    {
                //        break;
                //    }

                //    posOld = posNew;
                //    counter++;
                //    Thread.Sleep(500);
                //} while (counter < 60);




                //int position;
                //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                //int returnVal27 = AcquisitionControl.CheckMotorPosition(SerialManager, 4, out position);
                ////Logger.WriteLogFile(   "EC " + "init" + " (destination) motor position, after home = " + position.ToString());

                UpdateDynamicRodMessage("Dynamic Rod now at position:  " + position.ToString());
            }
            catch (Exception Ex)
            {
                Logger.WriteErrorFile("Error in move DR Fwd.  See ErrorFile.txt" + Ex.ToString());
                Logger.WriteLogFile("Error in move DR Fwd.  See ErrorFile.txt" + Ex.ToString());
                mtbStatusDynamicRodMessage.Text = "Error in move DR. See ErrorFile.txt";

            }


        }

        private void metroButton12_Click(object sender, EventArgs e)
        {


            try
            {
                double lastepsIn = 0.0;
                int laSteps = 0;
                string laStepsStr;
                double.TryParse(mtbDynamicRodStatus.Text, out lastepsIn);

                laSteps = (int)lastepsIn;

                laStepsStr = laSteps.ToString();
                if (laSteps > 10000)
                {
                    laStepsStr = "10000";
                }

                string stepCommand;

                stepCommand = "D" + laStepsStr + "R\r";

                //send string to control stepper motor
                int movec = Properties.Settings.Default.DMC;
                int holdc = Properties.Settings.Default.DHC;


                string command1 = "/1aM4m" + movec.ToString() + "h" + holdc.ToString();
                string command2 = command1 + stepCommand;

                mtbDROutput.Text = "Moving DR Rev:  " + laStepsStr;
                mtbDROutput.Refresh();
                if (laSteps != 0)
                {
                    SerialManager.WriteSerialPort(command2);  //move until the sensor is interrupted

                    //Thread.Sleep(9500);

                }

                //int position;
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                //int returnVal27 = AcquisitionControl.CheckMotorPosition(SerialManager, 4, out position);
                //check for stable position read 
                int position = 0;
                position = AcquisitionControl.PollMotorPosition(4, SerialManager);

                //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                //int posOld = 0;
                //int posNew = 1;
                //int retv = FAIL;
                //int counter = 0;
                //do
                //{
                //    retv = AcquisitionControl.CheckMotorPosition(SerialManager, 4, out position);
                //    if (retv == PASS)
                //    {
                //        posNew = position;
                //    }

                //    if (posNew == posOld)
                //    {
                //        break;
                //    }

                //    posOld = posNew;
                //    counter++;
                //    Thread.Sleep(500);
                //} while (counter < 60);




                //Logger.WriteLogFile(   "EC " + "init" + " (destination) motor position, after home = " + position.ToString());
                mtbDROutput.Text = "Dynamic Rod now at position:  " + position.ToString();
                mtbStatusDynamicRodMessage.Text = "Dynamic Rod now at position:  " + position.ToString();

            }
            catch (Exception Ex)
            {
                Logger.WriteErrorFile("Error in move DR Rev.  See ErrorFile.txt" + Ex.ToString());
                Logger.WriteLogFile("Error in move DR Rev.  See ErrorFile.txt" + Ex.ToString());
                mtbStatusDynamicRodMessage.Text = "Error in move DR. See ErrorFile.txt";

            }

        }

        private void mbFilterWheelAdvance_Click(object sender, EventArgs e)
        {
            //todo move and hold current in string
            try
            {
                //mtbFilterWheelMove
                double fwaStepsIn = 0.0;
                int fwSteps = 0;
                string fwStepsStr=String.Empty;
                string valueString = mtbFilterWheelMove.Text;

                bool isValid = valueString.All(char.IsDigit);
                if (isValid==false)
                {
                    mtbStatusFilterWheelMessage.Text = "Invalid move string:" + valueString;

                }

                if (valueString.Contains("@"))
                {
                    valueString = valueString.Replace("@", "");
                }

                bool retVal = double.TryParse(mtbFilterWheelMove.Text, out fwaStepsIn);


                fwSteps = (int)fwaStepsIn;
                fwStepsStr = fwSteps.ToString();
                if (fwSteps > 10000)
                {
                    fwStepsStr = "10000";
                }
                string stepCommand;

                stepCommand = "P" + fwStepsStr + "R\r";

                int movec = Properties.Settings.Default.FWMC;
                int holdc = Properties.Settings.Default.FWHC;


                string command = "/1aM1m"+movec.ToString()+"h"+holdc.ToString();
                string command2 = command + stepCommand;

                mtbFWOutput.Text = "Moving FW Fwd:  " + fwStepsStr;
                mtbFWOutput.Refresh();
                if (fwSteps != 0)
                {
                    SerialManager.WriteSerialPort(command2);
                    //Thread.Sleep(500);
                }
                //confirm position
                //int position;
                //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                //int returnVal27 = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);


                //check for stable position read 
                int position = 0;
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                position = AcquisitionControl.PollMotorPosition(1, SerialManager);

                //int posOld = 0;
                //int posNew = 1;
                //int retv =FAIL;
                //int counter = 0;
                //do
                //{
                //    retv = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);
                //    if(retv==PASS)
                //    {
                //        posNew = position;
                //    }

                //    if(posNew==posOld)
                //    {
                //        break;
                //    }

                //    posOld = posNew;
                //    counter++;
                //    Thread.Sleep(500);
                //} while (counter<60);



                mtbFWOutput.Text = "Filter wheel now at position  " + position.ToString();
                mtbStatusFilterWheelMessage.Text = "Filter wheel now at position  " + position.ToString();
            }
            catch (Exception Ex)
            {
                Logger.WriteErrorFile("Error in move FW fwd.  See ErrorFile.txt" + Ex.ToString());
                Logger.WriteLogFile("Error in move FW fwd.  See ErrorFile.txt ");

                mtbStatusFilterWheelMessage.Text = "Error in move FW  See ErrorFile.txt";
            }


        }

        private void mbFilterWheelReverse_Click(object sender, EventArgs e)
        {

            try
            {
                double fwaStepsIn = 0.0;
                int fwSteps = 0;
                string fwStepsStr;
                double.TryParse(mtbFilterWheelMove.Text, out fwaStepsIn);

                fwSteps = (int)fwaStepsIn;
                fwStepsStr = fwSteps.ToString();

                if(fwSteps>10000)
                {
                    fwStepsStr = "10000";
                }
                string stepCommand;

                stepCommand = "D" + fwStepsStr + "R\r";

                //send string to control stepper motor

                int movec = Properties.Settings.Default.FWMC;
                int holdc = Properties.Settings.Default.FWHC;


                string command = "/1aM1m"+movec.ToString()+"h"+holdc.ToString();
                string command2 = command + stepCommand;

                mtbFWOutput.Text = "Moving FW Rev:  " + fwStepsStr;
                mtbFWOutput.Refresh();
                if (fwSteps != 0)
                {
                    SerialManager.WriteSerialPort(command2);  //move until the sensor is interrupted

                    Thread.Sleep(500);
                }
                //confirm position
                //int position;
                //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                //int returnVal27 = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);
                //Logger.WriteLogFile(   "EC " + "init" + " (destination) motor position, after home = " + position.ToString());




                //check for stable position read 
                int position = 0;
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                position = AcquisitionControl.PollMotorPosition(1, SerialManager);

                //int posOld = 0;
                //int posNew = 0;
                //int retv = FAIL;
                //int counter = 0;
                //do
                //{
                //    retv = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);
                //    if (retv == PASS)
                //    {
                //        posNew = position;
                //    }

                //    if (posNew == posOld)
                //    {
                //        break;
                //    }

                //    posOld = posNew;
                //    counter++;
                //    Thread.Sleep(500);
                //} while (counter < 60);






                mtbFWOutput.Text = "Filter wheel now at position:  " + position.ToString();
                mtbStatusFilterWheelMessage.Text = "Filter wheel now at position:  " + position.ToString();
            }
            catch (Exception Ex)
            {
                Logger.WriteErrorFile("Error in move FW rev.  See ErrorFile.txt" + Ex.ToString());
                Logger.WriteLogFile("Error in move FW rev.  See ErrorFile.txt");
                mtbStatusFilterWheelMessage.Text = "Error in move FW rev   See ErrorFile.txt";
            }



        }

        private void mbMoveTapeHalf_Click(object sender, EventArgs e)
        {

            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;


            int retVal = FAIL;
            int count = 0;
            do
            {
                retVal = AcquisitionControl.MoveTapeHalf(SerialManager, this);
                count++;
            } while (retVal != PASS && count < 2);



        }

        private void mbMoveTapeFull_Click(object sender, EventArgs e)
        {

            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;


            //AcquisitionControl.MoveTapeFull(SerialManager, this );



            int retVal = FAIL;
            int count = 0;
            do
            {
                retVal = AcquisitionControl.MoveTapeFull(SerialManager, this);
                count++;
            } while (retVal != PASS && count < 2);

            //return values are 1=PASS 0=FAIL (tape related) 2=FAIL_NOZZLE limits

        }


        private int VerifyECTimes(int ec1Percent, int ec2Percent, int ec3Percent, int ec4Percent)
        {
            string message;
            string title;
            MessageBoxButtons buttons;// = MessageBoxButtons.YesNo;
            int returnValue = FAIL;

            bool displayDialog = false;

            int total = ec1Percent + ec2Percent + ec3Percent + ec4Percent;
            try
            {
                if (ec1Percent > 100 || ec1Percent < 0)
                {
                    title = "  Invalid ec1 percent value:  "+ec1Percent.ToString()+"  ";
                    message = " Valid range [0-100] ";
                    displayDialog = true;
                    buttons = MessageBoxButtons.OK;


                }
                else if (ec2Percent > 100 || ec2Percent < 0)
                {
                    title = "  Invalid ec2 percent value:  "+ec2Percent.ToString() + "  ";
                    message = " Valid range [0-100] ";
                    displayDialog = true;
                    buttons = MessageBoxButtons.OK;
                }
                else if (ec3Percent > 100 || ec3Percent < 0)
                {
                    title = "  Invalid ec3 percent value:  "+ec3Percent.ToString() + "  ";
                    message = " Valid range [0-100 ] ";
                    displayDialog = true;
                    buttons = MessageBoxButtons.OK;
                }

                else if (ec4Percent > 100 || ec4Percent < 0)
                {
                    title = "  Invalid ec4 percent value:  "+ec4Percent.ToString() + "  ";
                    message = " Valid range [0-100] ";
                    displayDialog = true;
                    buttons = MessageBoxButtons.OK;
                }
                else if (total > 100 || total <0 || total <100 )
                {
                    title = "  Invalid total percent value:  "+total.ToString()+"  ";
                    message = "Valid total is 100";
                    displayDialog = true;
                    buttons = MessageBoxButtons.OK;
                }


                else
                {

                    displayDialog = false;
                    returnValue = PASS;
                    message = string.Empty;
                    title = string.Empty;
                    buttons = MessageBoxButtons.OK;
                    returnValue = PASS;
                }



                if (displayDialog == true)
                {
                    DialogResult result = MetroMessageBox.Show(this,message, title, buttons, MessageBoxIcon.Warning);

                    if (result == DialogResult.OK)

                    {

                        //DialogResult.

                    }
                    //else if (result == DialogResult.Retry)

                    //{

                    //    // Do nothing

                    //}

                    //else

                    //{

                    //    // Do something

                    //}
                    returnValue = FAIL;
                }
            }
            catch (Exception Ex)
            {
                Logger.WriteErrorFile("  Error in Verify Percent Times.  Error = " + Ex.ToString()+"  ");
                    DialogResult result = MetroMessageBox.Show(this,Ex.ToString(),"Error in Verify Percent Times", MessageBoxButtons.OK, MessageBoxIcon.Warning);

                    if (result == DialogResult.OK)

                    {

                        //DialogResult.

                    }


            }



            return returnValue;


        }


        private int VerifykVuA(double targetkV, double targetuA, string optionalCheckIdentifier = "")
        {
            string message;
            string title;
            MessageBoxButtons buttons;// = MessageBoxButtons.YesNo;
            int returnValue = FAIL;

            bool displayDialog = false;


            try
            {
                if (targetkV > 50.0)
                {
                    title = optionalCheckIdentifier + "Invalid kV value.";
                    message = "Target kV invalid.  Must be less than 50.0";
                    displayDialog = true;
                    buttons = MessageBoxButtons.OK;


                }
                else if (targetuA > 2000.0)
                {
                    title = optionalCheckIdentifier + "Invalid uA value.";
                    message = "Target uA invalid.  Must be less than 2000.0";
                    displayDialog = true;
                    buttons = MessageBoxButtons.OK;


                }
                else if (targetkV * targetuA > 50000.0)
                {

                    title = optionalCheckIdentifier + "Invalid kV and uA values.";
                    message = "Total watts must be less than 50.0 W";
                    displayDialog = true;
                    buttons = MessageBoxButtons.OK;


                }
                else
                {
                    
                    displayDialog = false;
                    returnValue = PASS;
                    message = string.Empty;
                    title = string.Empty;
                    buttons = MessageBoxButtons.OK;
                    returnValue = PASS;
                }



                if (displayDialog == true)
                {
                    DialogResult result = MessageBox.Show(message, title, buttons, MessageBoxIcon.Warning);

                    if (result == DialogResult.OK)

                    {

                        //DialogResult.

                    }
                    /*
                    else if (result == DialogResult.Retry)

                    {

                        // Do nothing

                    }

                    else

                    {

                        // Do something

                    }
                    */
                    returnValue = FAIL;
                }
            }
            catch(Exception Ex)
            {
                Logger.WriteInternalLogFile("Error:  in VerifykVuA.  Ex = " + Ex.ToString());
            }



            return returnValue;
        }


        /*
        private string EnterPassword()
        {
            string message;
            string title;
            MessageBoxButtons buttons;// = MessageBoxButtons.YesNo;
            int returnValue = FAIL;

            bool displayDialog = false;


            try
            {
                 title =  "System Access";
                 message = "Enter System Access Password";
                 displayDialog = true;
                 buttons = MessageBoxButtons.OKCancel;

                else
                {

                    displayDialog = false;
                    returnValue = PASS;
                    message = string.Empty;
                    title = string.Empty;
                    buttons = MessageBoxButtons.OK;
                    returnValue = PASS;
                }



                if (displayDialog == true)
                {
                    DialogResult result = MessageBox.Show(message, title, buttons, MessageBoxIcon.Warning);

                    if (result == DialogResult.OK)

                    {

                        //DialogResult.

                    }
                    
                    else if (result == DialogResult.Retry)

                    {

                        // Do nothing

                    }

                    else

                    {

                        // Do something

                    }
                    
                    returnValue = FAIL;
                }
            }
            catch (Exception Ex)
            {
                Logger.WriteErrorFile("Error in VerifykVuA.  Error = " + Ex.ToString());
            }



            return returnValue;
        }
    */




        private void mbRampToTarget_Click(object sender, EventArgs e)
        { //ramp to target



            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            int returnValue = FAIL;

            double targetVoltage = 0.0;
            try
            {
                Double.TryParse(mtbMaintenanceTargetkV.Text, out targetVoltage);
            }
            catch
            {
                targetVoltage = 0.0;
                mtbMaintenanceTargetkV.Text = "INVALID.";
            }

            //if (targetVoltage > 50.0)
           // {
           //     targetVoltage = 25.0;
           // }


            //read the text box for I
            double targetCurrent = 0.0;
            try
            {
                Double.TryParse(mtbMaintenanceTargetuA.Text, out targetCurrent);
            }
            catch
            {
                targetCurrent = 0.0;
            }
            //if (targetCurrent > 2000.0)
            //    targetCurrent = 1000.0;
            //read presentV (actual 'kV') from NI

            returnValue = VerifykVuA(targetVoltage, targetCurrent);


            if (returnValue == PASS)
            {

                // 1. read the actual tb:
                string sactualkV = "0.0";
                double dactualkV = 0.0;
                mtbActualkV.Invoke(new MethodInvoker(delegate { sactualkV = mtbActualkV.Text; }));
                dactualkV = Convert.ToDouble(sactualkV);





                double presentV = 0.0;
                presentV = readInputVoltage;
                presentV = presentV * 50.0 / 10.0;

                if (presentV == 0 && dactualkV > 0)
                {
                    presentV = dactualkV;
                    Logger.WriteInternalLogFile("using gui value for actual kv");
                }
                //write to GUI:
                //tbActualV.Text = presentV.ToString();

                //read presentI (actual i) from NI
                double presentI = 0.0;
                presentI = readInputCurrent;
                presentI = presentI * 2000.0 / 10.0;

                //////write to GUI:
                ////tbActualI.Text = presentI.ToString();


                if (presentV < 0)
                    presentV = 0.0;
                if (presentI < 0)
                    presentI = 0.0;


                int returnVal = AcquisitionControl.RampXrays(presentV, presentI, targetVoltage, targetCurrent, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
            }



        }

        private void mbAcquire_Click(object sender, EventArgs e)
        {
            //maint screen 

            try
            {




                float kV;
                string kVs;

                //tbCal.Invoke(new MethodInvoker(delegate { tbmetroCalEntry.Text = Tnistvalue.ToString(); }));//sets the value
                //string actualValue;
                mtbActualkV.Invoke(new MethodInvoker(delegate { actualValueV = mtbActualkV.Text; }));


                kVs = actualValueV;
                kV = Convert.ToSingle(kVs);

                bool boolresponse_kV = myxrsfp.Send_kV[kV];

                float uA;
                string uAs;


                mtbActualuA.Invoke(new MethodInvoker(delegate { actualValueI = mtbActualuA.Text; }));



                uAs = actualValueI;
                uA = Convert.ToSingle(uAs);

                bool boolresponse_uA = myxrsfp.Send_uA[uA];


                short v1 = myxrsfp.Acquire_Start;//  .Acquire_Spectrum;

                //int presetTime = myxrsfp.Get_Preset;
                //Thread.Sleep(presetTime * 1000);

                mtbXrsStatus.Text = "Manual acquire Started";
                mtbXrsStatus.Refresh();



            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Ex maintenance screen in Acq (manual) = " + Ex.ToString());
                mtbXrsStatus.Text = "Error in Manual Acquire";
                mtbXrsStatus.Refresh();
            }

        }

        private void mbEcal_Click(object sender, EventArgs e)
        {
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;


            float FGainReturn = 0f;
            float FOffsetReturn = 0f;
            bool result = AcquisitionControl.PerformEcal(out FGainReturn,out FOffsetReturn, "c:/temp/acquisition.txt");



            Logger.WriteLogFile(   "Perform Ecal return value = " + result.ToString());
            Logger.WriteLogFile(   "Perform Ecal return value = " + result.ToString());
            mtbXrsStatus.Text = "Ecal result = " + result.ToString();
            mtbXrsStatus.Refresh();
            Thread.Sleep(3000);
            mtbXrsStatus.Text = "Ecal Gain = " + FGainReturn.ToString("F2")+" Ecal Offset = "+FOffsetReturn.ToString("F2");

            AcquisitionControl.SaveCESSpectrumRaw("c:/Ecal_Data_Raw", "sp_data", 1);



        }

        private void mbSetPreset_Click(object sender, EventArgs e)
        {

            try
            {

                //test logic for com interface to xrsfp and spectra x
                string setPreset;
                setPreset = mtbSetPreset.Text;
                int isetPreset;
                isetPreset = Convert.ToInt32(setPreset);



                bool b1 = myxrsfp.Send_Preset[isetPreset];

                //check return value
                //int i1 = myxrsfp.Get_Preset;
                mtbXrsStatus.Text = "Preset time = " + isetPreset.ToString();
                mtbXrsStatus.Refresh();


                ///////////////////////////////////////////////////////////////////
                // hey I want to set this to 2, but I cant!
                //////////////////////////////////////////////////////////////////

                //    Int16 Value;
                //    Value = 2;  //00 zero doesnt work....  01 accumulation time
                //    var response = myxrsfp.Send_Preset_Mode[Value];


                //string pathFilename = "C:/temp/m1.tfr";


                //myxrsfp = new cMTFFPX();

                //var realTime = myxrsfp.Get_Realtime;
                //var value2 = 600;
                //var bret = false;




            }
            catch (Exception eX)
            {
                //int error = 1;
                mtbSetPreset.Text = eX.ToString();
                eX.ToString();

            }



        }

        private void metroButton9_Click_1(object sender, EventArgs e)
        {

            try
            {
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                int returnVal26 = AcquisitionControl.LoadMTFRFile(3);


                AcquisitionControl.SaveCESSpectrum("c:/spectrum_data", "sp_data", 3);
                AcquisitionControl.LoadCESSpectrum("c:/spectrum_data", "sp_data", 3);

                mtbXrsStatus.Text = ".tfr3 + cond 3 loaded";
                mtbXrsStatus.Refresh();


            }
            catch (Exception Ex)
            {
                Logger.WriteErrorFile("Error in maint. loadTFR 3 file and cond code 3: Ex = " + Ex.ToString());

                mtbXrsStatus.Text = ".tfr3 + cond 3 load FAIL";
                mtbXrsStatus.Refresh();
            }


        }

        private void mbLoadTFR1CondCode1_Click(object sender, EventArgs e)
        {

            try
            {
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                int returnVal26 = AcquisitionControl.LoadMTFRFile(1);

                AcquisitionControl.SaveCESSpectrum("c:/spectrum_data", "sp_data", 1);
                AcquisitionControl.LoadCESSpectrum("c:/spectrum_data", "sp_data", 1);
                mtbXrsStatus.Text = ".tfr1 + cond 1 loaded";
                mtbXrsStatus.Refresh();



            }
            catch (Exception Ex)
            {
                mtbXrsStatus.Text = ".tfr1 + cond 1 load FAIL";
                mtbXrsStatus.Refresh();
                Logger.WriteErrorFile("Error in maint. loadTFR 1 file and cond code 1: Ex = " + Ex.ToString());


            }
        }

        private void mbLoadTFR2CondCode2_Click(object sender, EventArgs e)
        {


            try
            {
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                int returnVal26 = AcquisitionControl.LoadMTFRFile(2);


                AcquisitionControl.SaveCESSpectrum("c:/spectrum_data", "sp_data", 2);
                AcquisitionControl.LoadCESSpectrum("c:/spectrum_data", "sp_data", 2);
                mtbXrsStatus.Text = ".tfr2 + cond 2 loaded";
                mtbXrsStatus.Refresh();



            }
            catch (Exception Ex)
            {
                mtbXrsStatus.Text = ".tfr2 + cond 2 load FAIL";
                mtbXrsStatus.Refresh();
                Logger.WriteErrorFile("Error maint. in loadTFR 2 file and cond code 2: Ex = " + Ex.ToString());


            }
        }

        private void metroPanel20_Paint(object sender, PaintEventArgs e)
        {

        }

        private void mbAutoAnalyze_Click(object sender, EventArgs e)
        {

            try
            {
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;


                int returnVal26 = AcquisitionControl.AutoAnalyze();
                mtbXrsStatus.Text = "AutoAnalyze result = " + returnVal26.ToString();
                mtbXrsStatus.Refresh();

            }
            catch (Exception Ex)
            {
                Logger.WriteErrorFile("Error in maint. auto analyze: Ex = " + Ex.ToString());

            }

        }

        private void mbAdjustSpectra_Click(object sender, EventArgs e)
        {
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            int result = AcquisitionControl.AdjustSpectrum();
            Logger.WriteLogFile(   "AdjustSpectrum return value = " + result.ToString());

            mtbXrsStatus.Text = "Adj spec result = " + result.ToString();
            mtbXrsStatus.Refresh();
            AcquisitionControl.SaveCESSpectrum("c:/Temp/Data.ces", "sp_data", 1);




        }

        private void mbApplyEcalAndSave_Click(object sender, EventArgs e)
        {

            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            int result = AcquisitionControl.AdjustSpectrum();
            Logger.WriteLogFile(   "AdjustSpectrum return value = " + result.ToString());


            bool filesavesuccess = myxrsfp.Save_CES_Spectrum_File[mtbSpectrumPathFilename.Text];
            mtbXrsStatus.Text = "Save .ces result =" + filesavesuccess.ToString();
            mtbXrsStatus.Refresh();

        }

        private void metroButton2_Click(object sender, EventArgs e)
        {





            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            int sampleTimeValue = Properties.Settings.Default.SampleTime;
            AcquisitionControl.SetSamplePeriod(sampleTimeValue);


            try
            {
                BackgroundManager.m_oWorkerAcq.RunWorkerAsync();
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error Run acq thread.   Ex = " + Ex.ToString());
            }

        }


        /// <summary>
        /// Run click Provides input for either Run or Stop
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mbRun_Click(object sender, EventArgs e)
        {
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            //AcquisitionControl.AdjustSpectrum();




            if (mbRun.Text.Contains("Run"))
            {
                //static variable "RunStateSet"
                DateTimeFromStartButton = DateTime.Now;
                DateTimeFromStartButtonInternalLog = DateTime.Now;
                DateTimeFromStartButtonErrorLog = DateTime.Now;
                DateTimeFromStartButtonWarningLog = DateTime.Now;

                //SetActiveNormalECs();

                //ADD CLEAR OF MODBUS ALARM:  1.2.0.48
                ClearModbusAlarm();

                runState = 1;

                HaltEnabled = 1;

                DataContainer.StatusDisplayErrorMessage = String.Empty;
                DataContainer.StatusDisplayWarningMessage = String.Empty;


                mtbStatusOperation.Text = "Run Pressed.  Beginning Sample.";
                Logger.WriteLogFile(   "Run button pressed.");
                //mbRun.BackColor = Color.Green;
                metroStatusButton.BackColor = Color.Green;

                mbRun.Text = "Stop";
                RunPressed = DateTime.Now;

                try
                {
                    BackgroundManager.m_oWorkerAcq.RunWorkerAsync();
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error:  Run acq thread.  Ex = " + Ex.ToString());
                }

            }
            else
            {

                //pop up confirmation
                //FlexibleMessageBox.FONT = SystemFonts.MenuFont;

                //DialogResult dialogResult = FlexibleMessageBox.Show("Are you sure you want to stop?",
                //        "Confirm Stop Pressed",
                //        MessageBoxButtons.YesNo,
                //        MessageBoxIcon.Exclamation,
                //        MessageBoxDefaultButton.Button1
                //        );

                DialogResult dialogResult = MetroMessageBox.Show(this, "Are you sure you want to stop?", "Confirm Stop Pressed", MessageBoxButtons.YesNo, MessageBoxIcon.Warning, MessageBoxDefaultButton.Button1 /*,height=250*/);


                //DialogResult dialogResult = MessageBox.Show("Are you sure you want to Stop?", "Confirm Stop Pressed", MessageBoxButtons.YesNo,MessageBoxIcon.Exclamation,MessageBoxDefaultButton.Button1 );
                if (dialogResult == DialogResult.Yes)
                {
                    //do something


                    runState = 0;
                    //static Variable = "RunStateCleared"
                    mbRun.Text = "Run";
                    mtbStatusOperation.Text = "Stop Pressed.  Stopping Acquisition.";
                    Logger.WriteLogFile(   "STOP pressed");
                    //Warning("Stop Button Pressed.");
                    //mbRun.BackColor = Color.Gray;
                    metroStatusButton.BackColor = Color.Gray;
                    BackgroundManager.m_oWorkerAcq.CancelAsync();
                    AcquisitionControl.StopXrsfpAcquisition();
                    RampXraysToZero();
                    //add clear of modbus error (address 800)
                    ClearModbusAlarm();

                    try
                    {
                        if (BackgroundManager.m_oWorkerTubeSeasoning.IsBusy)
                        {
                            BackgroundManager.m_oWorkerTubeSeasoning.CancelAsync();
                        }

                    }
                    catch (Exception Ex)
                    {
                        Logger.WriteInternalLogFile("Tube seasoning stop Ex = "+Ex.ToString());
                    }


                }
            }

            //3 happens here:   m_oWorkerAcq_DoWork

            //starts timer on background thread
            //acquisition control called each 1 second:  onacqtimedevent 


            //test logic:


            //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            //rb15min.Invoke(new MethodInvoker(delegate { rb15 = rb15min.Checked; }));
            //rb30min.Invoke(new MethodInvoker(delegate { rb30 = rb30min.Checked; }));
            //rb60min.Invoke(new MethodInvoker(delegate { rb60 = rb60min.Checked; }));
            //if (rb15 == true)
            //{
            //    AcquisitionControl.SetSamplePeriod(15);
            //}
            //else if (rb30 == true)
            //{
            //    AcquisitionControl.SetSamplePeriod(30);
            //}
            //else if (rb60 == true)
            //{
            //    AcquisitionControl.SetSamplePeriod(60);
            //}


            //try
            //{
            //    BackgroundManager.m_oWorkerAcq.RunWorkerAsync();
            //}
            //catch (Exception Ex)
            //{
            //    Logger.WriteErrorFile("Run acq thread Ex = " + Ex.ToString());
            //}


        }

        public void HaltUpscale(string reason)
        {
            runState = 0;
            UpdateMaintCheckMessage("Manual Upscale Stop:  " + reason);
            BackgroundManager.m_oWorkerUpscale.CancelAsync();
            Logger.WriteLogFile( "Manual Upscale Stop.  " + reason, "c:/temp/ManualUpscale.txt");
            Logger.WriteErrorFile("Manual Upscale Stop:  " + reason);

        }



        //public void HaltEcal(string reason)
        //{
        //    runState = 0;
        //    UpdateMaintCheckMessage( "Manual Ecal Stop:  " + reason);
        //    BackgroundManager.m_oWorkerEcal.CancelAsync();
        //    Logger.WriteLogFile("c:/temp/ManualEcal.txt", "Manual Ecal Stop.  " + reason);
        //    Logger.WriteErrorFile("Manual Ecal Stop:  " + reason);

        //}
        public void HaltManualAcq(string reason)
        {
            runState = 0;
            UpdateMaintCheckMessage("Manual Acq Stop:  " + reason);
            
            BackgroundManager.m_oWorkerManualAcq.CancelAsync();


            Logger.WriteLogFile( "Manual Acq Stop.  " + reason, "c:/temp/ManualAcq.txt");
            Logger.WriteErrorFile("Manual Acq Stop:  " + reason);

        }




        public void HaltLeakCheck(string reason)
        {
            runState = 0;

            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            AcquisitionControl.StopXrsfpAcquisition();

            UpdateFlowCalPromptMessage("Leak Check Stop:  " + reason);

            BackgroundManager.m_oLeakCheck.CancelAsync();


            Logger.WriteLogFile( "Leak Check Stop.  Reason: " + reason, "c:/temp/LeakCheck.txt");
            Logger.WriteErrorFile("Leak Check Stop:  " + reason);

        }




        //
        // this is called from the tube seasoning background thread
        //
        /// <summary>
        /// Logs Error and Halts system
        /// </summary>
        /// <param name="reason"></param>
        public void HaltTubeSeasoning(string reason)
        {
            runState = 0;
            UpdateMaintCheckMessage(reason);
            
            //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            //AcquisitionControl.StopXrsfpAcquisition();


            BackgroundManager.m_oWorkerTubeSeasoning.CancelAsync();
            m_oWorkerRamp.CancelAsync();  //stop the 
            Logger.WriteInternalLogFile("Tube Seasoning Stop. " + reason);
            Logger.WriteErrorFile("Error:  Tube Seasoning Stop.  " + reason);
            Logger.WriteLogFile("Error:  Tube Seasoning Stop.  " + reason);

            //ramp xrays to zero





        }



        //
        // this is called from the acquisition background thread
        //
        /// <summary>
        /// Logs Error and Halts system
        /// </summary>
        /// <param name="reason"></param>
        public void Halt(string reason)
        {


            if (HaltEnabled == 1)
            {
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                AcquisitionControl.StopXrsfpAcquisition();

                runState = 0;
                if (InvokeRequired)
                {
                    mbRun.Invoke(new MethodInvoker(delegate { mbRun.Text = "Run"; }));
                    mtbStatusOperation.Invoke(new MethodInvoker(delegate { mtbStatusOperation.Text = "System Stop. " + reason; }));
                    metroStatusButton.Invoke(new MethodInvoker(delegate { metroStatusButton.BackColor = Color.Red; }));

                }
                else
                {
                    mbRun.Text = "Run";
                    mtbStatusOperation.Text = "System Stop.  " + reason;
                    metroStatusButton.BackColor = Color.Red;

                }

                try
                {
                    BackgroundManager.m_oWorkerAcq.CancelAsync();
                }
                catch
                {
                }
                /*
                try
                {
                    BackgroundManager.m_oWorkerManualAcq.CancelAsync();
                }
                catch
                {
                }
                */
                try
                {
                    if (BackgroundManager.m_oWorkerTubeSeasoning.IsBusy)
                    {
                        BackgroundManager.m_oWorkerTubeSeasoning.CancelAsync();
                    }
                }
                catch
                {
                }
                /*
                try
                {
                    BackgroundManager.m_oWorkerEcal.CancelAsync();
                }
                catch
                {
                }
                try
                {
                    BackgroundManager.m_oWorkerUpscale.CancelAsync();
                }
                catch
                {
                }
                try
                {
                    BackgroundManager.m_oLeakCheck.CancelAsync();
                }
                catch
                {
                }
                */
                /*
                try
                {
                    m_oWorkerRamp.CancelAsync();
                }
                catch
                {
                }
                */

                Thread.Sleep(2000);

                try
                {
                    double rate = 0.5;//update every half second

                    //read presentV (actual 'kV') from NI
                    double presentV = 0.0;
                    presentV = readInputVoltage;
                    presentV = presentV * 50.0 / 10.0;

                    //ActualV.Text = presentV.ToString();
                    presentV = Math.Round(presentV, 2, MidpointRounding.AwayFromZero);


                    //read presentI (actual i) from NI
                    double presentI = 0.0;
                    presentI = readInputCurrent;
                    presentI = presentI * 2000.0 / 10.0;
                    presentI = Math.Round(presentI, 2, MidpointRounding.AwayFromZero);
                    int time = 3;
                    List<double> VoltageValuesShutdown = new List<double>();
                    List<double> CurrentValuesShutdown = new List<double>();

                    calcLinearRampVoltageShutdown(presentV, 0.0, time, 0.5, VoltageValuesShutdown);   //present v, target v, time to transition, output rate per second
                    calcLinearRampCurrentShutdown(presentI, 0.0, time, 0.5, CurrentValuesShutdown);   //present i, target i, time to transition, output rate per second

                    if (presentV > 0 || presentI > 0)
                    {
                        xrayOnCommand = 0;  //prevent interlock toggle.
                        //UpdateOperationMessage("Shutting down:  ramp down X-rays");
                        // Logger.WriteLogFile("c:/temp/shutdown.txt", "Pausing shutdown to ramp down xrays...");
                        // returnVal = AcquisitionControl.RampXrays(presentV, presentI, 0.0, 0.0, m_oWorkerRamp, LinearRampValuesVoltage, LinearRampValuesCurrent, this);
                        ShutdownXrayRamp(VoltageValuesShutdown, CurrentValuesShutdown, rate);


                        if (mtbInterlockStatus.InvokeRequired)
                        {
                            mtbInterlockStatus.Invoke(new MethodInvoker(delegate { mtbInterlockStatus.Text = "OPEN"; }));

                        }
                        else
                        {
                            mtbInterlockStatus.Text = "OPEN";
                        }


                    }
                    HaltEnabled = 0;
                }
                catch (Exception Ex)
                {
                    Logger.WriteErrorFile("Error in halt function!  Ex =" + Ex.ToString());
                    if (InvokeRequired)
                    {
                        mtbStatusOperation.Invoke(new MethodInvoker(delegate { mtbStatusOperation.Text = "Error in Halt! " + reason; }));
                        metroStatusButton.Invoke(new MethodInvoker(delegate { metroStatusButton.BackColor = Color.Red; }));

                    }
                    else
                    {
                        mbRun.Text = "Run";
                        mtbStatusOperation.Text = "Error in Halt. " + reason;
                        metroStatusButton.BackColor = Color.Red;

                    }
                }

            }
            Logger.WriteLogFile("System Stop.  " + reason);
            Logger.WriteErrorFile("Error:  System Stop.  " + reason);
            Logger.WriteLogFile("Error:  System Stop.  " + reason);

            /*
            runState = 0;
            if (InvokeRequired)
            {
                mbRun.Invoke(new MethodInvoker(delegate { mbRun.Text = "Run"; }));
                mtbStatusOperation.Invoke(new MethodInvoker(delegate { mtbStatusOperation.Text = "System Stop. " + reason; }));
                metroStatusButton.Invoke(new MethodInvoker(delegate { metroStatusButton.BackColor = Color.Red; }));

            }
            else
            {
                mbRun.Text = "Run";
                mtbStatusOperation.Text = "System Stop.  " + reason;
                metroStatusButton.BackColor = Color.Red;

            }
            BackgroundManager.m_oWorkerAcq.CancelAsync();
            m_oWorkerRamp.CancelAsync();   
            Logger.WriteLogFile(   "System Stop.  " + reason);
            Logger.WriteErrorFile("Error:  System Stop.  " + reason);

            //ramp xrays to zero
            */

        }




        //
        // this is called from the acquisition background thread
        //
        public void HaltManualEcal(string reason)
        {
            try
            {
                runState = 0;
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                AcquisitionControl.StopXrsfpAcquisition();

                //if (InvokeRequired)
                //{
                //    //mbRun.Invoke(new MethodInvoker(delegate { mbRun.Text = "Run"; }));
                //    //mtbStatusOperation.Invoke(new MethodInvoker(delegate { mtbStatusOperation.Text = "System Stop. " + reason; }));
                //    //metroStatusButton.Invoke(new MethodInvoker(delegate { metroStatusButton.BackColor = Color.Red; }));

                //}
                //else
                //{
                //    mbRun.Text = "Run";
                //    mtbStatusOperation.Text = "System Stop.  " + reason;
                //    metroStatusButton.BackColor = Color.Red;

                //}
                if (BackgroundManager.m_oWorkerEcal.IsBusy)
                {
                    BackgroundManager.m_oWorkerEcal.CancelAsync();
                }

                //m_oWorkerRamp.CancelAsync();  
                Logger.WriteLogFile( "System Stop.  " + reason, "c:/temp/ManualEcal.txt");
                Logger.WriteErrorFile("Error:  Manual Ecal System Stop.  " + reason);
                //UpdateFilterWheelMessage()
                //IOReadAndDisplayGUITimer.Stop();
            }
            catch (Exception Ex)
            {
                Logger.WriteLogFile( "Ex in manual ecal.  Ex = " + Ex.ToString(), "c:/temp/ManualEcal.txt");
            }

            //
            // add functional call to end writes to error file and acquisition log files
            //
            //Thread.Sleep(7500);
            //Logger.wrapUpLog();



        }





        /*
        public void wrapUpLog()
        {

            string newFileName;
            try
            {
                newFileName = "c:/temp/acquisition_" + DateTime.Now.ToString("MM_dd_yyyy__HH_mm") + ".txt";
                System.IO.File.Move(   newFileName);
                newFileName = "c:/temp/ErrorFile_" + DateTime.Now.ToString("MM_dd_yyyy__HH_mm") + ".txt";
                System.IO.File.Move("c:/temp/ErrorFile.txt", newFileName);
            }
            catch (Exception Ex)
            {
                Logger.WriteErrorFile("unable to reset error and log files.  Ex = " + Ex.ToString());
            }

        }
        */


        /// <summary>
        /// 
        /// </summary>
        /// <param name="alarmValue"></param>
        //public void SetAlarmValue(int alarmValue)
        //{
        //    alarmCode = alarmValue;
        //}
        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        //public int GetAlarmValue()
        //{
        //    return alarmCode;
        //}
        public void WriteAlarmToModbus(int code)
        {
            Logger.WriteLogFile(   "Writing alarm code " + code.ToString() + " to Modbus addr 800");
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            DataStore xactHoldingRegisters = AcquisitionControl.getDataStore();

            ushort[] oneValue = new ushort[1] { (ushort)code };
            nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, oneValue, 800);
        }
        public void ClearModbusAlarm()
        {
            int code;
            code = 0;
            Logger.WriteLogFile(   "Clear Modbus alarm code.  Writing  zero to Modbus addr 800");
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            DataStore xactHoldingRegisters = AcquisitionControl.getDataStore();

            ushort[] oneValue = new ushort[1] { (ushort)code };
            nModbusOperations.updateModbusSlaveRegisters(xactHoldingRegisters, oneValue, 800);
        }



        public void Warning(string reason)
        {

            if (InvokeRequired)
            {

                mtbStatusOperation.Invoke(new MethodInvoker(delegate { mtbStatusOperation.Text = "Warning:  " + reason; }));
                metroStatusButton.Invoke(new MethodInvoker(delegate { metroStatusButton.BackColor = Color.Yellow; }));

            }
            else
            {
                mtbStatusOperation.Text = "Warning:  " + reason;
                metroStatusButton.BackColor = Color.Yellow;
                    

            }
            Logger.WriteWarningFile( "Warning:  " + reason);
            Logger.WriteLogFile( "Warning:  " + reason);

            
        }

        private void mbPumpOn_Click(object sender, EventArgs e)
        {

            // require selected pump speed



            if (mbPumpOn.Text.Contains("On"))
            {
                if (rbMetro150.Checked == false && rbMetro167.Checked == false && rbMetro184.Checked == false)
                {

                    tbMetroCalPrompt.Text = String.Empty;
                    Thread.Sleep(1000);
                    tbMetroCalPrompt.Text = "Select Pump Speed";

                }
                else
                {
                    metroToggleFlowCal.Enabled= true;

                    tbMetroCalPrompt.Text = "";
                    mbPumpOn.Text = "Pump Off";
                    AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                    AcquisitionControl.PumpOn(m_oWorkerPump);
                }


            }
            else if (mbPumpOn.Text.Contains("Off"))
            {

                metroToggleFlowCal.CheckState = System.Windows.Forms.CheckState.Unchecked;
                metroToggleFlowCal.Refresh();
                metroToggleFlowCal.Enabled = false;

                tbMetroCalPrompt.Text = "Turning Pump Off";

                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
                AcquisitionControl.PumpOff(m_oWorkerPump);
                tbMetroCalPrompt.Text = "Pump Off";
                mbPumpOn.Text = "Pump On";
                //Thread.Sleep(1000);
                //clear pump flow text boxes
                mtbFlow25.Text = String.Empty;
                mtbFlowAct.Text = String.Empty;
                mtbFlowStd.Text = String.Empty;
                mtbPumpError.Text = String.Empty;
                mtbPumpRunPercent.Text = String.Empty;


            }



        }


        ////move to 1
        //AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
        //AcquisitionControl.MoveFWHome(SerialManager, this);
        //    AcquisitionControl.MoveFWEC(SerialManager, 0, 1, this);

/*
        private void metroButton32_Click(object sender, EventArgs e)
        {
            //move to 1
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            int retVal=AcquisitionControl.MoveFWHome(SerialManager, this);
            if (retVal == PASS)
            {

                AcquisitionControl.MoveFWEC(SerialManager, 0, 1, this);
            }
            else
            {
                UpdateFilterWheelMessage("Error:  Filter wheel home function.");
            }
        }
*/
        private void bMetroEnterDataButton_Click(object sender, EventArgs e)
        {
            //  enter pressed
            enterDataButtonClicked = true;

        }

        private void metroButton5_Click(object sender, EventArgs e)
        {

            //interlock manual open

            //InterlockOpen();
            //try
            //{
            //    ToggleInterlockTimer.Stop();
            //    ToggleInterlockTimer.Dispose();
            //}
            //catch
            //{

            //}

            xrayOnCommand = 0;
            
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            AcquisitionControl.InterlockOpen(this);


            if (mbRun.Text == "Stop") //system Running
            {
                Logger.WriteLogFile(   "Maintenance Tab:  manual OPEN interlock during run!");

            }
            //}
            //else
            //{
              
            //}




        }

        private void metroButton6_Click_1(object sender, EventArgs e)
        {
            //interlock manual closed
            //InterlockClose();
            //StartInterlockToggleTimer();


            xrayOnCommand = 1;  

            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            AcquisitionControl.InterlockClose(this);

            if (mbRun.Text == "Stop") //system Running
            {
                Logger.WriteLogFile(   "Maintenance Tab:  manual CLOSE interlock during run!");

            }
            //}
            //else
            //{

            //}



        }

        private void metroPanel19_Paint(object sender, PaintEventArgs e)
        {

        }

        private void metroLabel84_Click(object sender, EventArgs e)
        {

        }

        private void metroButton7_Click_1(object sender, EventArgs e)
        {
            //ON
            DigitalSingleChannelWriter Port30writer = new DigitalSingleChannelWriter(InletHeaterOutput.Stream);
#if TURNON_NIHARDWARE
            Port30writer.WriteSingleSampleSingleLine(true, true);
#endif


        }

        private void metroButton8_Click(object sender, EventArgs e)
        {

            //OFF
            DigitalSingleChannelWriter Port30writer = new DigitalSingleChannelWriter(InletHeaterOutput.Stream);
#if TURNON_NIHARDWARE
            Port30writer.WriteSingleSampleSingleLine(true, false);
#endif

        }

        private void metroButton1_Click(object sender, EventArgs e)
        { // find way back through the data



            try
            {
                mtbDataOutputMessage.Text = "";
                mtbDataOutputMessage.Refresh();
                rtbData.Clear();



                //get start time
                DateTime Start = mdtStart.Value;

                //get end time
                DateTime End = mdtEnd.Value;

                var directory = new DirectoryInfo("c:/process_data/");
                DateTime from_date = Start;
                DateTime to_date = End.AddDays(1);

                var fileList = directory.GetFiles()
                    .Where(fileVal => fileVal.LastWriteTime >= from_date && fileVal.LastWriteTime <= to_date)
                    .OrderByDescending(d => d.CreationTime)
                    .ToList();


                filesToParse.Clear();

                foreach (var fileName in fileList)
                {
                    if (fileName.Name.Contains("data1"))
                    {
                        continue;
                    }
                    else if (fileName.Name.Contains("data2"))
                    {
                        continue;
                    }
                    else if (fileName.Name.Contains("data3"))
                    {
                        continue;
                    }
                    else
                    {
                        filesToParse.Add(fileName.Name);
                    }
                }


                filesToParseIndex += 1;
                if (filesToParseIndex >= filesToParse.Count() - 1)
                {
                    filesToParseIndex = filesToParse.Count() - 1;
                }

                string value = filesToParse[filesToParseIndex];


                //                filesToParseIndex -= 1;
                //                if (filesToParseIndex <= 0)
                //                {
                //                    filesToParseIndex = 0;
                //                }
                //string value = filesToParse[filesToParseIndex];
                string path = "c:/process_data/";

                //System.IO.StreamReader sr = new System.IO.StreamReader(path + value);


                //string fTextTemp = sr.ReadToEnd();

                //string fText = AdjustTitleDisplayData(fTextTemp);

                //System.IO.StreamReader sr = new System.IO.StreamReader(path + value);

                string[] logFile = File.ReadAllLines(path + value);

                List<string> logList = new List<string>(logFile);

                List<string> temp = new List<string>();

                temp = AdjustDataForDisplay(logList);


                string fText = string.Empty;
                foreach (string s in temp)
                {
                    fText = fText + s;
                }


                //string fTextTemp = sr.ReadToEnd();


                //string fText = AdjustDisplayData(fTextTemp);

                //var logList = new List<string>(fText);




                rtbData.SelectionStart = 0;  // or wherever you want to insert in this rtb
                rtbData.SelectionLength = 0;
                //rtbData.SelectionFont = new System.Drawing.Font("Tahoma", 14);
                //rtbData.SelectionFont = new System.Drawing.Font("TimesNewRoman", 10);
                rtbData.SelectionFont = new System.Drawing.Font("Consolas", 10);
                rtbData.SelectedText = fText;





                //dataGridView1.= fText;
                //DataTable dt = GetDataTable(txtFileName.Text);
                //dataGridView1.DataSource = dt.DefaultView;

                //sr.Close();


                //for data tab test
                try
                {
                    //dataGridView1.DataSource = ReadCsv(path + value);
                }
                catch //(Exception Ex)
                {

                }


            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in Data view.  Ex = " + Ex.ToString());
            }





            /*
            rtbData.Clear();

            try
            {

                //get start time
                DateTime Start = mdtStart.Value;

                //get end time
                DateTime End = mdtEnd.Value;

                var directory = new DirectoryInfo("c:/process_data/");
                DateTime from_date = Start;
                DateTime to_date = End.AddDays(1);

                var fileList = directory.GetFiles()
                    .Where(fileVal => fileVal.LastWriteTime >= from_date && fileVal.LastWriteTime <= to_date)
                    .OrderByDescending(d => d.CreationTime)
                    .ToList();


                filesToParse.Clear();

                foreach (var fileName in fileList)
                {
                    if (fileName.Name.Contains("data1"))
                    {
                        continue;
                    }
                    else if (fileName.Name.Contains("data2"))
                    {
                        continue;
                    }
                    else if (fileName.Name.Contains("data3"))
                    {
                        continue;
                    }
                    else
                    {
                        filesToParse.Add(fileName.Name);
                    }
                }
                filesToParseIndex += 1;
                if (filesToParseIndex >= filesToParse.Count() - 1)
                {
                    filesToParseIndex = filesToParse.Count() - 1;
                }

                string value = filesToParse[filesToParseIndex];
                string path = "c:/process_data/";

                System.IO.StreamReader sr = new System.IO.StreamReader(path + value);


                string fText = sr.ReadToEnd();
                rtbData.SelectionStart = 0;  // or wherever you want to insert in this rtb
                rtbData.SelectionLength = 0;
                rtbData.SelectionFont = new System.Drawing.Font("Tahoma", 14);

                //
                // this will select specific data and load into the two tables and date time text box
                //
                rtbData.SelectedText = fText;

                sr.Close();
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in Data view Back.  Ex = " + Ex.ToString());
            }

            */

            /*
            int max = filesToParse.Count();
            filesToParseIndex--;
            if (filesToParseIndex >=0 && filesToParseIndex < max)
            {

                System.IO.StreamReader sr = new System.IO.StreamReader(filesToParse[filesToParseIndex]);
                //rtbData.SelectionFont = new Font("Tahoma", 24, FontStyle.Bold);
                //rtbData.SelectionColor = System.Drawing.Color.Green;

                //rtbData.Text = sr.ReadToEnd();

                string fText = sr.ReadToEnd();

                rtbData.SelectionStart = 0;  // or wherever you want to insert..
                rtbData.SelectionLength = 0;
                rtbData.SelectionFont = new System.Drawing.Font("Tahoma", 14);
                rtbData.SelectedText = fText;


            }
            else
            {
                filesToParseIndex = -1;
                rtbData.Text = "No previous data.";
            }

            */

        }

        private void metroButton3_Click(object sender, EventArgs e)
        {

            try
            {
                mtbDataOutputMessage.Text = "";
                mtbDataOutputMessage.Refresh();
                rtbData.Clear();



                //get start time
                DateTime Start = mdtStart.Value;

                //get end time
                DateTime End = mdtEnd.Value;

                var directory = new DirectoryInfo("c:/process_data/");
                DateTime from_date = Start;
                DateTime to_date = End.AddDays(1);

                var fileList = directory.GetFiles()
                    .Where(fileVal => fileVal.LastWriteTime >= from_date && fileVal.LastWriteTime <= to_date)
                    .OrderByDescending(d => d.CreationTime)
                    .ToList();


                filesToParse.Clear();

                foreach (var fileName in fileList)
                {
                    if (fileName.Name.Contains("data1"))
                    {
                        continue;
                    }
                    else if (fileName.Name.Contains("data2"))
                    {
                        continue;
                    }
                    else if (fileName.Name.Contains("data3"))
                    {
                        continue;
                    }
                    else
                    {
                        filesToParse.Add(fileName.Name);
                    }
                }
                filesToParseIndex -= 1;
                if (filesToParseIndex <= 0)
                {
                    filesToParseIndex = 0;
                }

                string value = filesToParse[filesToParseIndex];
                string path = "c:/process_data/";

                //System.IO.StreamReader sr = new System.IO.StreamReader(path + value);


                //string fTextTemp = sr.ReadToEnd();

                //string fText = AdjustTitleDisplayData(fTextTemp);

                //System.IO.StreamReader sr = new System.IO.StreamReader(path + value);

                string[] logFile = File.ReadAllLines(path + value);

                List<string> logList = new List<string>(logFile);

                List<string> temp = new List<string>();

                temp = AdjustDataForDisplay(logList);


                string fText = string.Empty;
                foreach (string s in temp)
                {
                    fText = fText + s;
                }


                //string fTextTemp = sr.ReadToEnd();


                //string fText = AdjustDisplayData(fTextTemp);

                //var logList = new List<string>(fText);




                rtbData.SelectionStart = 0;  // or wherever you want to insert in this rtb
                rtbData.SelectionLength = 0;
                //rtbData.SelectionFont = new System.Drawing.Font("Tahoma", 14);
                //rtbData.SelectionFont = new System.Drawing.Font("TimesNewRoman", 10);
                rtbData.SelectionFont = new System.Drawing.Font("Consolas", 10);
                rtbData.SelectedText = fText;





                //dataGridView1.= fText;
                //DataTable dt = GetDataTable(txtFileName.Text);
                //dataGridView1.DataSource = dt.DefaultView;

                //sr.Close();


                //for data tab test
                try
                {
                    //dataGridView1.DataSource = ReadCsv(path + value);
                }
                catch //(Exception Ex)
                {

                }


            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in Data view.  Ex = " + Ex.ToString());
            }




            /*
            rtbData.Clear();


            try
            {

                //get start time
                DateTime Start = mdtStart.Value;

                //get end time
                DateTime End = mdtEnd.Value;

                var directory = new DirectoryInfo("c:/process_data/");
                DateTime from_date = Start;
                DateTime to_date = End.AddDays(1);

                var fileList = directory.GetFiles()
                    .Where(fileVal => fileVal.LastWriteTime >= from_date && fileVal.LastWriteTime <= to_date)
                    .OrderByDescending(d => d.CreationTime)
                    .ToList();


                filesToParse.Clear();

                foreach (var fileName in fileList)
                {
                    if (fileName.Name.Contains("data1"))
                    {
                        continue;
                    }
                    else if (fileName.Name.Contains("data2"))
                    {
                        continue;
                    }
                    else if (fileName.Name.Contains("data3"))
                    {
                        continue;
                    }
                    else
                    {
                        filesToParse.Add(fileName.Name);
                    }
                }
                filesToParseIndex -= 1;
                if (filesToParseIndex <= 0)
                {
                    filesToParseIndex = 0;
                }

                string value = filesToParse[filesToParseIndex];
                string path = "c:/process_data/";

                System.IO.StreamReader sr = new System.IO.StreamReader(path + value);


                string fText = sr.ReadToEnd();

                rtbData.SelectionStart = 0;  // or wherever you want to insert in this rtb
                rtbData.SelectionLength = 0;
                rtbData.SelectionFont = new System.Drawing.Font("Tahoma", 14);
                rtbData.SelectedText = fText;

                sr.Close();
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Exception in Data view.  Ex = " + Ex.ToString());
            }

            */
        }

        //start csv addition

        /// <summary>
        /// compresses all files in a given directory
        /// 
        /// </summary>
        /// <param name="path"></param>
        private int ZipAllFilesInDirectory(string sourcePath, string zipPathFilename)
        {

            try
            {
                //string startPath = @"c:\example\start";
                //string zipPath = @"c:\example\result.zip";
                //string extractPath = @"c:\example\extract";

                ZipFile.CreateFromDirectory(sourcePath, zipPathFilename);

                //ZipFile.ExtractToDirectory(zipPath, extractPath);c
                return PASS;

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error in ZipAllFileinDirectory.  Ex = " + Ex.ToString());
                return FAIL;
            }
        }


        private int DeleteAllFilesInDirectory(string sourcePath)
        {
            try
            {


                DirectoryInfo directory = new DirectoryInfo(sourcePath);

                //delete files:
                directory.GetFiles().ToList().ForEach(f => f.Delete());

                //delete folders inside choosen folder
                //directory.GetDirectories().ToList().ForEach(d => d.Delete(true));

                return PASS;

            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error in DeleteAllFileinDirectory.  Ex = " + Ex.ToString());
                return FAIL;
            }
        }


        private FileInfo GetLatestFileInDirectory(string path)
        {

            try
            {
                var inputDirectory = new DirectoryInfo(path);
                var myFile = inputDirectory.GetFiles().OrderByDescending(f => f.LastWriteTime).First();
                return myFile;
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error in GetLatestFileInDirectory.  Ex = " + Ex.ToString());
                return null;
            }
        }


        private int GetCountOfFilesInDirectory(string path)
        {

            try
            {
                var inputDirectory = new DirectoryInfo(path);
                var count = inputDirectory.GetFiles().OrderByDescending(f => f.LastWriteTime).Count();
                return count;
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error in GetLatestFileInDirectory.  Ex = " + Ex.ToString());
                return 0;
            }
        }




        /// <summary>
        /// Generate single (csv) file from the data in the latest file written to c:\process_data
        /// Output directory is:  c:\process_data_csv
        /// Zip directory is:  c:\process_data_zip
        /// </summary>
        private void GenerateCSVOutput(int upscaleActive)
        {


            try
            {
                //mtbDataOutputMessage.Text = "";
                //mtbDataOutputMessage.Text = "Collecting Data from Start Date to End Date.";
                //mtbDataOutputMessage.Refresh();
                //Thread.Sleep(500);

                //gether all files in directory,
                //read through them and create a final output file

                //get start time
                //DateTime Start = mdtStart.Value;

                //get end time
                //DateTime End = mdtEnd.Value;

                //var directory = new DirectoryInfo("c:/process_data/");
                //DateTime from_date_prelim = Start;
                //DateTime from_date = from_date_prelim.AddDays(-1);
                //DateTime to_date_prelim = End;
                //DateTime to_date = to_date_prelim.AddDays(1);

                //var fileList = directory.GetFiles()    //this does not do the >= or <= only < or >, thus the adjustment above
                //    .Where(file => file.LastWriteTime >= from_date && file.LastWriteTime <= to_date);

                var fileList = Directory.GetFiles("c:/Process_data").Select(f => new FileInfo(f)).OrderBy(f => f.CreationTime);

                string line;
                string outputFile;

                int index = 0;
                int itemFound = 0;


                DateTime now = DateTime.Now;



                //outputFile = "C:\\temp\\summary_" + from_date_prelim.Month.ToString() + "_" + from_date_prelim.Day.ToString() + "_" + from_date_prelim.Year.ToString() + "__" + to_date_prelim.Month.ToString() + "_" + to_date_prelim.Day.ToString() + "_" + to_date_prelim.Year.ToString() + ".txt";
                outputFile = csvPathName + "Sample_" + now.Month.ToString("D2") + "_" + now.Day.ToString("D2") + "_" + now.Year.ToString("D2") + "__" + now.Hour.ToString("D2") + "_" + now.Minute.ToString("D2") + "_" + now.Second.ToString("D2") + ".csv";


                //mtbDataOutputMessage.Text = "Output file written to:  " + outputFile;

                string outputString = string.Empty;
                string titleString1 = string.Empty;

                //if (Properties.Settings.Default.OutputPin7 == true)
                //{
                titleString1 = ", , , , , , , , , , , , , , , , , , , , ,ALUMINIUM, , SILICON, , PHOSPORUS, , SULPHUR, , CHLORINE, , POTASSIUM, , CALCIUM, , SCANDIUM, , TITANIUM, , VANADIUM, , CHROMIUM, , MANGANESE, , IRON, , COBALT, , NICKEL, , COPPER, , ZINC, , GALLIUM, , GERMANIUM, , ARSENIC, , SELENIUM, , BROMINE, , RUBINIUM, , STRONTIUM, , YTTRIUM, , ZIRCONIUM, , NIOBIUM, , MOLYBDENUM, , RUTHENIUM, , RHODIUM, , PALLADIUM, , SILVER, , CADMIUM, , INDIUM, , TIN, , ANTIMONY, , TELLURIUM, , IODINE, , CESIUM, , BARIUM, , LANTHANUM, , CERIUM, , PRASEODYMIUM, , NEODYMIUM, , PROMETHIUM, , SAMARIUM, , EUROPIUM, , GADOLINIUM, , TERBIUM, , DYSPROSIUM, , HOLMIUM, , ERBIUM, , THULIUM, , YTTERBIUM, , LUTETIUM, , HAFNIUM, , TANTALUM, , TUNGSTEN, , RHENIUM, , OSMIUM, , IRIDIUM, , PLATINUM, , GOLD, , MERCURY, , THALLIUM, , LEAD, , BISMUTH, , THORIUM, , PROTACTINIUM, , URANIUM, ";
                //}
                //else
                //{
                //    titleString1 = ", , , , , , , , , , , , , , , , , , ,ALUMINIUM , SILICON , PHOSPORUS , SULPHUR , CHLORINE , POTASSIUM , CALCIUM , SCANDIUM , TITANIUM , VANADIUM , CHROMIUM , MANGANESE , IRON , COBALT , NICKEL , COPPER , ZINC , GALLIUM , GERMANIUM , ARSENIC , SELENIUM , BROMINE , RUBINIUM , STRONTIUM , YTTRIUM , ZIRCONIUM , NIOBIUM , MOLYBDENUM , RUTHENIUM , RHODIUM , PALLADIUM , SILVER , CADMIUM , INDIUM , TIN , ANTIMONY , TELLURIUM , IODINE , CESIUM , BARIUM , LANTHANUM , CERIUM , PRASEODYMIUM , NEODYMIUM , PROMETHIUM, SAMARIUM , EUROPIUM , GADOLINIUM , TERBIUM , DYSPROSIUM , HOLMIUM , ERBIUM , THULIUM , YTTERBIUM , LUTETIUM , HAFNIUM , TANTALUM , TUNGSTEN , RHENIUM , OSMIUM , IRIDIUM , PLATINUM , GOLD , MERCURY , THALLIUM , LEAD , BISMUTH , THORIUM , PROTACTINIUM , URANIUM ";
                //}


                string titleString2 = string.Empty;
                //if (Properties.Settings.Default.OutputPin7 == true)
                //{
                titleString2 = "TIME, PUMP START TIME, AT (C), SAMPLE (C), BP (mmHg), TAPE (mmHg), FLOW 25 (slpm), FLOW ACT (lpm), FLOW STD (slpm), VOLUME (L), TUBE (C), ENCLOSURE (C), FILAMENT (V), SDD (C), DPP (C), RH (%), WIND (m/s), WIND DIR (deg), SAMPLE TIME (min), Output Pin 7 (True=ON), ALARM, Al 13 (ng/m3), Al Uncert (ng/m3), Si 14 (ng/m3), Si Uncert (ng/m3), P 15 (ng/m3), P Uncert (ng/m3),S 16 (ng/m3),S Uncert (ng/m3), Cl 17 (ng/m3),Cl Uncert (ng/m3),  K 19 (ng/m3),K Uncert (ng/m3), Ca 20 (ng/m3),Ca Uncert (ng/m3), Sc 21 (ng/m3),Sc Uncert (ng/m3), Ti 22 (ng/m3),Ti Uncert (ng/m3), V 23 (ng/m3),V Uncert (ng/m3), Cr 24 (ng/m3),Cr Uncert (ng/m3), Mn 25 (ng/m3),Mn Uncert (ng/m3), Fe 26 (ng/m3),Fe Uncert (ng/m3), Co 27 (ng/m3),Co Uncert (ng/m3), Ni 28 (ng/m3),Ni Uncert (ng/m3), Cu 29 (ng/m3),Cu Uncert (ng/m3), Zn 30 (ng/m3),Zn Uncert (ng/m3), Ga 31 (ng/m3),Ga Uncert (ng/m3), Ge 32 (ng/m3),Ge Uncert (ng/m3), As 33 (ng/m3),As Uncert (ng/m3), Se 34 (ng/m3),Se Uncert (ng/m3), Br 35 (ng/m3),Br Uncert (ng/m3), Rb 37 (ng/m3),Rb Uncert (ng/m3), Sr 38 (ng/m3),Sr Uncert (ng/m3), Y 39 (ng/m3),Y Uncert (ng/m3), Zr 40 (ng/m3),Zr Uncert (ng/m3), Nb 41(ng/m3),Nb Uncert (ng/m3), Mo 42 (ng/m3), Mo Uncert (ng/m3), Ru 44 (ng/m3),Ru Uncert (ng/m3), Rh 45 (ng/m3),Rh Uncert (ng/m3), Pd 46 (ng/m3),Pd Uncert (ng/m3), Ag 47 (ng/m3),Ag Uncert (ng/m3), Cd 48 (ng/m3),Cd Uncert (ng/m3), In 49 (ng/m3),In Uncert (ng/m3), Sn 50 (ng/m3), Sn Uncert (ng/m3),Sb 51 (ng/m3),Sb Uncert (ng/m3), Te 52 (ng/m3),Te Uncert (ng/m3), I 53 (ng/m3),I Uncert (ng/m3), Cs 55 (ng/m3),Cs Uncert (ng/m3), Ba 56 (ng/m3),Ba Uncert (ng/m3), La 57 (ng/m3),La Uncert (ng/m3), Ce 58 (ng/m3),Ce Uncert (ng/m3), Pr 59 (ng/m3),Pr Uncert (ng/m3), Nd 60 (ng/m3),Nd Uncert (ng/m3), Pm 61 (ng/m3),Pm Uncert (ng/m3), Sm 62 (ng/m3),Sm Uncert (ng/m3), Eu 63 (ng/m3),Eu Uncert (ng/m3), Gd 64 (ng/m3),Gd Uncert (ng/m3), Tb 65 (ng/m3),Tb Uncert (ng/m3), Dy 66 (ng/m3),Dy Uncert (ng/m3), Ho 67 (ng/m3),Ho Uncert (ng/m3), Er 68 (ng/m3),Er Uncert (ng/m3), Tm 69 (ng/m3),Tm Uncert (ng/m3), Yb 70 (ng/m3),Yb Uncert (ng/m3), Lu 71 (ng/m3),Lu Uncert (ng/m3), Hf 72 (ng/m3),Hf Uncert (ng/m3), Ta 73 (ng/m3),Ta Uncert (ng/m3), W 74 (ng/m3),W Uncert (ng/m3), Re 75 (ng/m3),Re Uncert (ng/m3), Os 76 (ng/m3),Os Uncert (ng/m3), Ir 77 (ng/m3),Ir Uncert (ng/m3), Pt 78 (ng/m3),Pt Uncert (ng/m3), Au 79 (ng/m3),Au Uncert (ng/m3), Hg 80 (ng/m3),Hg Uncert (ng/m3), Tl 81 (ng/m3),Tl Uncert (ng/m3), Pb 82 (ng/m3),Pb Uncert (ng/m3), Bi 83 (ng/m3),Bi Uncert (ng/m3), Th 90 (ng/m3),Th Uncert (ng/m3), Pa 91 (ng/m3),Pa Uncert (ng/m3), U 92 (ng/m3),U Uncert (ng/m3),";
                //}
                //else
                //{
                //    titleString2 = "TIME, AT (C), SAMPLE (C), BP (mmHg), TAPE (mmHg), FLOW 25 (slpm), FLOW ACT (lpm), FLOW STD (slpm), VOLUME (m3), TUBE (C), ENCLOSURE (C), FILAMENT (V), SDD (C), DDP (C), RH (%), WIND (m/s), WIND DIR (deg), SAMPLE TIME (min), ALARM, Al 13 (ng/m3), Si 14 (ng/m3), P 15 (ng/m3), S 16 (ng/m3), Cl 17 (ng/m3),  K 19 (ng/m3), Ca 20 (ng/m3), Sc 21 (ng/m3), Ti 22 (ng/m3), V 23 (ng/m3), Cr 24 (ng/m3), Mn 25 (ng/m3), Fe 26 (ng/m3), Co 27 (ng/m3), Ni 28 (ng/m3), Cu 29 (ng/m3), Zn 30 (ng/m3), Ga 31 (ng/m3), Ge 32 (ng/m3), As 33 (ng/m3), Se 34 (ng/m3), Br 35 (ng/m3), Rb 37 (ng/m3), Sr 38 (ng/m3), Y 39 (ng/m3), Zr 40 (ng/m3), Nb 41(ng/m3), Mo 42 (ng/m3), Ru 44 (ng/m3), Rh 45 (ng/m3), Pd 46 (ng/m3), Ag 47 (ng/m3), Cd 48 (ng/m3), In 49 (ng/m3), Sn 50 (ng/m3), Sb 51 (ng/m3), Te 52 (ng/m3), I 53 (ng/m3), Cs 55 (ng/m3), Ba 56 (ng/m3), La 57 (ng/m3), Ce 58 (ng/m3), Pr 59 (ng/m3), Nd 60 (ng/m3), Pm 61 (ng/m3), Sm 62 (ng/m3), Eu 63 (ng/m3), Gd 64 (ng/m3), Tb 65 (ng/m3), Dy 66 (ng/m3), Ho 67 (ng/m3), Er 68 (ng/m3), Tm 69 (ng/m3), Yb 70 (ng/m3), Lu 71 (ng/m3), Hf 72 (ng/m3), Ta 73 (ng/m3), W 74 (ng/m3), Re 75 (ng/m3), Os 76 (ng/m3), Ir 77 (ng/m3), Pt 78 (ng/m3), Au 79 (ng/m3), Hg 80 (ng/m3), Tl 81 (ng/m3), Pb 82 (ng/m3), Bi 83 (ng/m3), Th 90 (ng/m3), Pa 91 (ng/m3), U 92 (ng/m3)";
                //}


                StreamWriter writer = new StreamWriter(outputFile);

                writer.WriteLine(titleString1);
                writer.WriteLine(titleString2);


                List<string> ItemsToFind = new List<string>();

                ItemsToFind.Add("Start Time");     //1  this will find ambient start time before 1.0.0.43, and sample start time after 1.0.0.43
                ItemsToFind.Add("Pump Start Time");
                ItemsToFind.Add("Ambient Temp");
                ItemsToFind.Add("Sample Temp");
                ItemsToFind.Add("BP");  //5
                ItemsToFind.Add("Tape");  
                ItemsToFind.Add("Flow 25"); 
                ItemsToFind.Add("Flow Act");
                ItemsToFind.Add("Flow Std");
                ItemsToFind.Add("Volume"); //10
                ItemsToFind.Add("Tube Temp"); 
                ItemsToFind.Add("Enclosure Temp"); 
                ItemsToFind.Add("Filament Monitor");
                ItemsToFind.Add("SDD Temp");
                ItemsToFind.Add("DPP Temp"); //15
                ItemsToFind.Add("Relative Humidity"); //16  
                ItemsToFind.Add("Wind Speed"); //17
                ItemsToFind.Add("Wind Direction"); //18
                ItemsToFind.Add("Sample Time");  //17

                ItemsToFind.Add("Control Line");  //19
                ItemsToFind.Add("Alarm"); //20

                ItemsToFind.Add("Al,");
                ItemsToFind.Add("Si,");
                ItemsToFind.Add("P ,");
                ItemsToFind.Add("S ,");
                ItemsToFind.Add("Cl,");
                ItemsToFind.Add("K ,");
                ItemsToFind.Add("Ca,");
                ItemsToFind.Add("Sc,");
                ItemsToFind.Add("Ti,");
                ItemsToFind.Add("V ,");
                ItemsToFind.Add("Cr,");
                ItemsToFind.Add("Mn,");
                ItemsToFind.Add("Fe,");
                ItemsToFind.Add("Co,");
                ItemsToFind.Add("Ni,");
                ItemsToFind.Add("Cu,");
                ItemsToFind.Add("Zn,");
                ItemsToFind.Add("Ga,");
                ItemsToFind.Add("Ge,");
                ItemsToFind.Add("As,");
                ItemsToFind.Add("Se,");
                ItemsToFind.Add("Br,");
                ItemsToFind.Add("Rb,");
                ItemsToFind.Add("Sr,");
                ItemsToFind.Add("Y ,");
                ItemsToFind.Add("Zr,");
                ItemsToFind.Add("Nb,");
                ItemsToFind.Add("Mo,");
                ItemsToFind.Add("Ru,");
                ItemsToFind.Add("Rh,");
                ItemsToFind.Add("Pd,");
                ItemsToFind.Add("Ag,");
                ItemsToFind.Add("Cd,");
                ItemsToFind.Add("In,");
                ItemsToFind.Add("Sn,");
                ItemsToFind.Add("Sb,");
                ItemsToFind.Add("Te,");
                ItemsToFind.Add("I ,");
                ItemsToFind.Add("Cs,");
                ItemsToFind.Add("Ba,");
                ItemsToFind.Add("La,");
                ItemsToFind.Add("Ce,");
                ItemsToFind.Add("Pr,");
                ItemsToFind.Add("Nd,");
                ItemsToFind.Add("Pm,");
                ItemsToFind.Add("Sm,");
                ItemsToFind.Add("Eu,");
                ItemsToFind.Add("Gd,");
                ItemsToFind.Add("Tb,");
                ItemsToFind.Add("Dy,");
                ItemsToFind.Add("Ho,");
                ItemsToFind.Add("Er,");
                ItemsToFind.Add("Tm,");
                ItemsToFind.Add("Yb,");
                ItemsToFind.Add("Lu,");
                ItemsToFind.Add("Hf,");
                ItemsToFind.Add("Ta,");
                ItemsToFind.Add("W ,");
                ItemsToFind.Add("Re,");
                ItemsToFind.Add("Os,");
                ItemsToFind.Add("Ir,");
                ItemsToFind.Add("Pt,");
                ItemsToFind.Add("Au,");
                ItemsToFind.Add("Hg,");
                ItemsToFind.Add("Tl,");
                ItemsToFind.Add("Pb,");
                ItemsToFind.Add("Bi,");
                ItemsToFind.Add("Th,");
                ItemsToFind.Add("Pa,");
                ItemsToFind.Add("U ,");

                int foundFile = 0;
                FileInfo fI;
                int number = 0;
                number = fileList.Count<FileInfo>();
                //foreach (FileInfo f in fileList)
                //{
                fI = fileList.Last<FileInfo>();

                if (fI.Name.Contains("data") || fI.Name.Contains("zip"))
                {
                    foundFile = 0;

                    //continue;  //skip the data1, data2, and data3 files or .zip files
                }
                else
                {
                    foundFile = 1;
                    //found a good file here, lets add the data into the correct output
                    //System.IO.StreamReader tempfile = new System.IO.StreamReader(f.OpenRead());


                    while (index < (ItemsToFind.Count))
                    {

                        itemFound = 0;
                        System.IO.StreamReader tempfile2 = new System.IO.StreamReader(fI.OpenRead());

                        int EndProcessDataValue = 0;
                        while ((line = tempfile2.ReadLine()) != null)
                        {
                            //read each line and put it in the right place in the output string



                            if (line.Contains(ItemsToFind[index]))
                            {
                                itemFound = 1;

                                EndProcessDataValue = 21;  //include the cl7 value

                                //if (ItemsToFind[index] == "Alarm")
                                //{
                                //    if (ecalActive > 0)
                                //    {
                                //        outputString = (outputString + "Ecal" + ",");
                                //    }
                                //    else if (upscaleActive > 0)
                                //    {
                                //            outputString = (outputString + "Upscale" + ",");
                                //    }
                                //}
                                //else if(ecalActive==0 && upscaleActive==0)
                                //{


                                if (ItemsToFind[index] == "Alarm" && upscaleActive != 0)
                                {
                                    outputString = (outputString + "Upscale ");

                                }

                                string[] data = line.Split(',');
                                if (index == 0)
                                {
                                    //string[] datetime = data[2].Split(' ');
                                    //data
                                    outputString = data[2].Insert((data[2].Length - 2), "00");
                                    outputString = outputString.Substring(0, outputString.Length - 2);
                                    outputString = outputString + ",";
                                }
                                else if (index < EndProcessDataValue)
                                {
                                    outputString = (outputString + data[2] + ",");
                                }
                                else   //this captures the concentration from the output file
                                {
                                    outputString = (outputString + data[4] + "," + data[3] + ",");

                                }




                                index++;  //look for the next thing


                                if (index == ItemsToFind.Count)
                                {
                                    index = 0;
                                    break;
                                }
                                itemFound = 0;  //item has been found and added -- now to look for the next item indicated by index, from the start of the file
                                tempfile2 = new System.IO.StreamReader(fI.OpenRead());  //return to the start of the file--you are looking for something new
                            }
                            else
                            {
                                //int x = 0;
                                //item not found
                                //if ()
                            }

                            //}/////

                        } //inner while

                        if (line == null)
                        {
                            //item was not found      

                        }

                        //read through the whole file and didnt find the item
                        if (itemFound == 0)
                        {
                            //if (Properties.Settings.Default.OutputPin7 == true)
                            //{
                            if (index < (EndProcessDataValue))
                            {
                                outputString = (outputString + ",");
                            }
                            else
                            {
                                outputString = (outputString + "," + ",");

                            }
                            //}
                            //else
                            //{
                            //    if (index >= EndProcessDataValue)
                            //    {
                            //        outputString = (outputString + ",");
                            //    }
                            //}
                            index++;

                        }
                        else
                        {
                            tempfile2.Close();
                            index = 0;
                            break;
                        }
                    } //while loop



                    index = 0;
                    writer.WriteLine(outputString);
                    outputString = string.Empty;
                    if (foundFile == 1)
                    {
                        //break;

                    }




                }

                //}

                //mtbDataOutputMessage.Text = "Output file written to:  " + outputFile;
                writer.Close();

            }
            catch (Exception Ex)
            {
                //mtbDataOutputMessage.Text = "Error creating CSV summary file.  See ErrorFile.txt";

                Logger.WriteInternalLogFile("Exception in Summary CSV file:  Ex = " + Ex.ToString());
            }

        }









        //end csv addition


        private void metroButton4_Click(object sender, EventArgs e)
        {
            try
            {
                mtbDataOutputMessage.Text = "";
                mtbDataOutputMessage.Text = "Collecting Data from Start Date to End Date.";
                mtbDataOutputMessage.Refresh();
                Thread.Sleep(500);

                //gether all files in directory,
                //read through them and create a final output file

                //get start time
                DateTime Start = mdtStart.Value;

                //get end time
                DateTime End = mdtEnd.Value;

                DirectoryInfo directory;

                try
                {
                    directory = new DirectoryInfo("c:/process_data/");
                }
                catch
                {
                    directory = null;
                }

                DateTime from_date_prelim = Start;
                DateTime from_date = from_date_prelim.AddDays(-1);
                DateTime to_date_prelim = End;
                DateTime to_date = to_date_prelim.AddDays(1);

                IEnumerable<FileInfo> fileList;

                try
                {
                    fileList = directory.GetFiles()    //this does not do the >= or <= only < or >, thus the adjustment above
                            .Where(file => file.LastWriteTime >= from_date && file.LastWriteTime <= to_date);
                }
                catch
                {
                    fileList = null;
                }
                string line;
                string outputFile;

                int index = 0;
                int itemFound = 0;

                int EndProcessDataValue = 0;

                DateTime now = DateTime.Now;


                outputFile = "C:\\temp\\summary_" + from_date_prelim.Month.ToString() + "_" + from_date_prelim.Day.ToString() + "_" + from_date_prelim.Year.ToString() + "__" + to_date_prelim.Month.ToString() + "_" + to_date_prelim.Day.ToString() + "_" + to_date_prelim.Year.ToString() + ".txt";
                mtbDataOutputMessage.Text = "Output file written to:  " + outputFile;

                string outputString = string.Empty;
                string titleString1 = string.Empty;

                //if (Properties.Settings.Default.OutputPin7 == true)
                //{
                    titleString1 = ", , , , , , , , , , , , , , , , , , , , , ,ALUMINIUM, , SILICON, , PHOSPORUS, , SULPHUR, , CHLORINE, , POTASSIUM, , CALCIUM, , SCANDIUM, , TITANIUM, , VANADIUM, , CHROMIUM, , MANGANESE, , IRON, , COBALT, , NICKEL, , COPPER, , ZINC, , GALLIUM, , GERMANIUM, , ARSENIC, , SELENIUM, , BROMINE, , RUBINIUM, , STRONTIUM, , YTTRIUM, , ZIRCONIUM, , NIOBIUM, , MOLYBDENUM, , RUTHENIUM, , RHODIUM, , PALLADIUM, , SILVER, , CADMIUM, , INDIUM, , TIN, , ANTIMONY, , TELLURIUM, , IODINE, , CESIUM, , BARIUM, , LANTHANUM, , CERIUM, , PRASEODYMIUM, , NEODYMIUM, , PROMETHIUM, , SAMARIUM, , EUROPIUM, , GADOLINIUM, , TERBIUM, , DYSPROSIUM, , HOLMIUM, , ERBIUM, , THULIUM, , YTTERBIUM, , LUTETIUM, , HAFNIUM, , TANTALUM, , TUNGSTEN, , RHENIUM, , OSMIUM, , IRIDIUM, , PLATINUM, , GOLD, , MERCURY, , THALLIUM, , LEAD, , BISMUTH, , THORIUM, , PROTACTINIUM, , URANIUM, ";
              //    titleString1 = ", , , , , , , , , , , , , , , , , , ,ALUMINIUM , SILICON , PHOSPORUS , SULPHUR , CHLORINE , POTASSIUM , CALCIUM , SCANDIUM , TITANIUM , VANADIUM , CHROMIUM , MANGANESE , IRON , COBALT , NICKEL , COPPER , ZINC , GALLIUM , GERMANIUM , ARSENIC , SELENIUM , BROMINE , RUBINIUM , STRONTIUM , YTTRIUM , ZIRCONIUM , NIOBIUM , MOLYBDENUM , RUTHENIUM , RHODIUM , PALLADIUM , SILVER , CADMIUM , INDIUM , TIN , ANTIMONY , TELLURIUM , IODINE , CESIUM , BARIUM , LANTHANUM , CERIUM , PRASEODYMIUM , NEODYMIUM , PROMETHIUM, SAMARIUM , EUROPIUM , GADOLINIUM , TERBIUM , DYSPROSIUM , HOLMIUM , ERBIUM , THULIUM , YTTERBIUM , LUTETIUM , HAFNIUM , TANTALUM , TUNGSTEN , RHENIUM , OSMIUM , IRIDIUM , PLATINUM , GOLD , MERCURY , THALLIUM , LEAD , BISMUTH , THORIUM , PROTACTINIUM , URANIUM ";
                //}
                //else
                //{
                //    titleString1 = ", , , , , , , , , , , , , , , , , , ,ALUMINIUM , SILICON , PHOSPORUS , SULPHUR , CHLORINE , POTASSIUM , CALCIUM , SCANDIUM , TITANIUM , VANADIUM , CHROMIUM , MANGANESE , IRON , COBALT , NICKEL , COPPER , ZINC , GALLIUM , GERMANIUM , ARSENIC , SELENIUM , BROMINE , RUBINIUM , STRONTIUM , YTTRIUM , ZIRCONIUM , NIOBIUM , MOLYBDENUM , RUTHENIUM , RHODIUM , PALLADIUM , SILVER , CADMIUM , INDIUM , TIN , ANTIMONY , TELLURIUM , IODINE , CESIUM , BARIUM , LANTHANUM , CERIUM , PRASEODYMIUM , NEODYMIUM , PROMETHIUM, SAMARIUM , EUROPIUM , GADOLINIUM , TERBIUM , DYSPROSIUM , HOLMIUM , ERBIUM , THULIUM , YTTERBIUM , LUTETIUM , HAFNIUM , TANTALUM , TUNGSTEN , RHENIUM , OSMIUM , IRIDIUM , PLATINUM , GOLD , MERCURY , THALLIUM , LEAD , BISMUTH , THORIUM , PROTACTINIUM , URANIUM ";
                //}


                string titleString2 = string.Empty;
                //if (Properties.Settings.Default.OutputPin7 == true)
                //{
                titleString2 = " TIME, PUMP START TIME, AT (C), SAMPLE (C), BP (mmHg), TAPE (mmHg), FLOW 25 (slpm), FLOW ACT (lpm), FLOW STD (slpm), VOLUME (L), TUBE (C), ENCLOSURE (C), FILAMENT (V), SDD (C), DPP (C), RH (%), WIND (m/s), WIND DIR (deg), SAMPLE TIME (min), Output Pin 7 (True=ON), ALARM, XC VER, Al 13 (ng/m3), Al Uncert (ng/m3), Si 14 (ng/m3), Si Uncert (ng/m3), P 15 (ng/m3), P Uncert (ng/m3),S 16 (ng/m3),S Uncert (ng/m3), Cl 17 (ng/m3),Cl Uncert (ng/m3),  K 19 (ng/m3),K Uncert (ng/m3), Ca 20 (ng/m3),Ca Uncert (ng/m3), Sc 21 (ng/m3),Sc Uncert (ng/m3), Ti 22 (ng/m3),Ti Uncert (ng/m3), V 23 (ng/m3),V Uncert (ng/m3), Cr 24 (ng/m3),Cr Uncert (ng/m3), Mn 25 (ng/m3),Mn Uncert (ng/m3), Fe 26 (ng/m3),Fe Uncert (ng/m3), Co 27 (ng/m3),Co Uncert (ng/m3), Ni 28 (ng/m3),Ni Uncert (ng/m3), Cu 29 (ng/m3),Cu Uncert (ng/m3), Zn 30 (ng/m3),Zn Uncert (ng/m3), Ga 31 (ng/m3),Ga Uncert (ng/m3), Ge 32 (ng/m3),Ge Uncert (ng/m3), As 33 (ng/m3),As Uncert (ng/m3), Se 34 (ng/m3),Se Uncert (ng/m3), Br 35 (ng/m3),Br Uncert (ng/m3), Rb 37 (ng/m3),Rb Uncert (ng/m3), Sr 38 (ng/m3),Sr Uncert (ng/m3), Y 39 (ng/m3),Y Uncert (ng/m3), Zr 40 (ng/m3),Zr Uncert (ng/m3), Nb 41(ng/m3),Nb Uncert (ng/m3), Mo 42 (ng/m3), Mo Uncert (ng/m3), Ru 44 (ng/m3),Ru Uncert (ng/m3), Rh 45 (ng/m3),Rh Uncert (ng/m3), Pd 46 (ng/m3),Pd Uncert (ng/m3), Ag 47 (ng/m3),Ag Uncert (ng/m3), Cd 48 (ng/m3),Cd Uncert (ng/m3), In 49 (ng/m3),In Uncert (ng/m3), Sn 50 (ng/m3), Sn Uncert (ng/m3),Sb 51 (ng/m3),Sb Uncert (ng/m3), Te 52 (ng/m3),Te Uncert (ng/m3), I 53 (ng/m3),I Uncert (ng/m3), Cs 55 (ng/m3),Cs Uncert (ng/m3), Ba 56 (ng/m3),Ba Uncert (ng/m3), La 57 (ng/m3),La Uncert (ng/m3), Ce 58 (ng/m3),Ce Uncert (ng/m3), Pr 59 (ng/m3),Pr Uncert (ng/m3), Nd 60 (ng/m3),Nd Uncert (ng/m3), Pm 61 (ng/m3),Pm Uncert (ng/m3), Sm 62 (ng/m3),Sm Uncert (ng/m3), Eu 63 (ng/m3),Eu Uncert (ng/m3), Gd 64 (ng/m3),Gd Uncert (ng/m3), Tb 65 (ng/m3),Tb Uncert (ng/m3), Dy 66 (ng/m3),Dy Uncert (ng/m3), Ho 67 (ng/m3),Ho Uncert (ng/m3), Er 68 (ng/m3),Er Uncert (ng/m3), Tm 69 (ng/m3),Tm Uncert (ng/m3), Yb 70 (ng/m3),Yb Uncert (ng/m3), Lu 71 (ng/m3),Lu Uncert (ng/m3), Hf 72 (ng/m3),Hf Uncert (ng/m3), Ta 73 (ng/m3),Ta Uncert (ng/m3), W 74 (ng/m3),W Uncert (ng/m3), Re 75 (ng/m3),Re Uncert (ng/m3), Os 76 (ng/m3),Os Uncert (ng/m3), Ir 77 (ng/m3),Ir Uncert (ng/m3), Pt 78 (ng/m3),Pt Uncert (ng/m3), Au 79 (ng/m3),Au Uncert (ng/m3), Hg 80 (ng/m3),Hg Uncert (ng/m3), Tl 81 (ng/m3),Tl Uncert (ng/m3), Pb 82 (ng/m3),Pb Uncert (ng/m3), Bi 83 (ng/m3),Bi Uncert (ng/m3), Th 90 (ng/m3),Th Uncert (ng/m3), Pa 91 (ng/m3),Pa Uncert (ng/m3), U 92 (ng/m3),U Uncert (ng/m3),";
                //}
                //else
                //{
                //    titleString2 = "TIME, AT (C), SAMPLE (C), BP (mmHg), TAPE (mmHg), FLOW 25 (slpm), FLOW ACT (lpm), FLOW STD (slpm), VOLUME (L), TUBE (C), ENCLOSURE (C), FILAMENT (V), SDD (C), DDP (C), RH (%), WIND (m/s), WIND DIR (deg), SAMPLE TIME (min), ALARM, Al 13 (ng/m3), Si 14 (ng/m3), P 15 (ng/m3), S 16 (ng/m3), Cl 17 (ng/m3),  K 19 (ng/m3), Ca 20 (ng/m3), Sc 21 (ng/m3), Ti 22 (ng/m3), V 23 (ng/m3), Cr 24 (ng/m3), Mn 25 (ng/m3), Fe 26 (ng/m3), Co 27 (ng/m3), Ni 28 (ng/m3), Cu 29 (ng/m3), Zn 30 (ng/m3), Ga 31 (ng/m3), Ge 32 (ng/m3), As 33 (ng/m3), Se 34 (ng/m3), Br 35 (ng/m3), Rb 37 (ng/m3), Sr 38 (ng/m3), Y 39 (ng/m3), Zr 40 (ng/m3), Nb 41(ng/m3), Mo 42 (ng/m3), Ru 44 (ng/m3), Rh 45 (ng/m3), Pd 46 (ng/m3), Ag 47 (ng/m3), Cd 48 (ng/m3), In 49 (ng/m3), Sn 50 (ng/m3), Sb 51 (ng/m3), Te 52 (ng/m3), I 53 (ng/m3), Cs 55 (ng/m3), Ba 56 (ng/m3), La 57 (ng/m3), Ce 58 (ng/m3), Pr 59 (ng/m3), Nd 60 (ng/m3), Pm 61 (ng/m3), Sm 62 (ng/m3), Eu 63 (ng/m3), Gd 64 (ng/m3), Tb 65 (ng/m3), Dy 66 (ng/m3), Ho 67 (ng/m3), Er 68 (ng/m3), Tm 69 (ng/m3), Yb 70 (ng/m3), Lu 71 (ng/m3), Hf 72 (ng/m3), Ta 73 (ng/m3), W 74 (ng/m3), Re 75 (ng/m3), Os 76 (ng/m3), Ir 77 (ng/m3), Pt 78 (ng/m3), Au 79 (ng/m3), Hg 80 (ng/m3), Tl 81 (ng/m3), Pb 82 (ng/m3), Bi 83 (ng/m3), Th 90 (ng/m3), Pa 91 (ng/m3), U 92 (ng/m3)";
                //}


                StreamWriter writer = new StreamWriter(outputFile);

                writer.WriteLine(titleString1);
                writer.WriteLine(titleString2);


                double volumeForConversion = 0.0;

                List<string> ItemsToFind = new List<string>();

                ItemsToFind.Add("Start Time");     //1  this will find ambient start time before 1.0.0.43, and sample start time after 1.0.0.43
                ItemsToFind.Add("Pump Start Time");  //1.2.0.1
                ItemsToFind.Add("Ambient Temp");
                ItemsToFind.Add("Sample Temp");
                ItemsToFind.Add("BP"); //5
                ItemsToFind.Add("Tape");  
                ItemsToFind.Add("Flow 25");
                ItemsToFind.Add("Flow Act");
                ItemsToFind.Add("Flow Std");
                ItemsToFind.Add("Volume");  //10
                ItemsToFind.Add("Tube Temp"); 
                ItemsToFind.Add("Enclosure Temp");
                ItemsToFind.Add("Filament Monitor");
                ItemsToFind.Add("SDD Temp");
                ItemsToFind.Add("DPP Temp");  //15
                ItemsToFind.Add("Relative Humidity");  //16  
                ItemsToFind.Add("Wind Speed"); //17
                ItemsToFind.Add("Wind Direction"); //18
                ItemsToFind.Add("Sample Time");  //19
                ItemsToFind.Add("Control Line");  //20
                ItemsToFind.Add("Alarm"); //21
                ItemsToFind.Add("XC version");//22

                EndProcessDataValue = ItemsToFind.Count; //record this value for use in data display

                ItemsToFind.Add("Al,");
                ItemsToFind.Add("Si,");
                ItemsToFind.Add("P ,");
                ItemsToFind.Add("S ,");
                ItemsToFind.Add("Cl,");    
                ItemsToFind.Add("K ,");
                ItemsToFind.Add("Ca,");
                ItemsToFind.Add("Sc,");
                ItemsToFind.Add("Ti,");
                ItemsToFind.Add("V ,");
                ItemsToFind.Add("Cr,");
                ItemsToFind.Add("Mn,");
                ItemsToFind.Add("Fe,");
                ItemsToFind.Add("Co,");
                ItemsToFind.Add("Ni,");
                ItemsToFind.Add("Cu,");
                ItemsToFind.Add("Zn,");
                ItemsToFind.Add("Ga,");
                ItemsToFind.Add("Ge,");
                ItemsToFind.Add("As,");
                ItemsToFind.Add("Se,");
                ItemsToFind.Add("Br,");
                ItemsToFind.Add("Rb,");
                ItemsToFind.Add("Sr,");
                ItemsToFind.Add("Y ,");
                ItemsToFind.Add("Zr,");
                ItemsToFind.Add("Nb,");
                ItemsToFind.Add("Mo,");
                ItemsToFind.Add("Ru,");
                ItemsToFind.Add("Rh,");
                ItemsToFind.Add("Pd,");
                ItemsToFind.Add("Ag,");
                ItemsToFind.Add("Cd,");
                ItemsToFind.Add("In,");
                ItemsToFind.Add("Sn,");
                ItemsToFind.Add("Sb,");
                ItemsToFind.Add("Te,");
                ItemsToFind.Add("I ,");
                ItemsToFind.Add("Cs,");
                ItemsToFind.Add("Ba,");
                ItemsToFind.Add("La,");
                ItemsToFind.Add("Ce,");
                ItemsToFind.Add("Pr,");
                ItemsToFind.Add("Nd,");
                ItemsToFind.Add("Pm,");
                ItemsToFind.Add("Sm,");
                ItemsToFind.Add("Eu,");
                ItemsToFind.Add("Gd,");
                ItemsToFind.Add("Tb,");
                ItemsToFind.Add("Dy,");
                ItemsToFind.Add("Ho,");
                ItemsToFind.Add("Er,");
                ItemsToFind.Add("Tm,");
                ItemsToFind.Add("Yb,");
                ItemsToFind.Add("Lu,");
                ItemsToFind.Add("Hf,");
                ItemsToFind.Add("Ta,");
                ItemsToFind.Add("W ,");
                ItemsToFind.Add("Re,");
                ItemsToFind.Add("Os,");
                ItemsToFind.Add("Ir,");
                ItemsToFind.Add("Pt,");
                ItemsToFind.Add("Au,");
                ItemsToFind.Add("Hg,");
                ItemsToFind.Add("Tl,");
                ItemsToFind.Add("Pb,");
                ItemsToFind.Add("Bi,");
                ItemsToFind.Add("Th,");
                ItemsToFind.Add("Pa,");
                ItemsToFind.Add("U ,");



                foreach (FileInfo f in fileList)
                {
                    //string = "1.2.0.36"

                    if (f.Name.Contains("data") || f.Name.Contains("zip"))
                    {
                        continue;  //skip the data1, data2, and data3 files or .zip files
                    }
                    else
                    {

                        //found a good file here, lets add the data into the correct output
                        //System.IO.StreamReader tempfile = new System.IO.StreamReader(f.OpenRead());
                        int v1 = 0, v2 = 0, v3 = 0, v4 = 0;


                        while (index < (ItemsToFind.Count))
                        {
                            //output file formats to deal with:
                            //VERSIONS 1.2.0.1 - 1.2.0.30     VERSIONS 1.2.0.31 - 1.2.0.34      VERSIONS 1.2.0.36 
                            //data 0 = sym                    data 0 = sym                      data 0 = sym                                                                  
                            //data 1 = at wt                  data 1 = at wt                    data 1 = at wt             
                            //data 2 = Mass                   data 2 = Mass                     data 2 = Mass  
                            //data 3 = Mass Unc               data 3 = Conc Unc                 data 3 = Mass Unc            
                            //data 4 = Concentration          data 4 = Concentration            data 4 = Concentration
                            //                                                                  data 5 = Conc Unc   




                            //concUnc = 

                            //Analyte Concentration Uncertainty = Reported Conc. * sqrt((Mass Uncertainty / Mass) ^ 2 + (0.03) ^ 2 + (0.01) ^ 2)

                            itemFound = 0;
                            System.IO.StreamReader tempfile2 = new System.IO.StreamReader(f.OpenRead());

                            volumeForConversion = 0.0;
                            while ((line = tempfile2.ReadLine()) != null)
                            {
                                //read each line and put it in the right place in the output string
                                if (line.Contains(ItemsToFind[index]))
                                {
                                    itemFound = 1;

                                    //if (line.Contains("Control Line"))
                                    //{
                                   //EndProcessDataValue = 22;  //process data value
                                   // }
                                   /// else
                                   // {
                                   //     EndProcessDataValue = 19;
                                   // }



                                    string[] data = line.Split(',');
                                    if (index == 0)
                                    {
                                        //string[] datetime = data[2].Split(' ');
                                        //data
                                        outputString = data[2].Insert((data[2].Length - 2), "00");
                                        outputString = outputString.Substring(0, outputString.Length - 2);
                                        outputString = outputString + ",";
                                    }
                                    //else if (index<=19)   //this looks for process data in the output file
                                    //else if (index == EndProcessDataValue)
                                    //{
                                    //    outputString = (outputString + data[2]);
                                    //}
                                    //else if (index == EndProcessDataValue - 1)
                                    //{

                                    //}
                                    else if (index < EndProcessDataValue)
                                    {


                                        outputString = (outputString + data[2] + ",");

                                        if (index == (EndProcessDataValue - 1)) //
                                        {
                                            //this is the version number string 
                                            try
                                            {
                                                string[] verno = data[2].Split('.');

                                                int.TryParse(verno[0], out v1);
                                                int.TryParse(verno[1], out v2);
                                                int.TryParse(verno[2], out v3);
                                                int.TryParse(verno[3], out v4);

                                            }
                                            catch
                                            {
                                                v1 = 0; v2 = 0; v3 = 0; v4 = 0;

                                            }
                                        }
                                    }
                                    else   //this captures the concentration from the output file
                                    {

                                        if (v4 <= 30)
                                        {


                                            //data 4 is the concentration 
                                            // update data 3 (mass uncertainty)
                                            //((mass unc/mass)^2 + (.03)^2 + (.01)^2) ^0.5
                                            string stotalUnc = string.Empty;
                                            try
                                            {
                                                double massUnc = Convert.ToDouble(data[3]);
                                                double mass = Convert.ToDouble(data[2]);
                                                double a = 0;

                                                if (mass != 0)
                                                {
                                                     a = massUnc / mass;
                                                }
                                                else
                                                {
                                                    a = 1;
                                                }
                                                double total = (a * a) + (0.03 * 0.03) + (0.01 * 0.01);

                                                double unC = Math.Pow(total, 0.5);
                                                double totalUnc = (Convert.ToDouble(data[4]) * unC);
                                                stotalUnc = totalUnc.ToString("F2");

                                                outputString = (outputString + data[4] + "," + stotalUnc + ",");

                                            }
                                            catch
                                            {
                                                stotalUnc = "-1";
                                                outputString = (outputString + data[4] + "," + stotalUnc + ",");
                                            }

                                        }

                                        else if(v4>=31 && v4<=34)
                                        {

                                            try
                                            {
                                                outputString = (outputString + data[4] + "," + data[3] + ",");
                                                //outputString = (outputString + data[4] + "," + stotalUnc + ",");
                                            }
                                            catch
                                            {
                                                outputString = (outputString + data[4] +  " err," + data[3] + " err,");

                                            }

                                        }
                                        //version >= 1.2.0.35
                                        if (v4 >= 35)
                                        { 
                                            try
                                            {
                                                outputString = (outputString + data[4] + "," + data[5] + ",");
                                                //outputString = (outputString + data[4] + "," + stotalUnc + ",");
                                            }
                                            catch
                                            {
                                                outputString = (outputString + data[4] + " err," + data[5] + " err,");

                                            }
                                        }
                                    }

                                    index++;  //look for the next thing
                                    
                                                                        
                                    if (index==ItemsToFind.Count)
                                    {
                                        index = 0;
                                        break;  
                                    }
                                    itemFound = 0;  //item has been found and added -- now to look for the next item indicated by index, from the start of the file
                                    tempfile2 = new System.IO.StreamReader(f.OpenRead());  //return to the start of the file--you are looking for something new
                                }
                                else
                                {
                                    //int x = 0;
                                    //item not found
                                    //if ()
                                }



                            }
                            if (line==null)
                            {
                                //item was not found      

                            }

                            //read through the whole file and didnt find the item
                            if (itemFound == 0 )
                            {
                                //if (Properties.Settings.Default.OutputPin7 == true)
                                //{
                                if (index < (EndProcessDataValue))
                                {
                                    outputString = (outputString + ",");
                                }
                                else
                                {
                                    outputString = (outputString + "," + ",");

                                }
                                //}
                                //else
                                //{
                                //    if (index >= EndProcessDataValue)
                                //    {
                                //        outputString = (outputString + ",");
                                //    }
                                //}
                                index++;
                            
                            }
                            else
                            {
                                tempfile2.Close();
                                index = 0;
                                break;
                            }
                        }
                        index = 0;
                        writer.WriteLine(outputString);
                        outputString = string.Empty;

                        



                    }

                }

                mtbDataOutputMessage.Text = "Output file written to:  " + outputFile;
                writer.Close();

            }
            catch (Exception Ex)
            {
                mtbDataOutputMessage.Text = "Error creating summary file.  See ErrorFile.txt";
                Logger.WriteErrorFile("Error in summary file:  Error = " + Ex.ToString());
                Logger.WriteInternalLogFile("Error in summary file:  Error = " + Ex.ToString());
            }
        }

        private void metroTextBox6_Click(object sender, EventArgs e)
        {

        }

        private void tabPage1_Click(object sender, EventArgs e)
        {

        }

        private void metroButton33_Click(object sender, EventArgs e)
        {
            //move FW to EC2
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            int retVal =AcquisitionControl.MoveFWHome(SerialManager, this);
            if (retVal == PASS)
            {
                AcquisitionControl.MoveFWEC(SerialManager, 0, 2, this);
            }
            else
            {
                UpdateFilterWheelMessage("Error Filter Wheel home function.");

            }

        }

        private void mbMaintMoveFWtoEC3_Click(object sender, EventArgs e)
        {
            int fwECEndLocal = 3;
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            int retVal = AcquisitionControl.MoveFWHome(SerialManager, this);
            if (retVal == PASS)
            {
                int retVal2 = AcquisitionControl.MoveFWEC(SerialManager, 0, fwECEndLocal, this);
                if (retVal2 == PASS)
                {
                    Logger.WriteLogFile("EC " + fwECEndLocal.ToString() + " fw MOVE RETURNED PASS.");
                    int position = 0;

                    //int returnVal27 = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);  //1=FW
                    position = AcquisitionControl.PollMotorPosition(1, SerialManager);


                    Logger.WriteLogFile("EC " + fwECEndLocal.ToString() + " (destination) motor position, after move = " + position.ToString());
                    //Logger.WriteLogFile("Check FW motor postion returned: " + returnVal27.ToString());

                    if (position.ToString().Contains(Properties.Settings.Default.FWEC3.ToString()))
                    {
                        UpdateOperationMessage("Move FW to EC3 Pass");
                        UpdateFilterWheelMessage("FW at EC3 (" + Properties.Settings.Default.FWEC3.ToString() + ")");
                    }
                    else
                    {
                        UpdateOperationMessage("Move FW to EC3 Fail");
                        UpdateFilterWheelMessage("Move FW to EC3 Fail: FW at (" + Properties.Settings.Default.FWEC3.ToString() + ")");
                    }
                }
                else
                {
                    UpdateOperationMessage("Move FW to EC3 fail");
                    UpdateFilterWheelMessage("Mov FW to EC3 fail");
                }

            }
            else
            {
                UpdateOperationMessage("Error FW Home function");
                UpdateFilterWheelMessage("Error FW home function");

            }
        }
        /*
        private void mtbMaintMoveFWtoEC1_Click(object sender, EventArgs e)
        {
            //move FW to EC1
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            int retVal = AcquisitionControl.MoveFWHome(SerialManager, this);
            if (retVal == PASS)
            {
                AcquisitionControl.MoveFWEC(SerialManager, 0, 1, this);
            }
            else
            {
                UpdateFilterWheelMessage("Error Filter Wheel home function.");
            }
        }
        */
        private void mbMoveFWtoEC2_Click(object sender, EventArgs e)
        {
            int fwECEndLocal = 2;
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            int retVal = AcquisitionControl.MoveFWHome(SerialManager, this);
            if (retVal == PASS)
            {
                int retVal2 = AcquisitionControl.MoveFWEC(SerialManager, 0, fwECEndLocal, this);
                if (retVal2 == PASS)
                {
                    Logger.WriteLogFile("EC " + fwECEndLocal.ToString() + " fw MOVE RETURNED PASS.");
                    int position = 0;

                    //int returnVal27 = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);  //1=FW
                    position = AcquisitionControl.PollMotorPosition(1, SerialManager);

                    Logger.WriteLogFile("EC " + fwECEndLocal.ToString() + " (destination) motor position, after move = " + position.ToString());
                    //Logger.WriteLogFile("Check FW motor postion returned: " + returnVal27.ToString());

                    if (position.ToString().Contains(Properties.Settings.Default.FWEC2.ToString()))
                    {
                        UpdateOperationMessage("Move FW to EC2 Pass");
                        UpdateFilterWheelMessage("FW at EC2 (" + Properties.Settings.Default.FWEC2.ToString() + ")");
                    }
                    else
                    {
                        UpdateOperationMessage("Move FW to EC2 Fail");
                        UpdateFilterWheelMessage("Move FW to EC2 Fail: FW at (" + Properties.Settings.Default.FWEC2.ToString() + ")");
                    }
                }
                else
                {
                    UpdateOperationMessage("Move FW to EC2 fail");
                    UpdateFilterWheelMessage("Mov FW to EC2 fail");
                }

            }
            else
            {
                UpdateOperationMessage("Error FW Home function");
                UpdateFilterWheelMessage("Error FW home function");

            }

        }





        private void mbMoveFWtoEC1_Click(object sender, EventArgs e)
        {
            int fwECEndLocal = 1;
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            int retVal = AcquisitionControl.MoveFWHome(SerialManager, this);
            if (retVal == PASS)
            {
                int retVal2= AcquisitionControl.MoveFWEC(SerialManager, 0, fwECEndLocal, this);
                if(retVal2==PASS)
                {
                    Logger.WriteLogFile("EC " + fwECEndLocal.ToString() + " fw MOVE RETURNED PASS.");
                    int position = 0;




                    //int returnVal27 = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);  //1=FW
                    position = AcquisitionControl.PollMotorPosition(1, SerialManager);






                    Logger.WriteLogFile("EC " + fwECEndLocal.ToString() + " (destination) motor position, after move = " + position.ToString());
                    //Logger.WriteLogFile("Check FW motor postion returned: " + returnVal27.ToString());

                    if (position.ToString().Contains(Properties.Settings.Default.FWEC1.ToString()))
                    {
                        UpdateOperationMessage("Move FW to EC1 Pass");
                        UpdateFilterWheelMessage("FW at EC1 (" + Properties.Settings.Default.FWEC1.ToString() + ")");
                    }
                    else
                    {
                        UpdateOperationMessage("Move FW to EC1 Fail");
                        UpdateFilterWheelMessage("Move FW to EC1 Fail: FW at (" + Properties.Settings.Default.FWEC1.ToString() + ")");
                    }
                }
                else
                {
                    UpdateOperationMessage("Move FW to EC1 fail");
                    UpdateFilterWheelMessage("Mov FW to EC1 fail"); 
                }

            }
            else
            {
                UpdateOperationMessage("Error FW Home function");
                UpdateFilterWheelMessage("Error FW home function");

            }
       
        }

        private void mbMoveDynamicRodToEcalPosition_Click(object sender, EventArgs e)
        {


            //move DR home
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;


            try
            {
                int retVal;
                retVal = AcquisitionControl.MoveRodHome(SerialManager, this);

                if (retVal == PASS)
                {



                    AcquisitionControl.MoveRod(SerialManager, Properties.Settings.Default.EcalRodPosition, this);

                    int getRodPositionValue = 0;
                    getRodPositionValue = AcquisitionControl.PollMotorPosition(4, SerialManager);


                    //Thread.Sleep(500);
                    //check for stable position read 
                    //int posOld = 0;
                    //int posNew = 1;
                    //int retv = FAIL;
                    //int counter = 0;
                    //do
                    //{
                    //    retv = AcquisitionControl.CheckMotorPosition(SerialManager, 4, out getRodPositionValue);
                    //    if (retv == PASS)
                    //    {
                    //        posNew = getRodPositionValue;
                    //    }

                    //    if (posNew == posOld)
                    //    {
                    //        break;
                    //    }

                    //    posOld = posNew;
                    //    counter++;
                    //    Thread.Sleep(500);
                    //} while (counter < 60);







                    if (getRodPositionValue == Properties.Settings.Default.UpscaleRodPosition)
                    {
                        UpdateDynamicRodMessage("DR at Upscale Position (" + getRodPositionValue.ToString() + ")");
                    }
                    else if (getRodPositionValue == Properties.Settings.Default.EcalRodPosition)
                    {
                        UpdateDynamicRodMessage("DR at Ecal Position (" + getRodPositionValue.ToString() + ")");
                    }
                    else
                    {
                        UpdateDynamicRodMessage("DR at position (" + getRodPositionValue.ToString() + ")");
                    }







                }
                else
                {
                    UpdateDynamicRodMessage("Error:  DR home function.");
                }
            }
            catch(Exception Ex)
            {
                Logger.WriteErrorFile("Error: Move DR to Ecal.");
                Logger.WriteLogFile("Error: Move DR to Ecal.  Ex = " + Ex.ToString());
                Logger.WriteInternalLogFile("Error: Move DR to Ecal.  Ex = " + Ex.ToString());
                UpdateDynamicRodMessage("Error:  in move DR to Ecal");
            }

        }

        private void mbMoveDynamicRodtoUpscalePosition_Click(object sender, EventArgs e)
        {
            //move DR home
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;


            int retVal;
            try
            {


                retVal = AcquisitionControl.MoveRodHome(SerialManager, this);
                if (retVal == PASS)
                {

                    AcquisitionControl.MoveRod(SerialManager, Properties.Settings.Default.UpscaleRodPosition, this);
                    int getRodPositionValue = 0;
                    getRodPositionValue = AcquisitionControl.PollMotorPosition(4, SerialManager);

                    //AcquisitionControl.CheckMotorPosition(SerialManager, 4, out getRodPositionValue);
                    //Thread.Sleep(500);
                    //check for stable position read 
                    //int posOld = 0;
                    //int posNew = 1;
                    //int retv = FAIL;
                    //int counter = 0;
                    //do
                    //{
                    //    retv = AcquisitionControl.CheckMotorPosition(SerialManager, 4, out getRodPositionValue);
                    //    if (retv == PASS)
                    //    {
                    //        posNew = getRodPositionValue;
                    //    }

                    //    if (posNew == posOld)
                    //    {
                    //        break;
                    //    }

                    //    posOld = posNew;
                    //    counter++;
                    //    Thread.Sleep(500);
                    //} while (counter < 60);



                    if (getRodPositionValue == Properties.Settings.Default.UpscaleRodPosition)
                    {
                        UpdateDynamicRodMessage("DR at Upscale Position (" + getRodPositionValue.ToString() + ")");
                    }
                    else if (getRodPositionValue == Properties.Settings.Default.EcalRodPosition)
                    {
                        UpdateDynamicRodMessage("DR at Ecal Position (" + getRodPositionValue.ToString() + ")");
                    }
                    else
                    {
                        UpdateDynamicRodMessage("DR at position (" + getRodPositionValue.ToString() + ")");
                    }

                }
                else
                {
                    UpdateDynamicRodMessage("Error:  Move DR Home.");

                }
            }
            catch(Exception Ex)
            {
                Logger.WriteErrorFile("Error: in Move DR to Upscale.");
                Logger.WriteInternalLogFile("Error: in Move DR to Upscale.  Ex = " + Ex.ToString());
                Logger.WriteLogFile("Error: in Move DR to Upscale.  Ex = " + Ex.ToString());
                UpdateDynamicRodMessage("Error:  in move DR to Upscale");

            }
        }

        private void metroButton2_Click_1(object sender, EventArgs e)
        {

            try
            {
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

                if (mbRunManualAcq.Text == "Run Acquisition")
                {
                    mbRunManualAcq.Text = "Cancel Acquisition";
                    mtbMaintCheckMessage.Text = "";



                    if (mrbEcal.Checked == true)
                    {
                        DateTimeFromStartButton = DateTime.Now;
                        DateTimeFromStartButtonInternalLog = DateTime.Now;
                        DateTimeFromStartButtonErrorLog = DateTime.Now;
                        DateTimeFromStartButtonWarningLog = DateTime.Now;

                        //Perform Ecal
                        //metroTextBox2.Text = "";
                        //metroTextBox2.Enabled = false;
                        //metroTextBox2.Refresh();

                        BackgroundManager.m_oWorkerEcal.RunWorkerAsync();
                        mrbEcal.Enabled = false;
                        mrbUpscale.Enabled = false;
                        mrbManual.Enabled = false;


                    }
                    else if (mrbUpscale.Checked == true)
                    {
                        DateTimeFromStartButton = DateTime.Now;
                        DateTimeFromStartButtonInternalLog = DateTime.Now;
                        DateTimeFromStartButtonErrorLog = DateTime.Now;
                        DateTimeFromStartButtonWarningLog = DateTime.Now;


                        //metroTextBox2.Text = "";
                        //metroTextBox2.Enabled = false;
                        //metroTextBox2.Refresh();
                        //perform upscale
                        mtbMaintCheckMessage.Text = "Preparing to run manual Upscale...";
                        mtbMaintCheckMessage.Refresh();
                        Thread.Sleep(1000);
                        BackgroundManager.m_oWorkerUpscale.RunWorkerAsync();  //200
                        mrbEcal.Enabled = false;
                        mrbUpscale.Enabled = false;
                        mrbManual.Enabled = false;



                    }
                    else if (mrbManual.Checked == true)
                    {
                        DateTimeFromStartButton = DateTime.Now;
                        DateTimeFromStartButtonInternalLog = DateTime.Now;
                        DateTimeFromStartButtonErrorLog = DateTime.Now;
                        DateTimeFromStartButtonWarningLog = DateTime.Now;


                        //metroTextBox2.Enabled = true;
                        //metroTextBox2.Text = "";
                        //metroTextBox2.Refresh();
                        if (metroRadioButton1.Checked == true)
                        {
                            mtbMaintCheckMessage.Text = "EC1";
                        }
                        if (metroRadioButton2.Checked == true)
                        {
                            mtbMaintCheckMessage.Text = "EC2";
                        }
                        if (metroRadioButton3.Checked == true)
                        {
                            mtbMaintCheckMessage.Text = "EC3";
                        }
                        if (metroRadioButton4.Checked == true)
                        {
                            mtbMaintCheckMessage.Text = "EC4";
                        }



                        if (metroRadioButton1.Checked == false && metroRadioButton2.Checked == false && metroRadioButton3.Checked == false && metroRadioButton4.Checked == false)
                        {
                            mbRunManualAcq.Text = "Run Acquisition";
                            mtbMaintCheckMessage.Text = "Select EC1,2,3, or 4";

                        }
                        else
                        {
                            mtbMaintCheckMessage.Text = "Preparing to run manual acquisition...";
                            mtbMaintCheckMessage.Refresh();
                            Thread.Sleep(1000);
                            BackgroundManager.m_oWorkerManualAcq.RunWorkerAsync();

                            mrbEcal.Enabled = false;
                            mrbUpscale.Enabled = false;
                            mrbManual.Enabled = false;
                        }



                    }
                    else
                    {
                        mtbMaintCheckMessage.Text = "Must select Acquisition:  Manual, Ecal, or Upscale";
                    }

                    //check the type of run
                    //manual
                    //ecal
                    //upscale

                }
                else
                {
                    //cancel acquistion
                    mbRunManualAcq.Enabled = false;

                    //Application.DoEvents();  //clear the mouse clicks -- tbd if this works as expected

                    mbRunManualAcq.Text = "Run Acquisition";

                    metroStatusButton.BackColor = Color.Gray;

                    try
                    {
                        if (BackgroundManager.m_oWorkerAcq.IsBusy)
                        {
                            BackgroundManager.m_oWorkerAcq.CancelAsync();
                        }
                    }
                    catch
                    {

                    }

                    try
                    {
                        AcquisitionControl.StopXrsfpAcquisition();
                    }
                    catch
                    {

                    }
                    //add clear of modbus error (address 800)
                    ClearModbusAlarm();

                    try
                    {
                        if (BackgroundManager.m_oWorkerTubeSeasoning.IsBusy)
                        {
                            BackgroundManager.m_oWorkerTubeSeasoning.CancelAsync();
                        }
                    }
                    catch (Exception)
                    {
                        //Logger.WriteInternalLogFile("Tube seasoning stop.");
                    }

                    try
                    {
                        if (BackgroundManager.m_oWorkerEcal.IsBusy)
                        {

                            BackgroundManager.m_oWorkerEcal.CancelAsync();
                        }
                    }
                    catch
                    {

                    }

                    try
                    {
                        if (BackgroundManager.m_oWorkerUpscale.IsBusy)
                        {
                            Logger.WriteInternalLogFile("Upscale worker busy.");
                            BackgroundManager.m_oWorkerUpscale.CancelAsync();
                        }
   
                        
                    }
                    catch (Exception Ex)
                    {
                        Logger.WriteInternalLogFile("Ex cancel async Upscale.  Ex=" + Ex.ToString());

                    }
                    try
                    {

                        if (BackgroundManager.m_oWorkerManualAcq.IsBusy)
                        {

                            BackgroundManager.m_oWorkerManualAcq.CancelAsync();
                        }
                    }
                    catch
                    {
                    }
                    mtbMaintCheckMessage.Text = "Acquisition Cancelled";

                    mrbEcal.Enabled = true;
                    mrbUpscale.Enabled = true;
                    mrbManual.Enabled = true;


                    //wait till the threads cancel out.
                    //waiting = 1;
                    //int counter = 0;
                    //do
                    //{

                    //    counter++;
                    //    Thread.Sleep(100);
                    //} while (waiting == 1 && counter < 100);
                    RampXraysToZero();
                    mbRunManualAcq.Enabled = true;



                }
            }
            catch (Exception )
            {
                mbRunManualAcq.Text = "Run Acquisition";
                mtbMaintCheckMessage.Text = "Acquisition Cancelled";
                mbRunManualAcq.Enabled = false;
                Thread.Sleep(1000);
                mbRunManualAcq.Enabled = true;
                Thread.Sleep(100);
                mrbEcal.Enabled = true;
                mrbUpscale.Enabled = true;
                mrbManual.Enabled = true;

                //

            }




        }

        private void mrbManual_CheckedChanged(object sender, EventArgs e)
        {
            if(mrbManual.Checked==true)
            {
                metroRadioButton1.Enabled = true;
                metroRadioButton2.Enabled = true;
                metroRadioButton3.Enabled = true;
                metroRadioButton4.Enabled = true;
                metroTextBox2.Text = "";
                metroTextBox2.Enabled = true;
                metroTextBox2.Refresh();

            }

        }

        private void mrbEcal_CheckedChanged(object sender, EventArgs e)
        {
            if (mrbEcal.Checked == true)
            {
                metroRadioButton1.Enabled = false;
                metroRadioButton2.Enabled = false;
                metroRadioButton3.Enabled = false;
                metroRadioButton4.Enabled = false;
                metroRadioButton1.Checked = false;
                metroRadioButton2.Checked = false;
                metroRadioButton3.Checked = false;
                metroRadioButton4.Checked = false;
                metroTextBox2.Text = "";
                metroTextBox2.Enabled = false;
                metroTextBox2.Refresh();

            }


        }

        private void mrbUpscale_CheckedChanged(object sender, EventArgs e)
        {
            if (mrbUpscale.Checked == true)
            {
                metroRadioButton1.Enabled = false;
                metroRadioButton2.Enabled = false;
                metroRadioButton3.Enabled = false;
                metroRadioButton4.Enabled = false;
                metroRadioButton1.Checked = false;
                metroRadioButton2.Checked = false;
                metroRadioButton3.Checked = false;
                metroRadioButton4.Checked = false;
                metroTextBox2.Text = "";
                metroTextBox2.Enabled = false;
                metroTextBox2.Refresh();

            }

        }

        private void Form1_Load(object sender, EventArgs e)
        {

        }

        private void metroTextBox5_Click(object sender, EventArgs e)
        {

        }

        private void metroLabel85_Click(object sender, EventArgs e)
        {

        }

        private void mbXrfSaveSpectra_Click(object sender, EventArgs e)
        {
            SaveButton = 1;
        }

        private void metroLabel106_Click(object sender, EventArgs e)
        {

        }


        /// <summary>
        /// invalid
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void metroButton10_Click(object sender, EventArgs e)
        {
            
            if (mbEnableChangesCalibrationFlow.Text == "Enable Changes")
            {
                //enable flow calibration changes
                metroToggle1.Enabled = true;
                metroToggle2.Enabled = true;
                metroToggleFlowCal.Enabled = true;
                metroToggleLeakCheck.Enabled = true;
                mbPumpOn.Enabled = true;
                rbMetro150.Enabled = true;
                rbMetro167.Enabled = true;
                rbMetro184.Enabled = true;
                bMetroEnterDataButton.Enabled = true;
                mbEnableChangesCalibrationFlow.Text = "Disable Changes";
            }
            else if (mbEnableChangesCalibrationFlow.Text == "Disable Changes")
            {

                metroToggle1.Enabled = false;
                metroToggle2.Enabled = false;
                metroToggleFlowCal.Enabled = false;
                metroToggleLeakCheck.Enabled = false;
                mbPumpOn.Enabled = false;
                rbMetro150.Enabled = false;
                rbMetro167.Enabled = false;
                rbMetro184.Enabled = false;
                bMetroEnterDataButton.Enabled = false;

                //
                //yint and slope and t and p offset re read from settings


                mbEnableChangesCalibrationFlow.Text = "Enable Changes";


            }



        }

        private void metroButton11_Click(object sender, EventArgs e)
        {
            //disable flow calibration buttons:
            metroToggle1.Enabled = false;
            metroToggle2.Enabled = false;
            metroToggleFlowCal.Enabled = false;
            metroToggleLeakCheck.Enabled = false;
            mbPumpOn.Enabled = false;
            rbMetro150.Enabled = false;
            rbMetro167.Enabled = false;
            rbMetro184.Enabled = false;
            bMetroEnterDataButton.Enabled = false;


        }

        private void metroButton12_Click_1(object sender, EventArgs e)
        {



            try
            {
                AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;


                int returnVal27 = AcquisitionControl.AutoAnalyze();
                mtbMaintCheckMessage.Text = "AutoAnalyze result = " + returnVal27.ToString();
                mtbMaintCheckMessage.Refresh();

            }
            catch (Exception Ex)
            {

                mtbMaintCheckMessage.Text = "Error in AutoAnalyze. See temp/errorfile.txt"; 
                mtbMaintCheckMessage.Refresh();

                Logger.WriteErrorFile("Error in maint. auto analyze:  Ex = " + Ex.ToString());

            }





        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mbUpscaleOutputToFile_Click(object sender, EventArgs e)
        {  //qa output to summary file

            try
            {
                mtbQAStatus.Text = "";
                mtbQAStatus.Text = "Collecting Data from Start Date to End Date.";
                mtbQAStatus.Refresh();
                Thread.Sleep(500);

                //gether all files in directory,
                //read through them and create a final output file

                //get start time
                DateTime Start = mDateTimeQAStart.Value;

                //get end time
                DateTime End = mDateTimeQAEnd.Value;

                var directory = new DirectoryInfo("c:/Upscale_Data/");
                DateTime from_date_prelim = Start;
                DateTime from_date = from_date_prelim.AddDays(-1);
                DateTime to_date_prelim = End;
                DateTime to_date = to_date_prelim.AddDays(1);

                var fileList = directory.GetFiles()    //this does not do the >= or <= only < or >, thus the adjustment above
                    .Where(file => file.LastWriteTime >= from_date && file.LastWriteTime <= to_date);


                //System.Linq.IOrderedEnumerable<string> fileItems = Directory.GetFiles(@"C:\Upscale_Data", "*.txt").OrderByDescending(d => new FileInfo(d).CreationTime);

                //update to sort all files by creation date:

                //string path = @"C:\Upscale_Data";
                //DirectoryInfo di = new DirectoryInfo(path);
                //FileInfo[] fiArray = di.GetFiles();
                //Array.Sort(fiArray, (x, y) => StringComparer.OrdinalIgnoreCase.Compare(x.CreationTime, y.CreationTime));


                //                Array.Sort(fiArray, (x, y) => StringComparer.OrdinalIgnoreCase.Compare(Start, End));
                //Array.Sort(fiArray, (x, y) => StringComparer.OrdinalIgnoreCase.Compare(from_date,to_date));


                //foreach (FileInfo fi in fiArray)
                //{

                //}





                string line;
               // string appendString = "";
                //int counter;
                string outputFile;

                int index = 0;
                int itemFound = 0;


                DateTime now = DateTime.Now;
                //TextWriter tw = new StreamWriter("c:/process_data/" + now.Month.ToString() + "_" + now.Day.ToString() + "_" + now.Year.ToString() + "__" + now.Hour.ToString() + "_" + now.Minute.ToString() + "_" + now.Second.ToString() + "outout.txt");


                //outputFile = "C:/temp/summary_" + now.Month.ToString() + "_" + now.Day.ToString() + "_" + now.Year.ToString() + "__" + now.Hour.ToString() + "_" + now.Minute.ToString() + "_" + now.Second.ToString() + ".txt";
                outputFile = "C:\\temp\\summary_QA_" + from_date_prelim.Month.ToString() + "_" + from_date_prelim.Day.ToString() + "_" + from_date_prelim.Year.ToString() + "__" + to_date_prelim.Month.ToString() + "_" + to_date_prelim.Day.ToString() + "_" + to_date_prelim.Year.ToString() + ".txt";
                mtbQAStatus.Text = "QA Output file written to:  " + outputFile;

                string outputString = string.Empty;
                string titleString1 = string.Empty;
                titleString1 = ", CHROMIUM , NIOBIUM , CADMIUM , LEAD ";
                //                string titleString1 = ", , , , , , , , , , , , , , , , , , , ALUMINIUM (mg/m3), SILICON (ng/m3), PHOSPORUS (ng/m3), SULPHUR (ng/m3), CLORINE (ng/m3), POTASSIUM (ng/m3), CALCIUM (ng/m3), SCANDIUM (ng/m3), TITANIUM (ng/m3), VANADIUM (ng/m3), CHROMIUM (ng/m3), MANGANESE (ng/m3), IRON (ng/m3), COBALT (ng/m3), NICKEL (ng/m3), COPPER (ng/m3), ZINC (ng/m3), GALLIUM (ng/m3), GERMANIUM (ng/m3), ARSENIC (ng/m3), SELENIUM (ng/m3), BROMINE (ng/m3), RUBINIUM (ng/m3), STRONTIUM (ng/m3), YTTRIUM (ng/m3), ZIRCONIUM (ng/m3), NIOBIUM (ng/m3), MOLYBDENUM (ng/m3), RUTHENIUM (ng/m3), RHODIUM (ng/m3), PALLADIUM (ng/m3), SILVER (ng/m3), CADMIUM (ng/m3), INDIUM (ng/m3), TIN (ng/m3), ANTIMONY (ng/m3), TELLURIUM (ng/m3), IODINE (ng/m3), CAESIUM (ng/m3), BARIUM (ng/m3), LANTHANUM (ng/m3), CERIUM (ng/m3), PRASEODYMIUM (ng/m3), NEODYMIUM (ng/m3), SAMARIUM (ng/m3), EUROPIUM (ng/m3), GADOLINIUM (ng/m3), TERBIUM (ng/m3), DYSPROSIUM (ng/m3), HOLMIUM (ng/m3), ERBIUM (ng/m3), THULIUM (ng/m3), YTTERBIUM (ng/m3), LUTETIUM (ng/m3), HAFNIUM (ng/m3), TANTALUM (ng/m3), TUNGSTEN (ng/m3), RHENIUM (ng/m3), OSMIUM (ng/m3), IRIDIUM (ng/m3), PLATINUM (ng/m3), GOLD (ng/m3), MERCURY (ng/m3), THALLIUM (ng/m3), LEAD (ng/m3), BISMUTH (ng/m3), THORIUM (ng/m3), PROTACTINIUM (ng/m3), URANIUM (ng/m3)";
                string titleString2 = string.Empty;
                titleString2 = "TIME, Cr 24 (ng), Nb 41(ng), Cd 48 (ng), Pb 82 (ng)";


                StreamWriter writer = new StreamWriter(outputFile);

                writer.WriteLine(titleString1);
                writer.WriteLine(titleString2);


                List<string> ItemsToFind = new List<string>();

                ItemsToFind.Add("Sample Start time");     //1
                ItemsToFind.Add("Start Time");     
                //ItemsToFind.Add("Ambient");
                //ItemsToFind.Add("Sample");
                //ItemsToFind.Add("BP");
                //ItemsToFind.Add("Tape");  //5
                //ItemsToFind.Add("Flow 25");
                //ItemsToFind.Add("Flow Act");
                //ItemsToFind.Add("Flow Std");
                //ItemsToFind.Add("Volume");
                //ItemsToFind.Add("Tube Temp"); //10
                //ItemsToFind.Add("Enclosure Temp");
                //ItemsToFind.Add("Filament Monitor");
                //ItemsToFind.Add("SDD Temp");
                //ItemsToFind.Add("DDP Temp");
                //ItemsToFind.Add("Relative Humidity");  //15
                //ItemsToFind.Add("Wind Speed");
                //ItemsToFind.Add("Wind Direction");
                //ItemsToFind.Add("Sample Time");  //18
                //ItemsToFind.Add("Alarm");
                //
                //ItemsToFind.Add("Al,");
                //ItemsToFind.Add("Si,");
                //ItemsToFind.Add("P ,");
                //ItemsToFind.Add("S ,");
                //ItemsToFind.Add("Cl,");
                //ItemsToFind.Add("K ,");
                //ItemsToFind.Add("Ca,");
                //ItemsToFind.Add("Sc,");
                //ItemsToFind.Add("Ti,");
                //ItemsToFind.Add("V ,");
                ItemsToFind.Add("Cr,");    //2
                //ItemsToFind.Add("Mn,");
                //ItemsToFind.Add("Fe,");
                //ItemsToFind.Add("Co,");
                //ItemsToFind.Add("Ni,");
                //ItemsToFind.Add("Cu,");
                //ItemsToFind.Add("Zn,");
                //ItemsToFind.Add("Ga,");
                //ItemsToFind.Add("As,");
                //ItemsToFind.Add("Se,");
                //ItemsToFind.Add("Br,");
                //ItemsToFind.Add("Rb,");
                //ItemsToFind.Add("Sr,");
                //ItemsToFind.Add("Ti,");
                //ItemsToFind.Add("Y ,");
                //ItemsToFind.Add("Zr,");
                ItemsToFind.Add("Nb,");
                //ItemsToFind.Add("Mo,");
                //ItemsToFind.Add("Ru,");
                //ItemsToFind.Add("Rh,");
                //ItemsToFind.Add("Pd,");
                //ItemsToFind.Add("Ag,");
                ItemsToFind.Add("Cd,");
                //ItemsToFind.Add("In,");
                //ItemsToFind.Add("Sn,");
                //ItemsToFind.Add("Sb,");
                //ItemsToFind.Add("Te,");
                //ItemsToFind.Add("I ,");
                //ItemsToFind.Add("Cs,");
                //ItemsToFind.Add("Ba,");
                //ItemsToFind.Add("La,");
                //ItemsToFind.Add("Ce,");
                //ItemsToFind.Add("Pr,");
                //ItemsToFind.Add("Nd,");
                //ItemsToFind.Add("Sm,");
                //ItemsToFind.Add("Eu,");
                //ItemsToFind.Add("Gd,");
                //ItemsToFind.Add("Tb,");
                //ItemsToFind.Add("Dy,");
                //ItemsToFind.Add("Ho,");
                //ItemsToFind.Add("Er,");
                //ItemsToFind.Add("Tm,");
                //ItemsToFind.Add("Yb,");
                //ItemsToFind.Add("Lu,");
                //ItemsToFind.Add("Hf,");
                //ItemsToFind.Add("Ta,");
                //ItemsToFind.Add("W ,");
                //ItemsToFind.Add("Re,");
                //ItemsToFind.Add("Os,");
                //ItemsToFind.Add("Ir,");
                //ItemsToFind.Add("Pt,");
                //ItemsToFind.Add("Au,");
                //ItemsToFind.Add("Hg,");
                //ItemsToFind.Add("Tl,");
                ItemsToFind.Add("Pb,");
                //ItemsToFind.Add("Bi,");
                //ItemsToFind.Add("Th,");
                //ItemsToFind.Add("Pa,");
                //ItemsToFind.Add("U ,");

                string dateLine = string.Empty;
                string CrLine = string.Empty;
                string NbLine = string.Empty;
                string CdLine = string.Empty;
                string PbLine = string.Empty;

                //foreach (string item in fileItems)
                //{

                //}
                int ValidDateTimeFound = 0;

              foreach (FileInfo f in fileList)
              {

                    if (f.Name.Contains("data") || f.Name.Contains("zip"))
                    {
                        continue;  //skip the data1, data2, and data3 files
                    }
                    else
                    {

                        dateLine = string.Empty;
                        CrLine = string.Empty;
                        NbLine = string.Empty;
                        CdLine = string.Empty;
                        PbLine = string.Empty;

                        //found a good file here, lets add the data into the correct output
                        //System.IO.StreamReader tempfile = new System.IO.StreamReader(f.OpenRead());


                        while (index < (ItemsToFind.Count))
                        {

                            itemFound = 0;
                            System.IO.StreamReader tempfile2 = new System.IO.StreamReader(f.OpenRead());

                            while ((line = tempfile2.ReadLine()) != null)
                            {
                                //read each line and put it in the right place in the output string
                                if (line.Contains(ItemsToFind[index]))
                                {
                                    itemFound = 1;

                                    string[] data = line.Split(',');
                                    if ((index == 0 || index==1)  && ValidDateTimeFound==0)
                                    {
                                        outputString = data[2].Insert((data[2].Length - 2), "00");
                                        outputString = outputString.Substring(0, outputString.Length - 2);
                                        dateLine = outputString;
                                        ValidDateTimeFound = 1;
                                    }
                                    else if(index>0)
                                    {
                                        outputString = line;
                                        if(outputString.Contains("Cr"))
                                        {
                                            CrLine = data[1];
                                        }
                                        else if(outputString.Contains("Nb"))
                                        {
                                            NbLine = data[1];
                                        }
                                        else if(outputString.Contains("Cd"))
                                        {
                                            CdLine = data[1];
                                        }
                                        else if(outputString.Contains("Pb"))
                                        {
                                            PbLine = data[1];
                                        }

                                    }

                                    index++;  //look for the next thing

                                    if (index == ItemsToFind.Count)
                                    {
                                        index = 0;
                                        //ValidDateTimeFound = 0;
                                        break;
                                    }
                                    itemFound = 0;  //item has been found and added -- now to look for the next item indicated by index, from the start of the file
                                    tempfile2 = new System.IO.StreamReader(f.OpenRead());  //return to the start of the file--you are looking for something new
                                }
                                else
                                {
                                    //int x = 0;
                                    //item not found
                                    //outputString = outputString + ",";
                                    //if ()
                                }



                            }
                            if (line == null)
                            {
                                //item was not found      
                            }

                            //read through the whole file and didnt find the item
                            if (itemFound == 0)
                            {
                                index++;

                            }
                            else
                            {
                                tempfile2.Close();
                                index = 0;
                                //ValidDateTimeFound = 0;
                                break;
                            }
                        }
                        //appendString += "\r\n";

                        //write the string to the output file
                        //using (StreamWriter writer = new StreamWriter(outputFile))
                        //{
                        //tempfile2.Close();
                        index = 0;
                        ValidDateTimeFound = 0;
                        

                        writer.WriteLine(dateLine+","+CrLine+","+NbLine+","+CdLine+","+PbLine);
                        outputString = string.Empty;
                        dateLine = string.Empty;
                        CrLine = string.Empty;
                        NbLine = string.Empty;
                        CdLine = string.Empty;
                        PbLine = string.Empty;
                        //}




                    }

              }

                mtbQAStatus.Text = "Output file written to:  " + outputFile;
                writer.Close();

            }
            catch (Exception Ex)
            {
                mtbQAStatus.Text = "Error creating QA summary file.  See ErrorFile.txt";
                Logger.WriteErrorFile("Error creating QA summary file. Error = " + Ex.ToString());
                Logger.WriteInternalLogFile("Error in qa summary file.  Ex = " + Ex.ToString());
            }




        }

        private void metroPanel32_Paint(object sender, PaintEventArgs e)
        {   //output file logic for upscale

            try
            {
                mtbDataOutputMessage.Text = "";
                mtbDataOutputMessage.Text = "Collecting Data from Start Date to End Date.";
                mtbDataOutputMessage.Refresh();
                Thread.Sleep(500);

                //gether all files in directory,
                //read through them and create a final output file

                //get start time
                DateTime Start = mdtStart.Value;

                //get end time
                DateTime End = mdtEnd.Value;

                var directory = new DirectoryInfo("c:/process_data/");
                DateTime from_date_prelim = Start;
                DateTime from_date = from_date_prelim.AddDays(-1);
                DateTime to_date_prelim = End;
                DateTime to_date = to_date_prelim.AddDays(1);

                var fileList = directory.GetFiles()    //this does not do the >= or <= only < or >, thus the adjustment above
                    .Where(file => file.LastWriteTime >= from_date && file.LastWriteTime <= to_date);

                string line;
               // string appendString = "";
               // int counter;
                string outputFile;

                int index = 0;
                int itemFound = 0;


                DateTime now = DateTime.Now;
                //TextWriter tw = new StreamWriter("c:/process_data/" + now.Month.ToString() + "_" + now.Day.ToString() + "_" + now.Year.ToString() + "__" + now.Hour.ToString() + "_" + now.Minute.ToString() + "_" + now.Second.ToString() + "outout.txt");


                //outputFile = "C:/temp/summary_" + now.Month.ToString() + "_" + now.Day.ToString() + "_" + now.Year.ToString() + "__" + now.Hour.ToString() + "_" + now.Minute.ToString() + "_" + now.Second.ToString() + ".txt";
                outputFile = "C:\\temp\\summary_" + from_date_prelim.Month.ToString() + "_" + from_date_prelim.Day.ToString() + "_" + from_date_prelim.Year.ToString() + "__" + to_date_prelim.Month.ToString() + "_" + to_date_prelim.Day.ToString() + "_" + to_date_prelim.Year.ToString() + ".txt";
                mtbDataOutputMessage.Text = "Output file written to:  " + outputFile;

                string outputString = string.Empty;
                string titleString1 = string.Empty;
                titleString1 = ", , , , , , , , , , , , , , , , , , , ALUMINIUM , SILICON , PHOSPORUS , SULPHUR , CLORINE , POTASSIUM , CALCIUM , SCANDIUM , TITANIUM , VANADIUM , CHROMIUM , MANGANESE , IRON , COBALT , NICKEL , COPPER , ZINC , GALLIUM , GERMANIUM , ARSENIC , SELENIUM , BROMINE , RUBINIUM , STRONTIUM , YTTRIUM , ZIRCONIUM , NIOBIUM , MOLYBDENUM , RUTHENIUM , RHODIUM , PALLADIUM , SILVER , CADMIUM , INDIUM , TIN , ANTIMONY , TELLURIUM , IODINE , CESIUM , BARIUM , LANTHANUM , CERIUM , PRASEODYMIUM , NEODYMIUM , SAMARIUM , EUROPIUM , GADOLINIUM , TERBIUM , DYSPROSIUM , HOLMIUM , ERBIUM , THULIUM , YTTERBIUM , LUTETIUM , HAFNIUM , TANTALUM , TUNGSTEN , RHENIUM , OSMIUM , IRIDIUM , PLATINUM , GOLD , MERCURY , THALLIUM , LEAD , BISMUTH , THORIUM , PROTACTINIUM , URANIUM ";
                //                string titleString1 = ", , , , , , , , , , , , , , , , , , , ALUMINIUM (mg/m3), SILICON (ng/m3), PHOSPORUS (ng/m3), SULPHUR (ng/m3), CLORINE (ng/m3), POTASSIUM (ng/m3), CALCIUM (ng/m3), SCANDIUM (ng/m3), TITANIUM (ng/m3), VANADIUM (ng/m3), CHROMIUM (ng/m3), MANGANESE (ng/m3), IRON (ng/m3), COBALT (ng/m3), NICKEL (ng/m3), COPPER (ng/m3), ZINC (ng/m3), GALLIUM (ng/m3), GERMANIUM (ng/m3), ARSENIC (ng/m3), SELENIUM (ng/m3), BROMINE (ng/m3), RUBINIUM (ng/m3), STRONTIUM (ng/m3), YTTRIUM (ng/m3), ZIRCONIUM (ng/m3), NIOBIUM (ng/m3), MOLYBDENUM (ng/m3), RUTHENIUM (ng/m3), RHODIUM (ng/m3), PALLADIUM (ng/m3), SILVER (ng/m3), CADMIUM (ng/m3), INDIUM (ng/m3), TIN (ng/m3), ANTIMONY (ng/m3), TELLURIUM (ng/m3), IODINE (ng/m3), CAESIUM (ng/m3), BARIUM (ng/m3), LANTHANUM (ng/m3), CERIUM (ng/m3), PRASEODYMIUM (ng/m3), NEODYMIUM (ng/m3), SAMARIUM (ng/m3), EUROPIUM (ng/m3), GADOLINIUM (ng/m3), TERBIUM (ng/m3), DYSPROSIUM (ng/m3), HOLMIUM (ng/m3), ERBIUM (ng/m3), THULIUM (ng/m3), YTTERBIUM (ng/m3), LUTETIUM (ng/m3), HAFNIUM (ng/m3), TANTALUM (ng/m3), TUNGSTEN (ng/m3), RHENIUM (ng/m3), OSMIUM (ng/m3), IRIDIUM (ng/m3), PLATINUM (ng/m3), GOLD (ng/m3), MERCURY (ng/m3), THALLIUM (ng/m3), LEAD (ng/m3), BISMUTH (ng/m3), THORIUM (ng/m3), PROTACTINIUM (ng/m3), URANIUM (ng/m3)";
                string titleString2 = string.Empty;
                titleString2 = "TIME, AT (C), SAMPLE (C), BP (mmHg), TAPE (mmHg), FLOW 25 (slpm), FLOW ACT (lpm), FLOW STD (slpm), VOLUME (m3), TUBE (C), ENCLOSURE (C), FILAMENT (V), SDD (C), DDP (C), RH (%), WIND (m/s), WIND DIR (deg), SAMPLE TIME (min), ALARM, Al 13 (mg/m3), Si 14 (ng/m3), P 15 (ng/m3), S 16 (ng/m3), Cl 17 (ng/m3),  K 19 (ng/m3), Ca 20 (ng/m3), Sc 21 (ng/m3), Ti 22 (ng/m3), V 23 (ng/m3), Cr 24 (ng/m3), Mn 25 (ng/m3), Fe 26 (ng/m3), Co 27 (ng/m3), Ni 28 (ng/m3), Cu 29 (ng/m3), Zn 30 (ng/m3), Ga 31 (ng/m3), Ge 32 (ng/m3), As 33 (ng/m3), Se 34 (ng/m3), Br 35 (ng/m3), Rb 37 (ng/m3), Sr 38 (ng/m3), Y 39 (ng/m3), Zr 40 (ng/m3), Nb 41(ng/m3), Mo 42 (ng/m3), Ru 44 (ng/m3), Rh 45 (ng/m3), Pd 46 (ng/m3), Ag 47 (ng/m3), Cd 48 (ng/m3), In 49 (ng/m3), Sn 50 (ng/m3), Sb 51 (ng/m3), Te 52 (ng/m3), I 53 (ng/m3), Cs 55 (ng/m3), Ba 56 (ng/m3), La 57 (ng/m3), Ce 58 (ng/m3), Pr 59 (ng/m3), Nd 60 (ng/m3), Pm 61 (ng/m3), Sm 62 (ng/m3), Eu 63 (ng/m3), Gd 64 (ng/m3), Tb 65 (ng/m3), Dy 66 (ng/m3), Ho 67 (ng/m3), Er 68 (ng/m3), Tm 69 (ng/m3), Yb 70 (ng/m3), Lu 71 (ng/m3), Hf 72 (ng/m3), Ta 73 (ng/m3), W 74 (ng/m3), Re 75 (ng/m3), Os 76 (ng/m3), Ir 77 (ng/m3), Pt 78 (ng/m3), Au 79 (ng/m3), Hg 80 (ng/m3), Tl 81 (ng/m3), Pb 82 (ng/m3), Bi 83 (ng/m3), Th 90 (ng/m3), U 92 (ng/m3)";


                StreamWriter writer = new StreamWriter(outputFile);

                writer.WriteLine(titleString1);
                writer.WriteLine(titleString2);


                List<string> ItemsToFind = new List<string>();
                ItemsToFind.Add("Acquisition Start Time");     //1
                ItemsToFind.Add("Ambient");
                ItemsToFind.Add("Sample");
                ItemsToFind.Add("BP");
                ItemsToFind.Add("Tape");  //5
                ItemsToFind.Add("Flow 25");
                ItemsToFind.Add("Flow Act");
                ItemsToFind.Add("Flow Std");
                ItemsToFind.Add("Volume");
                ItemsToFind.Add("Tube Temp"); //10
                ItemsToFind.Add("Enclosure Temp");
                ItemsToFind.Add("Filament Monitor");
                ItemsToFind.Add("SDD Temp");
                ItemsToFind.Add("DDP Temp");
                ItemsToFind.Add("Relative Humidity");  //15
                ItemsToFind.Add("Wind Speed");
                ItemsToFind.Add("Wind Direction");
                ItemsToFind.Add("Sample Time");  //18
                ItemsToFind.Add("Alarm");
                //
                ItemsToFind.Add("Al,");
                ItemsToFind.Add("Si,");
                ItemsToFind.Add("P ,");
                ItemsToFind.Add("S ,");
                ItemsToFind.Add("Cl,");
                ItemsToFind.Add("K ,");
                ItemsToFind.Add("Ca,");
                ItemsToFind.Add("Sc,");
                ItemsToFind.Add("Ti,");
                ItemsToFind.Add("V ,");
                ItemsToFind.Add("Cr,");
                ItemsToFind.Add("Mn,");
                ItemsToFind.Add("Fe,");
                ItemsToFind.Add("Co,");
                ItemsToFind.Add("Ni,");
                ItemsToFind.Add("Cu,");
                ItemsToFind.Add("Zn,");
                ItemsToFind.Add("Ga,");
                ItemsToFind.Add("As,");
                ItemsToFind.Add("Se,");
                ItemsToFind.Add("Br,");
                ItemsToFind.Add("Rb,");
                ItemsToFind.Add("Sr,");
                ItemsToFind.Add("Ti,");
                ItemsToFind.Add("Y ,");
                ItemsToFind.Add("Zr,");
                ItemsToFind.Add("Nb,");
                ItemsToFind.Add("Mo,");
                ItemsToFind.Add("Ru,");
                ItemsToFind.Add("Rh,");
                ItemsToFind.Add("Pd,");
                ItemsToFind.Add("Ag,");
                ItemsToFind.Add("Cd,");
                ItemsToFind.Add("In,");
                ItemsToFind.Add("Sn,");
                ItemsToFind.Add("Sb,");
                ItemsToFind.Add("Te,");
                ItemsToFind.Add("I ,");
                ItemsToFind.Add("Cs,");
                ItemsToFind.Add("Ba,");
                ItemsToFind.Add("La,");
                ItemsToFind.Add("Ce,");
                ItemsToFind.Add("Pr,");
                ItemsToFind.Add("Nd,");
                ItemsToFind.Add("Sm,");
                ItemsToFind.Add("Eu,");
                ItemsToFind.Add("Gd,");
                ItemsToFind.Add("Tb,");
                ItemsToFind.Add("Dy,");
                ItemsToFind.Add("Ho,");
                ItemsToFind.Add("Er,");
                ItemsToFind.Add("Tm,");
                ItemsToFind.Add("Yb,");
                ItemsToFind.Add("Lu,");
                ItemsToFind.Add("Hf,");
                ItemsToFind.Add("Ta,");
                ItemsToFind.Add("W ,");
                ItemsToFind.Add("Re,");
                ItemsToFind.Add("Os,");
                ItemsToFind.Add("Ir,");
                ItemsToFind.Add("Pt,");
                ItemsToFind.Add("Au,");
                ItemsToFind.Add("Hg,");
                ItemsToFind.Add("Tl,");
                ItemsToFind.Add("Pb,");
                ItemsToFind.Add("Bi,");
                ItemsToFind.Add("Th,");
                ItemsToFind.Add("Pa,");
                ItemsToFind.Add("U ,");



                foreach (FileInfo f in fileList)
                {
                    if (f.Name.Contains("data") || f.Name.Contains("zip"))
                    {
                        continue;  //skip the data1, data2, and data3 files
                    }
                    else
                    {

                        //found a good file here, lets add the data into the correct output
                        //System.IO.StreamReader tempfile = new System.IO.StreamReader(f.OpenRead());


                        while (index < (ItemsToFind.Count))
                        {

                            itemFound = 0;
                            System.IO.StreamReader tempfile2 = new System.IO.StreamReader(f.OpenRead());

                            while ((line = tempfile2.ReadLine()) != null)
                            {
                                //read each line and put it in the right place in the output string
                                if (line.Contains(ItemsToFind[index]))
                                {
                                    itemFound = 1;

                                    string[] data = line.Split(',');
                                    if (index == 0)
                                    {
                                        //string[] datetime = data[2].Split(' ');
                                        //data
                                        outputString = data[2].Insert((data[2].Length - 2), "00");
                                        outputString = outputString.Substring(0, outputString.Length - 2);
                                        outputString = outputString + ",";
                                    }
                                    else if (index <= 19)
                                    {
                                        outputString = (outputString + data[2] + ",");
                                    }
                                    else
                                    {
                                        outputString = (outputString + data[4] + ",");

                                    }

                                    index++;  //look for the next thing


                                    if (index == ItemsToFind.Count)
                                    {
                                        index = 0;
                                        break;
                                    }
                                    itemFound = 0;  //item has been found and added -- now to look for the next item indicated by index, from the start of the file
                                    tempfile2 = new System.IO.StreamReader(f.OpenRead());  //return to the start of the file--you are looking for something new
                                }
                                else
                                {
                                    //int x = 0;
                                    //item not found
                                    //if ()
                                }



                            }
                            if (line == null)
                            {
                                //item was not found      

                            }

                            //read through the whole file and didnt find the item
                            if (itemFound == 0)
                            {
                                outputString = (outputString + ",");
                                index++;

                            }
                            else
                            {
                                tempfile2.Close();
                                index = 0;
                                //outputString = outputString + "/r/n";
                                break;
                            }
                        }
                        //appendString += "\r\n";

                        //write the string to the output file
                        //using (StreamWriter writer = new StreamWriter(outputFile))
                        //{
                        //tempfile2.Close();
                        index = 0;
                        writer.WriteLine(outputString);
                        outputString = string.Empty;
                        //}




                    }

                }

                mtbDataOutputMessage.Text = "Output file written to:  " + outputFile;
                writer.Close();


            }
            catch (Exception Ex)
            {
                mtbDataOutputMessage.Text = "Error creating summary file.  See ErrorFile.txt";

                Logger.WriteInternalLogFile("Error in summary file:  Ex = " + Ex.ToString());
            }





        }

        private void metroButton9_Click_2(object sender, EventArgs e)
        { //qa forward

        }

        private void metroButton2_Click_2(object sender, EventArgs e)
        {   //qa back

        }

        private void radioButton1_CheckedChanged(object sender, EventArgs e)
        {

        }

        private void mtbStatusTapeRemaining_Click(object sender, EventArgs e)
        {

        }

        private void metroTabPage5_Click(object sender, EventArgs e)
        {

        }

        private void metroButton11_Click_1(object sender, EventArgs e)
        {

        }

        private void cbMetroEC2Filter_SelectedIndexChanged(object sender, EventArgs e)
        {

        }

        private void metroButton11_Click_2(object sender, EventArgs e)
        {
            
            Form foptions = new FormOptions();
            foptions.ShowDialog();
        }

        private void tbMetroEC2kV_Click(object sender, EventArgs e)
        {

        }

        private void tbMetroEC2uA_Click(object sender, EventArgs e)
        {

        }

        /// <summary>
        /// Check the cal tab leak check toggle
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void metroToggleLeakCheck_CheckedChanged(object sender, EventArgs e)
        {

            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;

            System.Windows.Forms.CheckState checkStateLeakCheck = System.Windows.Forms.CheckState.Unchecked;
            //check for checked
            //if checked then
            if (metroToggleLeakCheck.InvokeRequired)
            {
                metroToggleLeakCheck.Invoke(new MethodInvoker(delegate { checkStateLeakCheck = metroToggleLeakCheck.CheckState; }));
            }
            else
            {
                checkStateLeakCheck = metroToggleLeakCheck.CheckState;
            }

            if (checkStateLeakCheck == System.Windows.Forms.CheckState.Checked)
            {
                BackgroundManager.m_oLeakCheck.RunWorkerAsync();
                if (InvokeRequired)
                {
                    tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Clear(); }));
                }
                else
                {
                    tbMetroCalEntry.Clear();
                }

            }
            else
            {
                //else cancel thread
                if (BackgroundManager.m_oLeakCheck.IsBusy)
                {
                    BackgroundManager.m_oLeakCheck.CancelAsync();
                }

                //turn off pump
                int returnVal = AcquisitionControl.PumpOff(m_oWorkerPump);
                if (returnVal == PASS)
                {
                    Logger.WriteInternalLogFile("Leak Check Pump off.");
                }
                else
                {
                    UpdateOperationMessage("Error:  Unable to stop pump");
                    Logger.WriteErrorFile("Error:  Unable to stop pump.");
                }

                if (InvokeRequired)
                {
                    tbMetroCalEntry.Invoke(new MethodInvoker(delegate { tbMetroCalEntry.Clear(); }));
                }
                else
                {
                    tbMetroCalEntry.Clear();
                }
                tbMetroCalPrompt.Text = "";

            }

        }

        private void metroPanel14_Paint(object sender, PaintEventArgs e)
        {

        }

        private void metroToggleFlowCal_CheckedChanged(object sender, EventArgs e)
        {
            int x = 5;  // dummy like to break

            //if the flow toggle is toggled on, then:
            //if(mettroToggleFlowCal)

            if (metroToggleFlowCal.CheckState == System.Windows.Forms.CheckState.Checked)
            {
                if (PumpIntention == 0)
                {
                    DialogResult dialogResultPumpOnOff = MetroMessageBox.Show(this, "Please turn Pump 'On' to begin Flow Calibration.", "Flow Calibration", MessageBoxButtons.OK, MessageBoxIcon.Information, MessageBoxDefaultButton.Button1 /*,height=250*/);
                    if (dialogResultPumpOnOff == DialogResult.Yes)
                    {
                        //actually turn pump on
                    }
                }
            }

        }

        private void mtbResetTapeRemaining_Click(object sender, EventArgs e)
        {

        }

        private void metroLabel36_Click(object sender, EventArgs e)
        {

        }

        private void mbTubeSeasoning_Click(object sender, EventArgs e)
        {
            

            if (mbTubeSeasoning.Text == "Tube Seasoning")
            {
                manualTubeSeasoning = 1;
                mbTubeSeasoning.Text = "Cancel Seasoning";
                mtbMaintCheckMessage.Text = "";                
                BackgroundManager.m_oWorkerTubeSeasoning.RunWorkerAsync();

            }
            else
            {
                
                mbTubeSeasoning.Text = "Tube Seasoning";
                mtbMaintCheckMessage.Text = "";

                if (BackgroundManager.m_oWorkerTubeSeasoning.IsBusy)
                {
                    BackgroundManager.m_oWorkerTubeSeasoning.CancelAsync();
                }
                manualTubeSeasoning = 0;
                RampXraysToZero();
            }
        }

        private void metroRadioButton2_CheckedChanged(object sender, EventArgs e)
        {

        }

        private void mbEnableChangesCalFlow_Click(object sender, EventArgs e)
        {


            if (mbEnableChangesCalFlow.Text == "Enable Changes")
            {
                //enable flow calibration changes
                metroToggle1.Enabled = true;
                metroToggle2.Enabled = true;

                //1.2.0.50 update interlock with pop up that says start up

                metroToggleFlowCal.Enabled = true;  //previously moved to interlock with the pump on / off

                metroToggleLeakCheck.Enabled = true;
                mbPumpOn.Enabled = true;
                rbMetro150.Enabled = true;
                rbMetro167.Enabled = true;
                rbMetro184.Enabled = true;
                bMetroEnterDataButton.Enabled = true;
                tbMetroCalEntry.Enabled = true;
                mbEnableChangesCalFlow.Text = "Disable Changes";
            }
            else if (mbEnableChangesCalFlow.Text == "Disable Changes")
            {

                metroToggle1.Enabled = false;
                metroToggle2.Enabled = false;
                metroToggleFlowCal.Enabled = false;
                metroToggleLeakCheck.Enabled = false;
                mbPumpOn.Enabled = false;
                rbMetro150.Enabled = false;
                rbMetro167.Enabled = false;
                rbMetro184.Enabled = false;
                bMetroEnterDataButton.Enabled = false;
                tbMetroCalEntry.Enabled = false;

                //
                //yint and slope and t and p offset re read from settings


                mbEnableChangesCalFlow.Text = "Enable Changes";


            }


        }

        private void metroPanel21_Paint(object sender, PaintEventArgs e)
        {

        }

        private void mbMaintMoveFWtoEC4_Click(object sender, EventArgs e)
        {

            int fwECEndLocal = 4;
            AcquisitionLogic AcquisitionControl = AcquisitionLogic.Instance;
            int retVal = AcquisitionControl.MoveFWHome(SerialManager, this);
            if (retVal == PASS)
            {
                int retVal2 = AcquisitionControl.MoveFWEC(SerialManager, 0, fwECEndLocal, this);
                if (retVal2 == PASS)
                {
                    Logger.WriteLogFile("EC " + fwECEndLocal.ToString() + " fw MOVE RETURNED PASS.");
                    int position = 0;

                    //int returnVal27 = AcquisitionControl.CheckMotorPosition(SerialManager, 1, out position);  //1=FW
                    position = AcquisitionControl.PollMotorPosition(1, SerialManager);

                    Logger.WriteLogFile("EC " + fwECEndLocal.ToString() + " (destination) motor position, after move = " + position.ToString());
                    //Logger.WriteLogFile("Check FW motor postion returned: " + returnVal27.ToString());

                    if (position.ToString().Contains(Properties.Settings.Default.FWEC4.ToString()))
                    {
                        UpdateOperationMessage("Move FW to EC4 Pass");
                        UpdateFilterWheelMessage("FW at EC4 (" + Properties.Settings.Default.FWEC4.ToString() + ")");
                    }
                    else
                    {
                        UpdateOperationMessage("Move FW to EC4 Fail");
                        UpdateFilterWheelMessage("Move FW to EC4 Fail: FW at (" + Properties.Settings.Default.FWEC4.ToString() + ")");
                    }
                }
                else
                {
                    UpdateOperationMessage("Move FW to EC4 fail");
                    UpdateFilterWheelMessage("Mov FW to EC4 fail");
                }

            }
            else
            {
                UpdateOperationMessage("Error FW Home function");
                UpdateFilterWheelMessage("Error FW home function");

            }

        }

        private void tbMetroVolume_Click(object sender, EventArgs e)
        {

        }

        private void metroPanel34_Paint(object sender, PaintEventArgs e)
        {

        }

        private void mbWarmUp_Click(object sender, EventArgs e)
        {
            //perform various warm up activities
            //tube seasoning
            //acquisition

            //Ecal  (what to do if fail?)
            //Upscale (what to do if fail?)

            if (mbWarmUp.Text == "Warm Up")
            {
                WarmUpActive = 1;  //1 for TS; 2 for Ecal
                manualWarmUp = 1;

                ManualWarmUpTime = 15.0;

                mbWarmUp.Text = "Cancel Warm Up";
                mtbMaintCheckMessage.Text = "";


                //TubeSeasoningTime = 1;  //temp set to 15
                UpdateMaintCheckMessage("Warm Up function start");
                Thread.Sleep(1000);
                UpdateMaintCheckMessage("15 min X-ray ON, then Ecal");
                Thread.Sleep(1000);
                BackgroundManager.m_oWorkerTubeSeasoning.RunWorkerAsync();


            }
            else
            {
                WarmUpActive = 0;
                //TubeSeasoningTime = 15; 
                mbWarmUp.Text = "Warm Up";
                mtbMaintCheckMessage.Text = "";
                try
                {
                    if (BackgroundManager.m_oWorkerTubeSeasoning.IsBusy)
                    {
                        BackgroundManager.m_oWorkerTubeSeasoning.CancelAsync();
                    }
                }
                catch
                {
                   
                }
                try
                {
                    if (BackgroundManager.m_oWorkerEcal.IsBusy)
                    {
                        BackgroundManager.m_oWorkerEcal.CancelAsync();
                    }
                }
                catch
                {

                }
                manualWarmUp = 0;
                WarmUpActive = 0;
                RampXraysToZero();

            }







        }

        private void mbLaunchAdapt_Click(object sender, EventArgs e)
        {
            //launch chrome, using the correct URL:

            Process.Start("chrome", @"http://localhost:8000/view/");



        }

        private void metroPanel17_Paint(object sender, PaintEventArgs e)
        {

        }

        private void metroPanel6_Paint(object sender, PaintEventArgs e)
        {

        }
    }


    class Regression
    {

        /// <summary>
        /// Generic line-fit to a collection of (x,y) points
        /// 
        /// </summary>
        /// <param name="xVals">The x-axis values.</param>
        /// <param name="yVals">The y-axis values.</param>
        /// <param name="inclusiveStart">The inclusive inclusiveStart index.</param>
        /// <param name="exclusiveEnd">The exclusive exclusiveEnd index.</param>
        /// <param name="rsquared">The r^2 value of the line.</param>
        /// <param name="yintercept">The y-intercept value of the line (i.e. y = ax + b, yintercept is b).</param>
        /// <param name="slope">The slop of the line (i.e. y = ax + b, slope is a).</param>
        public void LinearRegression(double[] xVals, double[] yVals,
                                            int inclusiveStart, int exclusiveEnd,
                                            out double rsquared, out double yintercept,
                                            out double slope)
        {
            //Debug.Assert(xVals.Length == yVals.Length);
            double sumOfX = 0;
            double sumOfY = 0;
            double sumOfXSq = 0;
            double sumOfYSq = 0;
            double ssX = 0;
            double ssY = 0;
            double sumCodeviates = 0;
            double sCo = 0;
            double count = exclusiveEnd - inclusiveStart;

            for (int ctr = inclusiveStart; ctr < exclusiveEnd; ctr++)
            {
                double x = xVals[ctr];
                double y = yVals[ctr];
                sumCodeviates += x * y;
                sumOfX += x;
                sumOfY += y;
                sumOfXSq += x * x;
                sumOfYSq += y * y;
            }
            ssX = sumOfXSq - ((sumOfX * sumOfX) / count);
            ssY = sumOfYSq - ((sumOfY * sumOfY) / count);
            double RNumerator = (count * sumCodeviates) - (sumOfX * sumOfY);
            double RDenom = (count * sumOfXSq - (sumOfX * sumOfX))
             * (count * sumOfYSq - (sumOfY * sumOfY));
            sCo = sumCodeviates - ((sumOfX * sumOfY) / count);

            double meanX = sumOfX / count;
            double meanY = sumOfY / count;
            double dblR = RNumerator / Math.Sqrt(RDenom);
            rsquared = dblR * dblR;
            yintercept = meanY - ((sCo / ssX) * meanX);
            slope = sCo / ssX;
        }

    }






    /// <summary>
    /// This class is for dealing with Modbus
    ///     * creating slave device
    ///     * creating registers
    ///     * formatting concentration data
    ///     * writing to registers 
    /// </summary>
    /// 
    //public static partial class Logger
    public static partial class nModbusOperations
    {
        /// <summary>
        /// This method creates a modbus slave on the desired port.
        /// </summary>
        /// <param name="commPort">
        /// The name for the slave serial port
        /// </param>
        /// <param name="baudRate">
        /// the serial port baud rate
        /// </param>
        /// <param name="dataStore">
        /// The data store object used for registers
        /// </param>

        public static SerialPort slavePort;
        public static Thread slaveThread;
        /// <summary>
        /// 
        /// </summary>
        /// <param name="commPort"></param>
        /// <param name="baudRate"></param>
        /// <param name="dataStore"></param>
        /// NOTE: it may be necessary to parse out requests for more than 127 registers
        /// As nModbus 4 crashes xact control if greater than 127 registers are requested!  02.09.2017
        /// 
        public static void initialize(string commPort, int baudRate, out DataStore dataStore)
        {
            //configure Modbus Slave 
            slavePort = new SerialPort(commPort);
            slavePort.BaudRate = baudRate;
            slavePort.DataBits = 8;
            slavePort.Parity = Parity.None;
            slavePort.StopBits = StopBits.One;
            //slavePort.Close();
            slavePort.Open();

            byte slaveId = 1;

            //create slave on seperate thread


            ModbusSlave slave = ModbusSerialSlave.CreateRtu(slaveId, slavePort);

            slave.DataStore = DataStoreFactory.CreateDefaultDataStore();
            dataStore = slave.DataStore;
            slaveThread = new Thread(new ThreadStart(slave.Listen));

            slaveThread.Start();
        }

        
        //public void modbusLogger()
        //{


        //}


        public static void Dispose()
        {
            slavePort.Close();
            slavePort.Dispose();
        }
        /// <summary>
        /// This method looks in the process_data directory and
        /// retrieves the most recent data file 
        /// </summary>
        /// <param name="path">
        /// The path to the process_data directory
        /// </param>
        /// <returns>
        /// A string containing the file's path
        /// </returns>
        /// 
        public static string findProcessFile(string path)
        {
            try
            {
                System.IO.FileInfo[] sortedFiles = new DirectoryInfo(path).GetFiles().OrderByDescending(f => f.LastWriteTime).ToArray();
                string[] processFiles = new string[sortedFiles.Length];

                for (int i = 0; i < sortedFiles.Length; i++)
                {
                    string f = sortedFiles[i].ToString();
                    if(f.Contains("zip"))
                    {
                        continue;
                    }
                    if (!f.Contains("data"))
                    {
                        processFiles.SetValue(f, i);
                    }
                }
                string targetFile = processFiles.FirstOrDefault(s => !string.IsNullOrEmpty(s)) ?? "";
                return path + "\\" + targetFile;
            }
            catch(Exception Ex)
            {
                Logger.WriteInternalLogFile("Error: in find ProcessFile. (Modbus)  Ex = " + Ex.ToString());
                Logger.WriteLogFile("Error: in find ProcessFile. (Modbus)  Ex = " + Ex.ToString());
                //Logger.WriteErrorFile("Error: in find ProcessFile. (modbus) ");
                return path;
            }
        }

        /// <summary>
        /// This method looks into the Process Data txt file and parses out the date time, 
        /// concentrations, and uncertainties
        /// </summary>
        /// <param name="filename">
        /// path to the process data text file 
        /// </param>
        /// <returns>
        /// Returns a string array with the data
        /// </returns>
        public static void getRawData(string filename, out List<string> conc_and_dateTime, out List<string> instrumentData, out List<string> conc_and_dateTime_No_Nb)
        {

            conc_and_dateTime = new List<string>();
            instrumentData = new List<string>();
            conc_and_dateTime_No_Nb = new List<string>();

            try
            {
                string[] rawData = System.IO.File.ReadAllLines(filename);


                // find index in process_data file
                var index = Array.IndexOf(rawData, ",*****,");


                //get datetime format for ADAPT 
                string[] line1 = rawData[0].Split(',');
                string[] dateTime = line1[2].Split('-', ' ', ':', '/');
                conc_and_dateTime.Add(dateTime[2] + dateTime[0] + dateTime[1] + dateTime[3] + dateTime[4]);// + dateTime[5]); //making datetime in adapt format
                conc_and_dateTime_No_Nb.Add(dateTime[2] + dateTime[0] + dateTime[1] + dateTime[3] + dateTime[4]);


                // get the concentrations 
                for (int i = 3; i < index; i++)
                {
                    string[] splitLine = rawData[i].Split(',');

                    conc_and_dateTime.Add(splitLine[0]); //symbol
                    conc_and_dateTime.Add(splitLine[1]); // atomic number
                    conc_and_dateTime.Add(splitLine[2]); //  mass
                    conc_and_dateTime.Add(splitLine[3]); // uncertainty in mass
                    conc_and_dateTime.Add(splitLine[4]); // concentration
                    if (splitLine[0].Contains("Nb"))
                    {
                        //do not add the value
                    }
                    else
                    {
                        conc_and_dateTime_No_Nb.Add(splitLine[0]); //symbol
                        conc_and_dateTime_No_Nb.Add(splitLine[1]); // atomic number
                        conc_and_dateTime_No_Nb.Add(splitLine[2]); //  mass
                        conc_and_dateTime_No_Nb.Add(splitLine[3]); // uncertainty in mass
                        conc_and_dateTime_No_Nb.Add(splitLine[4]); // concentration
                    }
                }



                // get the instrument data
                for (int i = index + 2; i < rawData.Length; i++)
                {
                    string[] splitLine = rawData[i].Split(',');

                    //double value = splitline

                    instrumentData.Add(splitLine[2]);
                }
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error in GetRawData (modbus) Ex =" + Ex.ToString());

            }

        }





        /// <summary>
        /// This method takes a floating point number and converts it into IEEE 754 standard integer representation
        /// </summary>
        /// <param name="numberToWrite">
        /// The number you would like to store in two registers
        /// </param>
        /// <returns>
        /// Returns a ushort array containing the integers for the modbus registers
        /// </returns>
        public static ushort[] floatToIntegersForRegisters(float numberToWrite)
        {
            try
            {
                // get the IEE 754 bit representation of Float 
                var ieeeRepresentation = BitConverter.GetBytes(numberToWrite);

                // Split the number int two 16 bit chunks and set them to integers

                int low = ieeeRepresentation[0] | (ieeeRepresentation[1] << 8);
                int high = ieeeRepresentation[2] | (ieeeRepresentation[3] << 8);


                // convert the integers to ushort to make Modbus happy later

                ushort[] dataToWrite = new ushort[] { (ushort)low, (ushort)high };
                return dataToWrite;
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error in floatToIntegersForRegisters.  (modbus) Ex = " + Ex.ToString());
                ushort[] dataToWrite = new ushort[] { (ushort)0, (ushort)0 };
                return dataToWrite;
            }
        }

        /// <summary>
        /// This method creates an array from the retrieved data that to be stored in 
        /// modbus registers 
        /// </summary>
        /// <param name="data">
        /// The string array of data retrieved with getConcDataAndAquisitionTime()
        /// </param>
        /// <returns>
        /// Returns a ushort array to be passed to the modbus registers
        /// </returns>
        public static ushort[] createModbusArray(List<string> data)
        {
            try

            {
                int numberOfAnalytes = (data.Count - 1) / 5;
                int dataLength = numberOfAnalytes * 5 + 3; //3 for datetime, 1 per atomic #, 2 per conc, 2 per unc

                //create the ushort array for the modbus slave 
                ushort[] modbusDataArray = new ushort[dataLength];

                /*--------------------------------------------------------*/

                // add date time to dataToBeWritten 
                char[] dateTimeChars = data[0].ToCharArray();

                //year//
                char[] yearChars = new char[4] { dateTimeChars[0], dateTimeChars[1], dateTimeChars[2], dateTimeChars[3] };
                string year = new string(yearChars);
                int yearForModbus = int.Parse(year);

                //month-day//
                char[] monthDayChars = new char[4] { dateTimeChars[4], dateTimeChars[5], dateTimeChars[6], dateTimeChars[7] };
                string monthDay = new string(monthDayChars);
                int monthDayForModbus = int.Parse(monthDay);

                //hours-minutes// 
                char[] hoursMinutesChars = new char[4] { dateTimeChars[8], dateTimeChars[9], dateTimeChars[10], dateTimeChars[11] };
                string hoursMinutes = new string(hoursMinutesChars);
                int hoursMinutesForModbus = int.Parse(hoursMinutes);


                 

                modbusDataArray[0] = (ushort)yearForModbus;
                modbusDataArray[1] = (ushort)monthDayForModbus;
                modbusDataArray[2] = (ushort)hoursMinutesForModbus;

                /*--------------------------------------------------------*/

                // get atomic #s, concentrations, and uncertainties

                ushort[] atomicNumbers = new ushort[numberOfAnalytes];
                int counter1 = 0;
                for (int i = 2; i < data.Count; i += 5)  //was 7 needs to be 2   fix modbus output
                {
                    atomicNumbers[counter1] = ushort.Parse(data[i]);
                    counter1 += 1;
                }

                ushort[] concentrations = new ushort[numberOfAnalytes * 2];
                //try
                //{

                    int counter2 = 0;
                    for (int i = 5; i < data.Count; i += 5) //i=10 needs to be i=5 to catch the first element
                    {
                        if (data[i] != "")
                        {
                            ushort[] conc = floatToIntegersForRegisters(float.Parse(data[i]));
                            concentrations[counter2] = conc[0];
                            concentrations[counter2 + 1] = conc[1];
                            counter2 += 2;
                        }
                        else
                        {
                            concentrations[counter2] = 0;
                            concentrations[counter2 + 1] = 0;
                            counter2 += 2;
                        }

                    }
                //}
                //catch (Exception Ex)
                //{
                //    string ex = "Could not get concentration data";
               // }


                ushort[] uncertainties = new ushort[numberOfAnalytes * 2];
                //try
               // {

                    int counter3 = 0;
                    for (int i = 4; i < data.Count; i += 5)  //was 9 changed to 4 (to catch first mass uncertainty)
                    {
                        if (data[i] != "")
                        {
                            ushort[] unc = floatToIntegersForRegisters(float.Parse(data[i]));
                            uncertainties[counter3] = unc[0];
                            uncertainties[counter3 + 1] = unc[1];
                            counter3 += 2;
                        }
                        else
                        {
                            uncertainties[counter3] = 0;
                            uncertainties[counter3 + 1] = 0;
                            counter3 += 2;
                        }

                    }
                //}
                //catch (Exception Ex)
               // {
                //    string ex = "Could not get uncertainties data";
                //}


                //add atomic numbers, concentrations, and uncertainties to data array
                for (int i = 0; i < atomicNumbers.Length; i++)
                {
                    modbusDataArray[i + 3] = atomicNumbers[i];
                }
                for (int i = 0; i < concentrations.Length; i++)
                {
                    modbusDataArray[i + 3 + atomicNumbers.Length] = concentrations[i];
                }
                for (int i = 0; i < uncertainties.Length; i++)
                {
                    modbusDataArray[i + 3 + atomicNumbers.Length + concentrations.Length] = uncertainties[i];
                }

                return modbusDataArray;
            }
            catch (Exception Ex)
            {

                Logger.WriteInternalLogFile("Error in create modbus array (modbus) Ex = " + Ex.ToString());
                ushort[] modbusDataArray = new ushort[1];
                return modbusDataArray;
            }
        }

        /// <summary>
        /// Creates Ushort array to send to modbus registers
        /// containing the year, month+day, and hour+min
        /// </summary>
        /// <param name="modbusArray">
        /// Array created with createMobusArray
        /// </param>
        /// <returns></returns>
        public static ushort[] modbusDateTimeArray(ushort[] modbusArray)
        {

            ushort[] returnArray = new ushort[5];

            try
            {

                // set the year
                returnArray[0] = modbusArray[0];

                int sizeMonthDay = modbusArray[1].ToString().Length;
                int sizeHourMin = modbusArray[2].ToString().Length;


                // set the month and day
                if (sizeMonthDay <= 2)
                {
                    returnArray[1] = 0;
                    returnArray[2] = modbusArray[1];
                }
                else if (sizeMonthDay == 3)
                {
                    char[] monthDay = modbusArray[1].ToString().ToCharArray();
                    string month = monthDay[0].ToString();
                    string day = monthDay[1].ToString() + monthDay[2].ToString();
                    returnArray[1] = Convert.ToUInt16(month);
                    returnArray[2] = Convert.ToUInt16(day);
                }
                else if (sizeMonthDay == 4)
                {
                    char[] monthDay = modbusArray[1].ToString().ToCharArray();
                    string month = monthDay[0].ToString() + monthDay[1].ToString();
                    string day = monthDay[2].ToString() + monthDay[3].ToString();
                    returnArray[1] = Convert.ToUInt16(month);
                    returnArray[2] = Convert.ToUInt16(day);
                }
                else
                {
                    returnArray[1] = 0;
                    returnArray[2] = 0;
                }


                // set the hours and minutes 
                if (sizeHourMin <= 2)
                {
                    returnArray[3] = 0;
                    returnArray[4] = modbusArray[2];
                }
                else if (sizeHourMin == 3)
                {
                    char[] hourMin = modbusArray[2].ToString().ToCharArray();
                    string hour = hourMin[0].ToString();
                    string min = hourMin[1].ToString() + hourMin[2].ToString();
                    returnArray[3] = Convert.ToUInt16(hour);
                    returnArray[4] = Convert.ToUInt16(min);
                }
                else if (sizeHourMin == 4)
                {
                    char[] hourMin = modbusArray[2].ToString().ToCharArray();
                    string hour = hourMin[0].ToString() + hourMin[1].ToString();
                    string min = hourMin[2].ToString() + hourMin[3].ToString();
                    returnArray[3] = Convert.ToUInt16(hour);
                    returnArray[4] = Convert.ToUInt16(min);
                }
                else
                {
                    returnArray[3] = 0;
                    returnArray[4] = 0;
                }

                return returnArray;
            }

            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error in modbus create data time array (modbus) Ex=" + Ex.ToString());
                return returnArray;
            }

        }

        /// <summary>
        /// Creates Ushort array to send to modbus registers
        /// containing the year, month+day, and hour+min
        /// </summary>
        /// <param name="modbusArray">
        /// Array created with createMobusArray
        /// </param>
        /// <returns></returns>
        //public static ushort[] ModbusDateTimeArrayFromDTNow(DateTime nowValue)  //ushort[] modbusArray)
        //public static char[] ModbusDateTimeArrayFromDTNow(DateTime nowValue)  //ushort[] modbusArray)
        public static ushort[] ModbusDateTimeArrayFromDTNow(DateTime nowValue)  //ushort[] modbusArray)
        {
            try
            {
                //                                         01234567890123    
                string stDateTime = DateTime.Now.ToString("yyyyMMddHHmmss"); // case sensitive

                ushort[] usDateTime = new ushort[6];

                string year = stDateTime.Substring(0, 4);
                string month = stDateTime.Substring(4, 2);
                string day = stDateTime.Substring(6, 2);
                string hour = stDateTime.Substring(8, 2);
                string min = stDateTime.Substring(10, 2);
                string sec = stDateTime.Substring(12, 2);

                UInt16 sy = Convert.ToUInt16(year);
                UInt16 sM = Convert.ToUInt16(month);
                UInt16 sd = Convert.ToUInt16(day);
                UInt16 sH = Convert.ToUInt16(hour);
                UInt16 sm = Convert.ToUInt16(min);
                UInt16 ss = Convert.ToUInt16(sec);

                usDateTime[0] = sy;
                usDateTime[1] = sM;
                usDateTime[2] = sd;
                usDateTime[3] = sH;
                usDateTime[4] = sm;
                usDateTime[5] = ss;

                return usDateTime;
            }
            catch (Exception Ex)
            {
                ushort[] usDateTime = new ushort[6];

                Logger.WriteInternalLogFile("Ex in ModbusDateTimeArrayFromDTNow.  Ex = " + Ex.ToString());

                UInt16 sy = 1;
                UInt16 sM = 1;
                UInt16 sd = 1;
                UInt16 sH = 1;
                UInt16 sm = 1;
                UInt16 ss = 1;

                usDateTime[0] = sy;
                usDateTime[1] = sM;
                usDateTime[2] = sd;
                usDateTime[3] = sH;
                usDateTime[4] = sm;
                usDateTime[5] = ss;
                return usDateTime;


            }

        }






        /// <summary>
        /// Creates a ushort array of ints with the atomic 
        /// numbers. 
        /// </summary>
        /// <param name="modbusArray"></param>
        /// <returns></returns>
        /// 
        public static ushort[] atomicNumberArray(ushort[] modbusArray)
        {
            try
            {
                int numberOfAnalytes = (modbusArray.Length - 3) / 5;
                ushort[] atomicNumberArray = new ushort[numberOfAnalytes];
                int counter = 0;

                for (int i = 3; i < numberOfAnalytes + 3; i++)
                {
                    atomicNumberArray[counter] = modbusArray[i];
                    counter++;

                }

                return atomicNumberArray;
            }
            catch(Exception Ex)
            {
                Logger.WriteInternalLogFile("Error: in atomic number array (Modbus) Ex = " + Ex.ToString());
                Logger.WriteLogFile("Error: in atomic number array (Modbus) Ex = " + Ex.ToString());

                ushort[] atomicNumberArray = new ushort[1];

                return atomicNumberArray;
            }
        }


        /// <summary>
        /// Creates a ushort array with concentrations 
        /// </summary>
        /// <param name="modbusArray"></param>
        /// <returns></returns>
        public static ushort[] modbusConcArray(ushort[] modbusArray)
        {
            try
            {
                int numberOfAnalytes = (modbusArray.Length - 3) / 5;
                ushort[] modbusConcArray = new ushort[numberOfAnalytes * 2];
                int counter = 0;

                for (int i = 3 + numberOfAnalytes; i < 3 + numberOfAnalytes * 3; i++)
                {
                    modbusConcArray[counter] = modbusArray[i];
                    counter++;
                }
                return modbusConcArray;
            }
            catch(Exception Ex)
            {
                Logger.WriteInternalLogFile("Error: in ConcArray (Modbus) Ex = " + Ex.ToString());
                Logger.WriteLogFile("Error: in ConcArray (Modbus) Ex = " + Ex.ToString());
                ushort[] modbusConcArray = new ushort[1 * 2];
                return modbusConcArray;

            }
        }


        /// <summary>
        /// Creates a ushort array with uncertainties 
        /// </summary>
        /// <param name="modbusArray"></param>
        /// <returns></returns>
        public static ushort[] modbusUncArray(ushort[] modbusArray)
        {
            try
            {
                int numberOfAnalytes = (modbusArray.Length - 3) / 5;
                ushort[] modbusUncArray = new ushort[numberOfAnalytes * 2];
                int counter = 0;

                for (int i = 3 + numberOfAnalytes * 3; i < 3 + numberOfAnalytes * 5; i++)
                {
                    modbusUncArray[counter] = modbusArray[i];
                    counter++;
                }
                return modbusUncArray;
            }
            catch(Exception Ex)
            {
                //Logger.WriteErrorFile("Error: in UncArray (modbus)");
                Logger.WriteInternalLogFile("Error: in UncArray (Modbus) Ex = " + Ex.ToString());
                Logger.WriteLogFile("Error: in UncArray (Modbus) Ex = " + Ex.ToString());

                ushort[] modbusUncArray = new ushort[1 * 2];
                return modbusUncArray;

            }
        }


        /// <summary>
        /// Creates a ushort array that can be sent to modbus with the xact instrument data
        /// </summary>
        /// <param name="data">
        /// List containing the telemetry data
        /// </param>
        /// <returns></returns>
        public static ushort[] ModbusTelemetryArray(List<string> data)
        {
            try
            {
                ushort[] returnData = new ushort[(data.Count - 1) * 2];
                int counter = 0;
                for (int i = 0; i < data.Count-1; i++)  //-1 shift and to remove the date time for pump start
                {
                    float parsedFloat = 0.0F;
                    bool fResult = float.TryParse(data[i], out parsedFloat);

                    //float parsedFloat = float.Parse(data[i]);

                    ushort[] convertedFloat;
                    if (fResult == true)
                    {
                        convertedFloat = floatToIntegersForRegisters(parsedFloat);
                    }
                    else
                    {
                        convertedFloat = floatToIntegersForRegisters(0.0F);

                    }
                    returnData[counter] = convertedFloat[0];
                    returnData[counter + 1] = convertedFloat[1];
                    counter += 2;
                }


                return returnData;
            }
            catch(Exception Ex)
            {
                Logger.WriteInternalLogFile("Error: in ModbusTelemetry Array (Modbus) Ex = " + Ex.ToString());
                Logger.WriteLogFile("Error: in ModbusTelemetry Array (Modbus) Ex = " + Ex.ToString());
                //Logger.WriteErrorFile("Error: in ModbusTelemetry Array (modbus) ");

                ushort[] returnData = new ushort[(1 * 2)];
                return returnData;
            }
        }

        public static ushort[] ModbusTelemetryArrayLiveData(List<double> data)
        {
            try
            {
                ushort[] returnData = new ushort[(data.Count) * 2];
                int counter = 0;
                for (int i = 0; i < data.Count; i++)
                {
                    float parsedFloat = (float)data[i];    //float.Parse(data[i]);
                    ushort[] convertedFloat = floatToIntegersForRegisters(parsedFloat);

                    returnData[counter] = convertedFloat[0];
                    returnData[counter + 1] = convertedFloat[1];
                    counter += 2;
                }


                return returnData;
            }
            catch (Exception Ex)
            {
                Logger.WriteInternalLogFile("Error in ModbusTelemetry Array Live Data (modbus) Ex = " + Ex.ToString());
                ushort[] returnData = new ushort[(1 * 2)];
                return returnData;
            }
        }




        /// <summary>
        /// This method takes a ushort array of data and writes it to consecutive modbus registers
        /// </summary>
        /// <param name="dataStore">
        /// The dataStore object used by the modbus registers
        /// </param>
        /// <param name="dataToWrite">
        /// the ushort array of data you want to write
        /// </param>
        /// <param name="startAddress">
        /// The first modbus register address you would like to write to
        /// </param>
        public static void updateModbusSlaveRegisters(DataStore dataStore, ushort[] dataToWrite, int startAddress)
        {
            if (Properties.Settings.Default.OutputPin7 == false)  //only write to modbus addresses if output toggle pin 7 is false
            {
                try
                {

                    for (int i = 0; i < dataToWrite.Length; i++) //we want to start at address = 1 to make modbus happy but need to get all the values written 
                    {

                        dataStore.HoldingRegisters[startAddress] = dataToWrite[i];
                        startAddress++;
                    }
                }
                catch (Exception Ex)
                {
                    Logger.WriteInternalLogFile("Error in ModbusTelemetry Array (modbus) Ex = " + Ex.ToString());

                }
            }


        }


    }









    /// <summary>
    /// This class is for writing data to the adapt database 
    /// The key tables that need to be updated are: 
    ///     * dateTime
    ///     * xactData
    ///     * instrumentStatusData
    ///     * windData
    /// </summary>
    public partial class AdaptDB
    {


        /// <summary>
        /// Creates a connection to the adapt database 
        /// </summary>
        /// <param name="dbPath">
        /// The path for the adapt database 
        /// </param>
        public void DBConnection(string dbPath, out SQLiteConnection dbConnection)
        {
            dbConnection = null;
            try
            {
                //string ldbPath = "C:\\XactControl\\Adapt\\adapt.db";

                dbConnection = new SQLiteConnection("Data Source="+dbPath+";Version=3;");
                if(dbConnection ==null)
                {
                    Logger.WriteLogFile( "dbConnection invalid", "c:/temp/adaptlog.txt");

                }
               
                //dbConnection = new SQLiteConnection("Data Source=C:\\XactControl\\Adapt\\adapt.db" + ";Version=3;");  //works!
                //C:\XactControl\Adapt
                dbConnection.Open();
            }
            catch(Exception Ex)
            {
                Logger.WriteErrorFile("Error: in database connection.");
                Logger.WriteInternalLogFile("Error: in database connection.  Ex = "+Ex.ToString());
                Logger.WriteLogFile("Error: in database connection.  Ex = " + Ex.ToString());
            }
        }






        /// <summary>
        /// Updates the dateTime table on the adapt db
        /// </summary>
        /// <param name="dbConnection"></param>
        /// <param name="data"></param>
        public void updateDateTime(SQLiteConnection dbConnection, List<string> data, List<string> instrumentData)
        {

            string dateTime = data[0];
            string checkDateTimeTable = String.Format("select date_time from dateTime where date_time like {0}", dateTime);
            SQLiteCommand dateTimeRedundancy = new SQLiteCommand(checkDateTimeTable, dbConnection);
            SQLiteDataReader reader = dateTimeRedundancy.ExecuteReader();
            string sampleTime;
            try
            {
                //the value of 17 needs to be checked vs changes in output file
                if (instrumentData.Count >= 17)
                {
                    try
                    {
                        sampleTime = instrumentData[16];
                    }
                    catch
                    {
                        sampleTime = "";

                    }
                    int valid = 0;
                    try
                    {
                        if (Convert.ToInt32(sampleTime) == 5)
                        {
                            valid = 1;
                        }
                        else if (Convert.ToInt32(sampleTime) == 15)
                        {
                            valid = 1;
                        }
                        else if (Convert.ToInt32(sampleTime) == 30)
                        {
                            valid = 1;
                        }
                        else if (Convert.ToInt32(sampleTime) == 60)
                        {
                            valid = 1;
                        }
                        else if (Convert.ToInt32(sampleTime) == 120)
                        {
                            valid = 1;
                        }
                        //else if (Convert.ToInt32(sampleTime) == 180)
                        //{
                        //    valid = 1;
                        //}
                        else if (Convert.ToInt32(sampleTime) == 240)
                        {
                            valid = 1;
                        }
                        else
                        {
                            valid = 0;
                        }
                    }
                    catch
                    {
                        sampleTime = "0";
                    }
                    if(valid==0)
                    {

                        sampleTime = "0";
                    }

                }
                else if (instrumentData.Count <= 1)
                {
                    sampleTime = instrumentData[0];
                }
                else if (instrumentData.Count<=2)
                {
                    sampleTime = instrumentData[1];
                }
                else
                {
                    sampleTime="0";
                }
            }
            catch (Exception Ex)
            {
                sampleTime = "0";
                Logger.WriteErrorFile("Error in update sample time (adapt db)  Ex = " + Ex.ToString());
            }
            string sampleTime_pk;

            //querry database pk 

            string getPKstring = String.Format("SELECT pk FROM sampleTime where sample_time like {0} ", sampleTime);
            SQLiteCommand getPK = new SQLiteCommand(getPKstring, dbConnection);
            sampleTime_pk = Convert.ToString(getPK.ExecuteScalar());


            List<string> dateTimeList = new List<string>();

            while (reader.Read())
            {
                dateTimeList.Add(reader.GetInt64(0).ToString());
            }
            reader.Close();


            if (dateTimeList.Count >= 0)  // this appears to be invalid? was >=1, change to >=0, 06.14.2019

            {
                try
                {
                    string sendDateTime = String.Format("insert into dateTime(date_time, sampleTime_pk, sample_completeness) values({0}, {1}, 99)", dateTime, sampleTime_pk);
                    SQLiteCommand insertDateTime = new SQLiteCommand(sendDateTime, dbConnection);
                    insertDateTime.ExecuteNonQuery();
                }
                catch (Exception ex)
                {

                    //Console.WriteLine("dateTime update failed\n");
                    Logger.WriteErrorFile("Error in UpdateDateTime (adapt.db).  Write failure.  Ex = " + ex.ToString());
                  //  Logger.WriteLogFile("Error in UpdateDateTime (adapt.db).  Write failure.  Ex = " + ex.ToString());
                }
            }

            else
            {
                //Console.WriteLine("dateTime update failed\n");
                Logger.WriteErrorFile("Error in UpdateDateTime.  DateTime already exists in this database.");
                //Logger.WriteLogFile("Error in UpdateDateTime.  DateTime already exists in this database.");
            }




        }


        /// <summary>
        /// updates the xactData table on the adapt db 
        /// </summary>
        /// <param name="dbConnection"></param>
        /// <param name="data"></param>
        public void updateXactData(SQLiteConnection dbConnection, List<string> data, List<string> instrumentData)
        {

            List<string> valuesForDatabase = new List<string>();

            string dateTime_pk = data[0];
            string concentration;
            string concentration_err;
            string analyte_pk;
            string concUnits_pk = "1"; // ng/m^3 
            string mdl_exp;

            try
            {

                //string sampleTime = instrumentData[17];
                string sampleTime;
                if (instrumentData.Count >= 17)
                {
                    sampleTime = instrumentData[16];

                }
                else if (instrumentData.Count <= 2)
                {
                    sampleTime = instrumentData[1];
                }
                else
                {
                    sampleTime = "0";
                }

                string sampleTime_pk;

                //querry database pk 
                string getPKstring = String.Format("SELECT pk FROM sampleTime where sample_time like {0} ", sampleTime);
                SQLiteCommand getPK = new SQLiteCommand(getPKstring, dbConnection);
                sampleTime_pk = Convert.ToString(getPK.ExecuteScalar());

                //create the db command strings from the data 

                if ((data.Count - 1) % 5 == 0)
                {


                    // this starting at six below 06.14.2019
                    //
                    for (int i = 1; i < data.Count; i += 5)
                    {
                        analyte_pk = data[i + 1];
                        concentration_err = data[i + 3];
                        concentration = data[i + 4];


                        //querry database for mdl_exp
                        string getMDLstring = String.Format("SELECT mdl_exp FROM mdl WHERE sampleTime_pk = {0} AND analyte_pk = {1};", sampleTime_pk, analyte_pk);
                        SQLiteCommand getMDL = new SQLiteCommand(getMDLstring, dbConnection);
                        mdl_exp = Convert.ToString(getMDL.ExecuteScalar());

                        if (mdl_exp.Length > 0)
                        { 
                            valuesForDatabase.Add(String.Format("insert into xactData(concentration, concentration_err, mdl_exp, dateTime_pk, analyte_pk, concUnits_pk)  values ({0}, {1}, {2}, {3}, {4}, {5})",
                            concentration, concentration_err, mdl_exp, dateTime_pk, analyte_pk, concUnits_pk));

                     //       valuesForDatabase.Add(String.Format("insert into xactData(concentration, concentration_err, mdl_exp, dateTime_pk, analyte_pk, concUnits_pk)  values ({0}, {1}, {2}, {3}, {4})",
                     //       concentration, concentration_err, mdl_exp, dateTime_pk,  concUnits_pk));

                        }
                        else
                        {
                            valuesForDatabase.Add(String.Format("insert into xactData(concentration, concentration_err, mdl_exp, dateTime_pk, analyte_pk, concUnits_pk)  values ({0}, {1}, {2}, {3}, {4}, {5})",
                            concentration, concentration_err, "1.0", dateTime_pk, analyte_pk, concUnits_pk));
                        }

                    }

                    for (int i = 0; i < valuesForDatabase.Count; i++)
                    {

                        SQLiteCommand insertIntoTable = new SQLiteCommand(valuesForDatabase[i], dbConnection);
                        insertIntoTable.ExecuteNonQuery();
                    }
                }

                else
                {
                    //Console.WriteLine("The length is incorrect");
                    Logger.WriteErrorFile("Error in update xact data.  The length is incorrect.");

                }
            }
            catch(Exception Ex)
            {
                Logger.WriteErrorFile("Error: in update xact data to data base.");
                Logger.WriteInternalLogFile("Error: in update xact data to data base.  Ex = " + Ex.ToString());
                Logger.WriteLogFile("Error: in update xact data to data base.  Ex = " + Ex.ToString());
            }


        }




        /// <summary>
        /// update the instrumentStatusData table on adapt db
        /// </summary>
        /// <param name="dbConnection"></param>
        /// <param name="data"></param>
        public void updateInstrumentStatusData(SQLiteConnection dbConnection, List<string> conc_and_dateTime, List<string> instrumentData)
        {


            //set up column names

            //string atm_temp = instrumentData[1];
            //string atm_press = instrumentData[3];
            //string tape_press = instrumentData[4];
            //string samp_temp = instrumentData[2];
            //string samp_rh = instrumentData[14]; // to be fixed later 
            //string flow_act = instrumentData[6];
            //string volume = instrumentData[8];
            //string tube_temp = instrumentData[9];
            //string enc_temp = instrumentData[10];
            //string dateTime_pk = conc_and_dateTime[0];
            //string flow_act_qa = "0.0";

            string atm_temp = instrumentData[0];
            string samp_temp = instrumentData[1];
            string atm_press = instrumentData[2];
            string tape_press = instrumentData[3];
            string flow_act = instrumentData[5];
            string volume = instrumentData[7];
            string tube_temp = instrumentData[8];
            string enc_temp = instrumentData[9];
            string samp_rh = instrumentData[13];  
            string dateTime_pk = conc_and_dateTime[0];
            string flow_act_qa = "0.0";



            //create the command string
            string valuesForDatabase = String.Format("insert into instrumentStatusData(atm_temp, atm_press, tape_press, samp_temp, flow_act, volume, tube_temp, enc_temp, dateTime_pk, flow_act_qa, samp_rh) values ({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10})", atm_temp, atm_press, tape_press, samp_temp, flow_act, volume, tube_temp, enc_temp, dateTime_pk, flow_act_qa, samp_rh);
            SQLiteCommand insertIntoTable = new SQLiteCommand(valuesForDatabase, dbConnection);

            try
            {
                insertIntoTable.ExecuteNonQuery();
            }
            catch (Exception Ex)
            {
                //Console.WriteLine("Couldn't update instrumentStatusData");
                Logger.WriteErrorFile("Could not update instrument status data in adapt db.  Ex= "+Ex.ToString());
                Logger.WriteInternalLogFile("Could not update instrument status data in adapt db.  Ex= " + Ex.ToString());
            }


        }




        /// <summary>
        /// updates the windData table on the adapt db
        /// </summary>
        /// <param name="dbConnection"></param>
        /// <param name="conc_and_dateTime"></param>
        /// <param name="instrumentData"></param>
        public void updateWindData(SQLiteConnection dbConnection, List<string> conc_and_dateTime, List<string> instrumentData)
        {
            string wind_speed = instrumentData[14];  //15
            string wind_dir = instrumentData[15];   //16   
            string windDirUnits_pk = "1";
            string windSpeedUnits_pk = "4";  //   [m/s] may need to add some logic to parse from wind sensor string 
            string dateTime_pk = conc_and_dateTime[0];

            //create the command string 
            string valuesForDatabase = String.Format("insert into windData (wind_speed, wind_dir, windDirUnits_pk, windSpeedUnits_pk, dateTime_pk) values ({0}, {1}, {2}, {3}, {4})", wind_speed, wind_dir, windDirUnits_pk, windSpeedUnits_pk, dateTime_pk);
            SQLiteCommand insertIntoTable = new SQLiteCommand(valuesForDatabase, dbConnection);

            try
            {
                insertIntoTable.ExecuteNonQuery();
            }

            catch (Exception ex)
            {
                //Console.WriteLine("Couldn't update windData");
                Logger.WriteInternalLogFile("Error in UpdateWindData.  Ex = " + ex.ToString());
                
            }
        }

    }



    /// <summary>
    /// Perform the necessary error and operation logging
    /// </summary>
    public static partial class Logger
    {

        //private static StreamWriter ErrorFile = new StreamWriter("c:\\temp\\ErrorFile01.txt", true);
        //multithreaded file write....
        private static ReaderWriterLockSlim _readWriteLock = new ReaderWriterLockSlim();


        public static string GetTimeStampStr(int includeMs)
        {

            DateTime timeStamp;
            timeStamp = DateTime.Now;

            if (includeMs == 1)
            {
                return timeStamp.ToString("MM/dd/yyyy  HH:mm:ss:ffff ");
            }
            else
            {
                return timeStamp.ToString("MM/dd/yyyy  HH:mm:ss ");

            }

        }

        public static string GetTimeStampStr2()
        {

            DateTime timeStamp;
            timeStamp = DateTime.Now;
            return timeStamp.ToString("MM/dd/yyyy_HH:mm:ss");

        }


        /// <summary>
        ///  this implements thread safe error file write
        /// 
        /// </summary>
        /// <param name="errorMessage"></param>
        public static void WriteErrorFile(string errorMessage)
        {
            string strDateTime;



            strDateTime = Logger.WriteErrorsAndWarningsFile(errorMessage);
            DataContainer.StatusDisplayErrorMessage = strDateTime +"  "+errorMessage;

        }


        /// <summary>
        ///  this implements thread safe error file write
        /// 
        /// </summary>
        /// <param name="warningMessage"></param>
        private static string WriteErrorsAndWarningsFile(string Message)
        {
            string pathFileName=string.Empty;
            string strTime=string.Empty;

         
            pathFileName = "C:\\temp\\ErrorsAndWarnings_"+Form1.ErrorsAndWarningsFileNumber.ToString()+ ".txt";

            long length = 0;

            try
            {
                length = new System.IO.FileInfo(pathFileName).Length;
            }
            catch (Exception)
            {
                //this would call this routine which is invalid
                //Logger.WriteErrorFile("Ex in get length of uC file.  Ex = " + Ex.ToString());
            }
                         
            if (length > 1000000)
            {
                Form1.ErrorsAndWarningsFileNumber++;
                pathFileName = "C:\\temp\\ErrorsAndWarnings_" + Form1.ErrorsAndWarningsFileNumber.ToString() + ".txt";
            }


            strTime = GetTimeStampStr(0); //0===no ms in date time string



            try
            {
                _readWriteLock.EnterWriteLock();
                using (StreamWriter swError = new StreamWriter(pathFileName, true))
                {
                    swError.WriteLine("{0}   {1}", strTime, Message);
                    swError.Close();
                }
                return strTime;
            }
            catch
            {
                return String.Empty;
            }
            finally
            {
                _readWriteLock.ExitWriteLock();
            }




        }







        /// <summary>
        ///  this implements thread safe error file write
        /// 
        /// </summary>
        /// <param name="warningMessage"></param>
        public static void WriteWarningFile(string warningMessage)
        {
            string strDateTime;

            strDateTime = Logger.WriteErrorsAndWarningsFile(warningMessage);
            DataContainer.StatusDisplayWarningMessage = strDateTime + " " + warningMessage;


        }



        /// <summary>
        ///  this implements thread safe error file write
        /// 
        /// </summary>
        /// <param name="errorMessage"></param>
        public static void WriteInternalLogFile(string errorMessage)
        {
            string pathFileName;
            string strTime;

            //Roll file by date:
            //DateTime now = new DateTime();
            //now = DateTime.Now;
            //if (now.Day > Form1.DateTimeFromStartButtonInternalLog.Day)
            //{
            //    Form1.DateTimeFromStartButtonInternalLog = DateTime.Now;
            //    pathFileName = "C:\\CES\\InternalLog\\InternalLog_" + Form1.DateTimeFromStartButtonInternalLog.ToString("MM_dd_yyyy__HH_mm_ss__") + Form1.fileNoForInternalLog.ToString() + ".txt";
            //    Form1.fileNoForInternalLog = 0;
            //}
            //else
            //{
            //    pathFileName = "C:\\CES\\InternalLog\\InternalLog_" + Form1.DateTimeFromStartButtonInternalLog.ToString("MM_dd_yyyy__HH_mm_ss__") + Form1.fileNoForInternalLog.ToString() + ".txt";
            //}
            

            pathFileName = "C:\\CES\\InternalLog\\InternalLog_" + Form1.DateTimeFromStartButtonInternalLog.ToString("MM_dd_yyyy__HH_mm_ss__") + Form1.fileNoForInternalLog.ToString() + ".txt";

            long length = 0;

            try
            {
                length = new System.IO.FileInfo(pathFileName).Length;
            }
            catch (Exception )
            {
                //this would call this routine...
                //Logger.WriteInternalLogFile("Ex in get length of uC file.  Ex = " + Ex.ToString());
            }
            if (length > 50000000)
            {
                Form1.fileNoForInternalLog += 1;
                pathFileName = "C:\\CES\\InternalLog\\InternalLog_" + Form1.DateTimeFromStartButtonInternalLog.ToString("MM_dd_yyyy__HH_mm_ss__" + Form1.fileNoForInternalLog.ToString()) + ".txt";
            }


            strTime = GetTimeStampStr(1);

            try
            {
                _readWriteLock.EnterWriteLock();
                using (StreamWriter swWrite = new StreamWriter(pathFileName, true))
                {
                    swWrite.WriteLine("{0}   {1}", strTime, errorMessage);
                    swWrite.Close();
                }
            }
            catch
            {

            }
            finally
            {
                _readWriteLock.ExitWriteLock();
            }
        }


        public static void WriteLogFile(string Message, string pathFileName="c:/temp/acquisition.txt")//, string pathFileName = "C:/temp/Acquisition.txt")
        {

            string strTime;
            string pathFileNameNew;
            string[] elementItems = pathFileName.Split('.');

            
            
            pathFileNameNew = elementItems[0] + "__" + Form1.DateTimeFromStartButton.ToString("MM_dd_yyyy__HH_mm_ss__") + Form1.fileNoForLogFile + "." + elementItems[1];
            

            long length = 0;

            try
            {
                length = new System.IO.FileInfo(pathFileNameNew).Length;
            }
            catch (Exception )
            {
                //this would call this routine...
                //Logger.WriteInternalLogFile("Ex in get length of uC file.  Ex = " + Ex.ToString());
            }
            if (length > 50000000)
            {
                Form1.fileNoForLogFile += 1;
                //pathFileName = "C:\\CES\\InternalLog\\InternalLog_" + Form1.DateTimeFromStartButtonInternalLog.ToString("MM_dd_yyyy__HH_mm_ss__" + Form1.fileNoForInternalLog.ToString()) + ".txt";
                pathFileNameNew = elementItems[0] + "__" + Form1.DateTimeFromStartButton.ToString("MM_dd_yyyy__HH_mm_ss__") + Form1.fileNoForLogFile + "." + elementItems[1];

            }



            strTime = GetTimeStampStr(1);

            try
            {
                _readWriteLock.EnterWriteLock();
                using (StreamWriter swLogFile = new StreamWriter(pathFileNameNew, true))
                {
                    swLogFile.WriteLine("{0} Message:  {1}", strTime, Message);
                    swLogFile.Close();
                }
            }
            catch
            {

            }
            finally
            {
                _readWriteLock.ExitWriteLock();
            }
        }

        /*
        /// <summary>
        ///  this implements thread safe info/warning file write
        ///  must pass in the path\\filename of the file
        ///  
        /// </summary>
        /// <param name="Message"></param>
        public static void WriteLogFile(string pathFileName, string Message)//, string pathFileName = "C:/temp/Acquisition.txt")
        {


            string strTime;
            string pathFileNameNew;


            string[] elementItems = pathFileName.Split('.');

            //"C:/temp/acquisition"  "txt"

            pathFileNameNew = elementItems[0] + "__" + Form1.DateTimeFromStartButton.ToString("MM_dd_yyyy__HH_mm_ss__")+Form1.fileNoForLogFile + "."+elementItems[1];


            long length = 0;

            try
            {
                length = new System.IO.FileInfo(pathFileNameNew).Length;
            }
            catch (Exception Ex)
            {
                //this would call this routine...
                //Logger.WriteInternalLogFile("Ex in get length of uC file.  Ex = " + Ex.ToString());
            }
            if (length > 50000000)
            {
                Form1.fileNoForLogFile += 1;
                //pathFileName = "C:\\CES\\InternalLog\\InternalLog_" + Form1.DateTimeFromStartButtonInternalLog.ToString("MM_dd_yyyy__HH_mm_ss__" + Form1.fileNoForInternalLog.ToString()) + ".txt";
                pathFileNameNew = elementItems[0] + "__" + Form1.DateTimeFromStartButton.ToString("MM_dd_yyyy__HH_mm_ss__") + Form1.fileNoForLogFile + "." + elementItems[1];

            }



            strTime = GetTimeStampStr();

            try
            {
                _readWriteLock.EnterWriteLock();
                using (StreamWriter sw = new StreamWriter(pathFileNameNew, true))
                {
                    sw.WriteLine("{0} Message:  {1}", strTime, Message);
                    sw.Close();
                }
            }
            catch
            {

            }
            finally
            {
                _readWriteLock.ExitWriteLock();
            }
        }
        */

        //Test: Save Settings
        public static void SaveSetting(string settingValue)
        {
            string pathFileName;
            pathFileName = "C:/CES/UserSettings/settings.ini";
            try
            {
                _readWriteLock.EnterWriteLock();
                using (StreamWriter sw = new StreamWriter(pathFileName, true))
                {
                    sw.WriteLine(settingValue);
                    sw.Close();
                }

            }
            catch (Exception ex)
            {
                Logger.WriteInternalLogFile("Error: Unable to save settings. Ex = " + ex.ToString());
            }
            finally
            {
                _readWriteLock.ExitWriteLock();
            }
        }







    }



    public static class DataContainer
    {
        public static string StatusDisplayErrorMessage;
        public static string StatusDisplayWarningMessage;

        public static Int32 displayItem;
    }

    public static class PassContainer
    {
        static public bool passwordValid;
        static public bool enableOneTime;
        static public int entryRetries;
        static public DateTime pwStart;
        static public DateTime pwEnd;


    }

}
